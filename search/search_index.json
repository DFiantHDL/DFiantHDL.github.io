{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DFiant HDL (DFHDL) Docs","text":"<p>The Official DFiant Hardware Description Language (DFHDL) Documentation</p> <p> </p> <p>Welcome to the DFiant hardware description language (DFHDL) documentation! </p> <p>DFHDL is a dataflow HDL and is embedded as a library in the Scala programming language. DFiant enables timing-agnostic and device-agnostic hardware description by using dataflow firing rules as logical constructs, coupled with modern software language features (e.g., inheritance, polymorphism, pattern matching) and classic HDL features (e.g., bit-accuracy, input/output ports). Additionally, DFHDL integrates two additional levels of hardware description abstractions: register-transfer (RT), which is equivalent to languages like Chisel and Amaranth; and event-driven (ED), which is equivalent to Verilog and VHDL. </p> <p> Get started</p> <p> Read more about the technology</p> <p> Run examples in your browser</p>"},{"location":"#documentation-status","title":"Documentation Status","text":"<p>We are actively working on a comprehensive user guide. We hope to be releasing it in the coming days.</p> <p>In the meanwhile, checkout our getting-started guide, to setup your system and try out a basic example. Additionally, we placed several examples under the Run In Browser section of the documentation, where you can try them right now.</p>"},{"location":"#required-knowledge","title":"Required Knowledge","text":"<p>You are not required to know Scala, yet you are expected to understand basic object oriented concepts. This documentation attempts to bridge over any syntactic gaps you may arrive at. Nonetheless, as you attempt to create more complex and generic designs, more Scala knowledge will be required of you.</p> <p>You are not required to be an FPGA/ASIC expert, yet you are expected to understand fundamental hardware description concepts found in languages such as Verilog and VHDL.  </p> <p>You are required to keep an open mind. Some of these concepts may seem strange at first, but they were set after careful thought and planning. However, we are not infallible so feel free to file an issue with questions and/or suggestions of different approaches we can take.</p>"},{"location":"about/LICENSE/","title":"License","text":"<p>Copyright (c) 2021 DFiant Inc.</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> GNU Lesser General Public License version 3 <pre><code>                    GNU LESSER GENERAL PUBLIC LICENSE\n                        Version 3, 29 June 2007\n\n  Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n  Everyone is permitted to copy and distribute verbatim copies\n  of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n    a) under this License, provided that you make a good faith effort to\n    ensure that, in the event an Application does not supply the\n    function or data, the facility still operates, and performs\n    whatever part of its purpose remains meaningful, or\n\n    b) under the GNU GPL, with none of the additional permissions of\n    this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n    a) Give prominent notice with each copy of the object code that the\n    Library is used in it and that the Library and its use are\n    covered by this License.\n\n    b) Accompany the object code with a copy of the GNU GPL and this license\n    document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n    a) Give prominent notice with each copy of the Combined Work that\n    the Library is used in it and that the Library and its use are\n    covered by this License.\n\n    b) Accompany the Combined Work with a copy of the GNU GPL and this license\n    document.\n\n    c) For a Combined Work that displays copyright notices during\n    execution, include the copyright notice for the Library among\n    these notices, as well as a reference directing the user to the\n    copies of the GNU GPL and this license document.\n\n    d) Do one of the following:\n\n        0) Convey the Minimal Corresponding Source under the terms of this\n        License, and the Corresponding Application Code in a form\n        suitable for, and under terms that permit, the user to\n        recombine or relink the Application with a modified version of\n        the Linked Version to produce a modified Combined Work, in the\n        manner specified by section 6 of the GNU GPL for conveying\n        Corresponding Source.\n\n        1) Use a suitable shared library mechanism for linking with the\n        Library.  A suitable mechanism is one that (a) uses at run time\n        a copy of the Library already present on the user's computer\n        system, and (b) will operate properly with a modified version\n        of the Library that is interface-compatible with the Linked\n        Version.\n\n    e) Provide Installation Information, but only if you would otherwise\n    be required to provide such information under section 6 of the\n    GNU GPL, and only to the extent that such information is\n    necessary to install and execute a modified version of the\n    Combined Work produced by recombining or relinking the\n    Application with a modified version of the Linked Version. (If\n    you use option 4d0, the Installation Information must accompany\n    the Minimal Corresponding Source and Corresponding Application\n    Code. If you use option 4d1, you must provide the Installation\n    Information in the manner specified by section 6 of the GNU GPL\n    for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n    a) Accompany the combined library with a copy of the same work based\n    on the Library, uncombined with any other library facilities,\n    conveyed under the terms of this License.\n\n    b) Give prominent notice with the combined library that part of it\n    is a work based on the Library, and explaining where to find the\n    accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n</code></pre>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>We would like to thank the opensource community, namely the Scala community, and great many others for their work and support!</p> Previous version EU support <p>Previous version of this work (simply called \"DFiant\" at the time) has been supported by EU H2020 ICT project LEGaTO, contract #780681.</p> <p></p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>We will most likely adopt the code of conduct of Django. </p> <p>This page will be updated soon.</p> <p>Our Stance on Opensource</p> <p>We are standing on the shoulders of giants, so lets at least wipe down our feet first.   Be kind, be respectful, and take no-one and nothing for granted.</p>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#v010","title":"v0.1.0","text":"<p>This is the first official version release of DFiant.</p>"},{"location":"getting-started/hello-world/","title":"Hello Hardware World","text":""},{"location":"getting-started/hello-world/#the-basic-dfhdl-program","title":"The Basic DFHDL Program","text":"<p>Since DFHDL is a Scala library, we are creating a Scala program that takes DFHDL designs and compiles (transpiles) them into lower representations (e.g., VHDL or Verilog). As such, some of DFHDL's compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. The Scala code below describes a program that runs the DFHDL compiler on an 8-bit overlapping counter design, <code>Counter8</code>. </p> <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> <p>Writing a DFHDL compilation program \u2013 as easy as 01-10-11!</p> <ol> <li><code>import dfhdl.*</code> once per source file, to import all the required namespace objects, types, and functionality.</li> <li><code>class _design_name_ extends RTDesign:</code> to define your register-transfer (RT) domain design. Populate your design with the required interface and functionality. DFHDL supports two additional design domains: dataflow (DF), and event-driven (ED).</li> <li>Add <code>@top</code> annotation to your top-level design (e.g., <code>@top class top_design_name_ ...</code>) to automatically create a compilation program entry point for the design, instantiate it, elaborate it, compile it to Verilog or VHDL (see compiler options), and finally commit the files to disk.</li> </ol>"},{"location":"getting-started/hello-world/#run-it-in-your-browser","title":"Run It In Your Browser","text":"Run it here <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> <p>For more examples that are available to run in your browser, see the relevant section.</p>"},{"location":"getting-started/hello-world/#run-it-on-your-system","title":"Run It On Your System","text":"<p>To run this example on your system, make sure to first follow the initial setup instructions.</p> <p>You have several options to run Scala programs on your system:</p> <ul> <li>For this simple <code>Counter8</code> example, you can just use the simplest scala-single-file approach. </li> <li>For common DFHDL projects, we recommend using the scala project approach. </li> <li>For complex, full-production DFHDL projects, you may need to use an sbt project, but this is usually not required.</li> </ul>"},{"location":"getting-started/hello-world/#scala-single-file","title":"Scala Single File","text":"View the scala single file example Counter8.scala<pre><code>//&gt; using scala 3.6.3\n//&gt; using dep io.github.dfianthdl::dfhdl::0.9.2\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.9.2\n//&gt; using option -deprecation -language:implicitConversions\n\nimport dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> Download and run in your terminal<pre><code>curl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-single-file/Counter8.scala\nscala run ./Counter8.scala\n</code></pre> <p>For more information, please run <code>scala run --help</code> or consult the online documentation.</p>"},{"location":"getting-started/hello-world/#scala-project","title":"Scala Project","text":"View the scala project files example projectFolder/project.scala<pre><code>//&gt; using scala 3.6.3\n//&gt; using dep io.github.dfianthdl::dfhdl::0.9.2\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.9.2\n//&gt; using option -deprecation -language:implicitConversions\n</code></pre> projectFolder/Counter8.scala<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> Download and run in your terminal<pre><code>curl -o project.scala https://dfianthdl.github.io/getting-started/hello-world/scala-project/project.scala\ncurl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-project/Counter8.scala\nscala run .\n</code></pre> <p>For more information, please run <code>scala run --help</code> or consult the online documentation.</p>"},{"location":"getting-started/hello-world/#sbt-project","title":"sbt Project","text":"<p>The best way to get started with a DFHDL sbt project is to clone our template from GitHub:</p> Clone and run in your terminal<pre><code>git clone https://github.com/DFiantHDL/dfhdl-template\ncd dfhdl-template\nsbt run\n</code></pre> <p>For more information, please consult the sbt documentation.</p>"},{"location":"getting-started/hello-world/#recommended-scala-formatting-for-dfhdl","title":"Recommended Scala Formatting for DFHDL","text":"<p>We recommend actively using Scalafmt, a code formatter for Scala that integrates well with your toolchain. The following setting is recommended for DFHDL designs:</p> View the Scalafmt recommended configuration file projectFolder/.scalafmt.conf<pre><code>version = 3.8.3\nrunner.dialect = scala3\n\nmaxColumn = 100\nalign.tokens = [{code = \"&lt;&gt;\"}, {code = \"=\"}, {code = \"=&gt;\"}, {code = \":=\"}, {code = \":==\"}]\nrewrite.scala3.removeOptionalBraces = oldSyntaxToo\nrewrite.scala3.insertEndMarkerMinLines = 15\n\nbinPack.literalArgumentLists = true\nbinPack.literalsMinArgCount = 5\nbinPack.literalsInclude = [\".*\"]\nbinPack.literalsIncludeSimpleExpr = true\nbinPack.literalsSingleLine = false\n\nnewlines.selectChains = keep\n</code></pre> Download it via your terminal<pre><code>curl -o .scalafmt.conf https://dfianthdl.github.io/getting-started/hello-world/scala-project/.scalafmt.conf\n</code></pre> <p>For more information, please consult the Scalafmt documentation.</p>"},{"location":"getting-started/initial-setup/","title":"Initial Setup","text":"<p>DFHDL is a domain specific language (DSL) library written in the Scala programming language (Scala 3.6.3), and as such it lets you utilize the entire Scala ecosystem, including IDEs, various tools, and other libraries. </p> <p>Is your system already fit for Scala development? Jump to the DFHDL hello-world section</p>"},{"location":"getting-started/initial-setup/#installing-scala-and-other-dependencies","title":"Installing Scala and Other Dependencies","text":"<p>We recommend directly installing Scala 3.6.3 (no need to install either Coursier, Scala CLI, or sbt):</p> <ul> <li> <p> Windows Instructions</p> Using Chocolatey <p>Run the following in Windows command or powershell:</p> <pre><code>choco install scala --version=3.6.3 \n</code></pre> </li> <li> <p> Linux Instructions</p> Using SDKMAN! <p>Run the following in your shell:</p> <pre><code>sdk install scala 3.6.3 \n</code></pre> </li> <li> <p> macOS Instructions</p> Using Homebrew <p>Run the following in your shell:</p> <pre><code>brew update\nbrew install scala\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>If for some reason the instructions above don't work for you, you can try to install Scala via Coursier using the information below.</p> </li> </ul> Installing Scala via Coursier <p>We recommend directly installing Scala, as instructed above. However, if you are experiencing issues, you can try installing Scala via Coursier, as follows:</p> <ul> <li> <p> Windows Instructions</p> ManualCMDPowershell <ol> <li> <p>Download the installer zip file.</p> </li> <li> <p>Open the zip.</p> </li> <li> <p>Double click the <code>cs-x86_64-pc-win32.exe</code> executable to extract and run Coursier setup.</p> </li> </ol> <p>Run the following in Windows command:</p> <pre><code>curl -fLo cs-x86_64-pc-win32.zip https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\ntar -xf cs-x86_64-pc-win32.zip\nmove cs-x86_64-pc-win32.exe cs.exe\n.\\cs setup\n</code></pre> <p>Run the following in Windows Powershell:</p> <pre><code>Invoke-WebRequest -Uri \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\" -OutFile \"cs-x86_64-pc-win32.zip\"\nExpand-Archive -Path \"cs-x86_64-pc-win32.zip\"\nRename-Item -Path \"cs-x86_64-pc-win32.exe\" -NewName \"cs.exe\"\nRemove-Item -Path \"cs-x86_64-pc-win32.zip\"\n.\\cs setup\n</code></pre> </li> <li> <p> Linux Instructions</p> x86-64 (aka AMD64)ARM64Other linux <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p> Goto Coursier's website</p> </li> <li> <p> macOS Instructions</p> via Brewaarch64 (M1,M2,...)x86-64 <p>Run the following in your shell:</p> <pre><code>brew install coursier/formulas/coursier\ncs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/coursier/launchers/raw/master/cs-x86_64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>For other OS or instructions please consult the Coursier website.</p> <p> Goto Coursier's website</p> </li> </ul>"},{"location":"getting-started/initial-setup/#ide-setup","title":"IDE Setup","text":"<p>Many IDEs support Scala development. The most popular are VS Code and IntelliJ IDEA. We recommend VS Code with the Metals plugin.</p> <p>Here is a summary of relevant IDEs:</p> <ul> <li> <p> VS Code (Recommended)</p> <p> Download VS Code</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> IntelliJ IDEA</p> <p> Download IntelliJ via ToolBox</p> <p> Scala Development Guide</p> </li> <li> <p> Vim</p> <p> Download Vim</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Sublime Text</p> <p> Download Sublime Text</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Emacs</p> <p> Download Emacs</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Other IDE/Instructions</p> <p> For other OS or instructions please consult the Metals website.</p> </li> </ul>"},{"location":"in-browser/1-bit-full-adder/","title":"1-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; a ^ b ^ c_in\n  c_out &lt;&gt; a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/alu/","title":"ALU","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nenum ALUSel extends Encode:\n  case ADD, SUB, SLL, SRL, SRA, AND, OR, XOR, SLT, SLTU, COPY1\n\n@top class ALU extends DFDesign:\n  val op1    = Bits(32) &lt;&gt; IN\n  val op2    = Bits(32) &lt;&gt; IN\n  val aluSel = ALUSel   &lt;&gt; IN\n  val aluOut = Bits(32) &lt;&gt; OUT\n\n  private val shamt = op2(4, 0)\n\n  import ALUSel.*\n  val outCalc: Bits[32] &lt;&gt; VAL = aluSel match\n    case ADD   =&gt; op1 + op2\n    case SUB   =&gt; op1 - op2\n    case AND   =&gt; op1 &amp; op2\n    case OR    =&gt; op1 | op2\n    case XOR   =&gt; op1 ^ op2\n    case SLT   =&gt; (op1.sint &lt; op2.sint).extend\n    case SLTU  =&gt; (op1 &lt; op2).extend\n    case SLL   =&gt; op1 &lt;&lt; shamt\n    case SRL   =&gt; op1 &gt;&gt; shamt\n    case SRA   =&gt; (op1.sint &gt;&gt; shamt).bits\n    case COPY1 =&gt; op1\n    case _     =&gt; ?\n  aluOut := outCalc\nend ALU\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/counter/","title":"Counter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class Counter(val width: Int &lt;&gt; CONST = 8) extends RTDesign:\n  val en  = Bit         &lt;&gt; IN\n  val cnt = UInt(width) &lt;&gt; OUT.REG init 0\n  if (en)\n    cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/led-blinker/","title":"LED Blinker","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** This is a led blinker */\n@top class Blinker(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST = 50000,\n    val LED_FREQ_Hz: Int &lt;&gt; CONST  = 1\n) extends RTDesign:\n  /** Half-count of the toggle for 50% duty cycle */\n  val HALF_PERIOD = (CLK_FREQ_KHz * 1000) / (LED_FREQ_Hz * 2)\n\n  /** LED output */\n  val led = Bit                     &lt;&gt; OUT.REG init 1\n  val cnt = UInt.until(HALF_PERIOD) &lt;&gt; VAR.REG init 0\n  if (cnt == HALF_PERIOD - 1)\n    cnt.din := 0\n    led.din := !led\n  else cnt.din := cnt + 1\nend Blinker\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/lfsr/","title":"LFSR","text":"<pre><code>import dfhdl.*\n\nenum Ctrl extends Encode:\n  case Idle, Seed, Run\n\n/** Galois Linear-Feedback Shift Register\n  */\nclass LFSR(val taps: Bits[Int] &lt;&gt; CONST) extends RTDesign:\n  val ctrl = Ctrl &lt;&gt; IN\n  val seed = Bits(taps.width) &lt;&gt; IN\n  val calc = Bits(taps.width) &lt;&gt; OUT init all(1)\n\n  import Ctrl.*\n  ctrl match\n    case Idle =&gt; // do nothing\n    case Seed =&gt;\n      if (seed == all(0)) calc := all(1)\n      else calc := seed\n    case Run =&gt;\n      val tap = if (calc.reg(1)(0)) taps else b\"${taps.width}'0\"\n      calc := (calc.reg &gt;&gt; 1) ^ tap\nend LFSR</code></pre>"},{"location":"in-browser/n-bit-full-adder/","title":"N-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nclass FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; a ^ b ^ c_in\n  c_out &lt;&gt; a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a\n\n@top class FullAdderN(val n: Int = 4) extends EDDesign:\n  val a, b  = Bits(n) &lt;&gt; IN\n  val c_in  = Bit     &lt;&gt; IN\n  val sum   = Bits(n) &lt;&gt; OUT\n  val c_out = Bit     &lt;&gt; OUT\n\n  val adder = List.fill(n)(FullAdder1())\n  for (i &lt;- 0 until n)\n    adder(i).a   &lt;&gt; a(i)\n    adder(i).b   &lt;&gt; b(i)\n    adder(i).sum &lt;&gt; sum(i)\n    if (i &lt; n - 1)\n      adder(i).c_out &lt;&gt; adder(i + 1).c_in\n  adder.head.c_in  &lt;&gt; c_in\n  adder.last.c_out &lt;&gt; c_out\nend FullAdderN\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/reg-file/","title":"Register File","text":"<pre><code>import dfhdl.*\n\n@top class RegFile(\n    val DATA_WIDTH: Int &lt;&gt; CONST = 32,\n    val REG_NUM: Int &lt;&gt; CONST    = 32\n) extends RTDesign:\n  val regs = Bits(DATA_WIDTH) X REG_NUM &lt;&gt; VAR.REG\n\n  val rs1, rs2 = new RelatedDomain:\n    val addr = Bits.until(REG_NUM) &lt;&gt; IN\n    val data = Bits(DATA_WIDTH)    &lt;&gt; OUT.REG\n    data.din := regs(addr)\n\n  val rd = new RelatedDomain:\n    val addr = Bits.until(REG_NUM) &lt;&gt; IN\n    val data = Bits(DATA_WIDTH)    &lt;&gt; IN\n    val wren = Bit                 &lt;&gt; IN\n    if (wren) regs(addr).din := data\n    regs(0).din              := all(0) // in RISC-V x0 is always 0\nend RegFile\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/true-dpr/","title":"True Dual-Port RAM","text":"<pre><code>import dfhdl.*\n\n@top class TrueDPR(\n    val DATA_WIDTH: Int &lt;&gt; CONST = 8,\n    val ADDR_WIDTH: Int &lt;&gt; CONST = 8\n) extends EDDesign:\n  val ram = Bits(DATA_WIDTH) X (2 ** ADDR_WIDTH) &lt;&gt; VAR.SHARED\n\n  val a, b = new RTDomain:\n    val data = Bits(DATA_WIDTH) &lt;&gt; IN\n    val addr = Bits(ADDR_WIDTH) &lt;&gt; IN\n    val q    = Bits(DATA_WIDTH) &lt;&gt; OUT.REG\n    val we   = Bit              &lt;&gt; IN\n\n    if (we)\n      ram(addr) := data\n    q.din       := ram(addr)\nend TrueDPR\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/uart-tx/","title":"UART Transmitter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class UART_Tx(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST  = 50000,\n    val BAUD_RATE_BPS: Int &lt;&gt; CONST = 115200\n) extends RTDesign:\n  val data_en    = Bit             &lt;&gt; IN\n  val DATA_BITS  = 8\n  val data       = Bits(DATA_BITS) &lt;&gt; IN\n  val tx         = Bit             &lt;&gt; OUT.REG\n  val tx_en      = Bit             &lt;&gt; OUT.REG\n  val tx_done    = Bit             &lt;&gt; OUT.REG\n  val BIT_CLOCKS = CLK_FREQ_KHz * 1000 / BAUD_RATE_BPS\n\n  enum Status extends Encode.OneHot:\n    case Idle, StartBit, DataBits, StopBit, Finalize\n  import Status.*\n  val status     = Status                 &lt;&gt; VAR.REG init Idle\n  val bitClkCnt  = UInt.until(BIT_CLOCKS) &lt;&gt; VAR.REG init 0\n  val dataBitCnt = UInt.until(DATA_BITS)  &lt;&gt; VAR.REG init 0\n  val shiftData  = Bits(DATA_BITS)        &lt;&gt; VAR.REG\n\n  // To save on writing the \"bit clock count wait\" 3 times,\n  // we use DFHDL's meta-programming capability.\n  @internals.metaContextIgnore\n  def waitBitAndThen(onThreshold: =&gt; Unit): Unit =\n    if (bitClkCnt == BIT_CLOCKS - 1)\n      bitClkCnt.din := 0\n      onThreshold\n    else bitClkCnt.din := bitClkCnt + 1\n\n  status match\n    case Idle =&gt;\n      tx_en.din      := 0\n      tx.din         := 1\n      tx_done.din    := 0\n      bitClkCnt.din  := 0\n      dataBitCnt.din := 0\n      if (data_en)\n        shiftData.din := data\n        status.din    := StartBit\n\n    case StartBit =&gt;\n      tx_en.din := 1\n      tx.din    := 0\n      waitBitAndThen { status.din := DataBits }\n\n    case DataBits =&gt;\n      tx.din := shiftData.lsbit\n      waitBitAndThen {\n        shiftData.din := shiftData &gt;&gt; 1\n        if (dataBitCnt == DATA_BITS - 1)\n          dataBitCnt.din := 0\n          status.din     := StopBit\n        else dataBitCnt.din := dataBitCnt + 1\n      }\n\n    case StopBit =&gt;\n      tx.din := 1\n      waitBitAndThen {\n        tx_done.din := 1\n        status.din  := Finalize\n      }\n\n    case Finalize =&gt;\n      tx_en.din   := 0\n      tx_done.din := 1\n      status.din  := Idle\n  end match\nend UART_Tx\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"intro/technology/","title":"The DFiant Technology","text":"<p>DFiant navigates the complexities of hardware design with a nuanced approach that addresses the limitations of traditional methods. The register-transfer level (RTL) abstraction, while precise, often shifts the design focus from the \"what\" of functionality to the \"how\" of implementation. This subtle yet significant distinction restricts design flexibility, making it challenging to optimize for external constraints like performance or power without compromising on tool automation capabilities. The detailed nature of RTL leads to complex, verbose coding, and extended simulation time. Although such granularity of control is sometimes necessary, it often exceeds the requirements of many applications.</p> <p>Conversely, High-Level Synthesis (HLS) tools offer an abstraction that simplifies hardware design, particularly for those without a background in hardware engineering. By utilizing familiar programming languages and incorporating auto-pipelining and optimization, HLS makes hardware acceleration more accessible. However, the inherent sequential semantics of these languages can obstruct the development of parallel hardware architectures, making it especially challenging to describe processors or synchronous interfaces.</p> <p>A newer category, High-Level RTLs (HL-RTLs), such as Chisel and Amaranth, aims to bridge these gaps. Embedded within popular programming languages as domain-specific languages (DSLs), these HL-RTLs introduce innovative constructs for hardware generation. However, despite these significant advancements, they remain anchored to the RTL model, which can restrict implementation flexibility. Furthermore, their level of abstraction does not fully support the verification capabilities found in VHDL and Verilog, which benefit from event-driven semantics.</p> <p>DFiant attempts to introduce an optimal middle ground, which covers key HDL technologies across dimensions of both control and productivity (sort of \"have the cake and it it too\").</p>"},{"location":"intro/technology/#the-dataflow-hardware-description-abstraction","title":"The Dataflow Hardware Description Abstraction","text":"<p>At the heart of DFiant's innovation is the dataflow hardware description abstraction, a paradigm shift from the traditional RTL model. Instead of relying on wires and registers, dataflow abstraction employs streams of data tokens. This fundamental difference explains why RTL is inherently tied to device specifications and timing constraints, whereas dataflow abstraction remains neutral to such parameters.</p> <p> </p> <p>In RTL design, designers are tasked with specifying the exact operations that occur in each clock cycle, closely aligning the design with the physical timing of the hardware. Dataflow abstraction, on the other hand, focuses on the sequence of operations based on data dependencies, without mandating when each operation should start or finish within the clock cycles. This distinction allows operations in the dataflow model to be free from the rigid timing of clock cycles, granting compilers in the toolchain greater flexibility to schedule operations and effectively pipeline the design.</p> <p>Moreover, RTL design often requires the strategic placement of registers for various functions, anchoring the design to specific timing requirements. We categorize register use in RTL into three primary functions: backend synchronization, interface synchronization, and intrinsic design functionality, such as state management. The figure above illustrates the diverse applications of registers within RTL designs. Unlike RTL, where registers are uniformly represented, dataflow abstraction introduces unique language constructs or constraints for each register type. This differentiation enables the DFHDL compiler to distinguish between registers integral to the function and those necessary for implementation, providing subsequent design stages valuable insights for optimization. In contrast, RTL often relies on comments within the code to convey this information, if it is documented at all.</p>"},{"location":"intro/technology/#three-design-domain-abstractions-within-a-single-hdl","title":"Three Design Domain Abstractions within a Single HDL","text":"<p>DFHDL stands out by offering a comprehensive integration of three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in Figure 4. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p> </p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through a carefully constructed compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p>A standout feature of DFHDL is its ability to regenerate the code in DFHDL syntax at any point in the compilation process, including intermediate stages. This transparency offers developers valuable insights into each step of the optimization or compilation, a stark contrast to many HLS tools that produce hard-to-interpret code, leaving developers to decipher the underlying processes in case of issues.</p>"},{"location":"intro/technology/#more-details","title":"More Details","text":"<p>For more details on motivation, you can read this position paper.</p>"},{"location":"transitioning/from-verilog/","title":"Transitioning from Verilog to DFHDL","text":""},{"location":"transitioning/from-verilog/#using-chatgpt","title":"Using ChatGPT","text":"<p>Help me ChatGPT, you're my only hope</p>"},{"location":"transitioning/from-verilog/#summary","title":"Summary","text":"<p>Module Definition</p> Verilog<pre><code>module _module_name_ #(\n  //param declarations\n) (\n  //port declarations\n);\n  //internal declarations\nendmodule\n</code></pre> DFHDL<pre><code>class _design_name_(\n  //param declarations\n) extends EDDesign:\n  //port &amp; internal declarations\n\n\nend _design_name_ //optional\n</code></pre> Verilog<pre><code>module AndGate (\n  input a, b;\n  output o\n);\n  assign o = a &amp; b\nendmodule\n</code></pre> DFHDL<pre><code>class AndGate extends EDDesign:\n  val a, b = Bit &lt;&gt; IN\n  val o    = Bit &lt;&gt; OUT\n\n  o &lt;&gt; a &amp;&amp; b\nend AndGate\n</code></pre> <p>Parameter Declarations</p> Verilog<pre><code>parameter [7:0] p = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val p: Bits[8] &lt;&gt; CONST = b\"8'1011\"\n</code></pre> Verilog<pre><code>module Concat #(\n  parameter  int len1;\n  parameter  int len2;\n  localparam int outlen = len1 + len2\n) (\n  input  [len1-1:0]   i1;\n  input  [len2-1:0]   i2;\n  output [outlen-1:0] o\n);\n  assign o = {i1, i2};\nendmodule\n</code></pre> DFHDL<pre><code>class Concat(\n    val len1: Int &lt;&gt; CONST\n    val len2: Int &lt;&gt; CONST\n) extends EDDesign:\n  val outlen = len1 + len2\n  val i1 = Bits(len1)   &lt;&gt; IN\n  val i2 = Bits(len2)   &lt;&gt; IN\n  val o  = Bits(outlen) &lt;&gt; OUT\n\n  o &lt;&gt; (i1, i2)\nend Concat\n</code></pre> <p>logic/reg/wire</p> Verilog<pre><code>logic [7:0] v = 8\u2019b1011;\nwire  [7:0] v = 8\u2019b1011;\nreg   [7:0] v = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val v = Bits(8) &lt;&gt; VAR init b\"8'1011\"\n</code></pre>"},{"location":"user-guide/compilation/","title":"Compilation","text":""},{"location":"user-guide/compilation/#elaboration","title":"Elaboration","text":""},{"location":"user-guide/connectivity/","title":"Index","text":""},{"location":"user-guide/connectivity/#hierarchy-and-connectivity","title":"Hierarchy and Connectivity","text":"<p>DFHDL supports composable design hierarchies by instantiating design classes and connecting ports.</p> <p>Terminology</p> <ul> <li>design - A Scala class extending <code>XXDesign</code>, where <code>XX</code> can be <code>DF</code>, <code>RT</code>, or <code>ED</code>, corresponding to the desired design domain.</li> <li>design member - Any DFHDL object instantiated within a design (the design contains or owns all its members).</li> <li>child design/component - A design instance that is owned by another design.</li> <li>top design - The highest-level design in the hierarchy (no other design contains it), also known as the top-level design.</li> <li>top-app design - A <code>@top</code> annotated top design that generates a main entry with the default application.</li> </ul> topconstchild A param1param2child B in portout port param"},{"location":"user-guide/connectivity/#design-declaration","title":"Design Declaration","text":""},{"location":"user-guide/connectivity/#design-dcl-syntax","title":"Syntax","text":"<p>A DFHDL design declaration follows the standard Scala class syntax, with specialized handling by the DFHDL Scala compiler plugin under the hood.</p> Design declaration syntax<pre><code>/** _documentation_ */\n@top(genMain) //required only for top-level designs\nclass\u00a0_name_(_params_)\u00a0extends XXDesign:\n  _contents_\nend _name_ //optional `end` marker\n</code></pre> <ul> <li><code>_name_</code> is the Scala class name reference for the design you declared. The DFHDL compiler preserves this class name and uses it in error messages and the final generated artifacts (e.g., Verilog modules or VHDL entities). See the naming section for more details.</li> <li><code>(_params_)</code> is an optional parameter block. The parameter block can include either Scala parameters that are inlined for the design elaboration stage or DFHDL design parameters that are preserved through the design elaboration and compilation stages. If you do not need parameters, Scala syntax accepts both empty parentheses <code>()</code> and no parentheses. See Parameter Block Syntax for more information.</li> <li><code>_XXDesign_</code> is the class to extend depending on the desired design domain, where <code>XX</code> can be <code>DF</code> for dataflow, <code>RT</code> for register-transfer, or <code>ED</code> for event-driven.</li> <li><code>_contents_</code> are the design interface (ports/interfaces/domains) and functionality (variables, functions, child designs, processes, etc.), depending on the semantics of the selected design domain.</li> <li><code>@top(genMain)</code> is a special obligatory annotation for top-level designs (designs that are not instantiated within another design). The annotation has an optional <code>val genMain: Boolean = true</code> parameter. When <code>genMain = false</code>, all this annotation does is provide a default top-level context for the design (e.g., implicit/given compiler options). When <code>genMain = true</code>, the design becomes a top-app design where all design parameters must have default values, and a main Scala entry point named <code>top__name_</code> is generated (e.g., for a top-app design named <code>Foo</code>, the entry point is named <code>top_Foo</code>).</li> <li><code>_documentation_</code> is the design documentation in Scaladoc format. This documentation is meta information that is preserved throughout the compilation process and finally generated as documentation for the generated backend code.</li> </ul> <p>Basic top-app design example: a two-bits left shifter</p> <p>The DFHDL code below implements a two-bit left shifter design named <code>LeftShift2</code> under register-transfer (RT) domain semantics, as indicated by the class <code>LeftShift2</code> extending <code>RTDesign</code>. The design has one 8-bit input port and one 8-bit output port and implements the 2-bit left shift functionality by applying it to the input and assigning it to the output.</p> <pre><code>import dfhdl.*\n//optionally set the default backend configuration option\n//(can be overridden by the top-app CLI)\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A two-bits left shifter */\n@top class LeftShift2 extends RTDesign:\n  /** bits input */\n  val iBits = Bits(8) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(8) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; 2\n</code></pre> LeftShift22&lt;&lt; iBitsoBits <p>This design is also a top-app design, since it's annotated with <code>@top</code>. This means that we have an executable Scala program that compiles the design and generates Verilog or VHDL backend code. The backend configuration option can be set via a CLI argument, or alternatively, be set via an implicit backend setting like in the code above. The <code>@top</code> annotation captures the implicit/given options within its scope and feeds them to the top-app CLI program as defaults to run when no CLI arguments are given.</p> Generated VerilogGenerated VHDL <pre><code>/* A two-bits left shifter */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LeftShift2_defs.svh\"\n\nmodule LeftShift2(\n  /* bits input */\n  input  wire logic [7:0] iBits,\n  /* bits output */\n  output      logic [7:0] oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; 2;\nendmodule\n</code></pre> <pre><code>-- A two-bits left shifter \nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LeftShift2_pkg.all;\n\nentity LeftShift2 is\nport (\n  -- bits input \n  iBits : in  std_logic_vector(7 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(7 downto 0)\n);\nend LeftShift2;\n\narchitecture LeftShift2_arch of LeftShift2 is\nbegin\n  oBits &lt;= slv_sll(iBits, 2);\nend LeftShift2_arch;\n</code></pre> Runnable example <pre><code>import dfhdl.*\n//optionally set the default backend configuration option\n//(can be overridden by the top-app CLI)\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A two-bits left shifter */\n@top class LeftShift2 extends RTDesign:\n  /** bits input */\n  val iBits = Bits(8) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(8) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; 2\n</code></pre>"},{"location":"user-guide/connectivity/#design-params-syntax","title":"Parameter Block Syntax","text":"<p>Just like any Scala class parameter blocks, the DFHDL design accepts a sequence of comma-delimited parameter declarations.</p> Design declaration parameter block syntax<pre><code>([_access_] _name_: _type_ [= _default_], ...)\n</code></pre> <ul> <li><code>_type_</code> is either a pure Scala parameter type or a DFHDL parameter type in the form of <code>DFType &lt;&gt; CONST</code>.<ul> <li>Pure Scala parameters are completely transparent to the DFHDL compiler and are inlined during elaboration. </li> <li>DFHDL parameters are preserved throughout the compilation process and manifest as parameters in the generated backend code.</li> </ul> </li> <li><code>_name_</code> is the Scala parameter name reference. The DFHDL compiler preserves this parameter name for DFHDL parameter types only. For the top-app command-line interface (CLI), these names are also preserved, so that the parameters can be listed and modified through the CLI.</li> <li><code>_default_</code> is the optional default value of the parameter. </li> <li><code>_access_</code> is the optional Scala parameter access modifier. By default, a Scala class parameter access is <code>private val</code>.</li> </ul> <p>Scala-parameterized top-app design example: a basic left shifter</p> <p>The DFHDL code below implements a basic left shifter design named <code>LeftShiftBasic</code>. This design is similar to the earlier example of <code>LeftShift2</code> except here the design has the shift value as an input, and its input and output port widths are set according to the Scala parameter <code>width</code>.</p> <pre><code>/** A basic left shifter */\n@top class LeftShiftBasic(\n    val width: Int = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre> LeftShiftBasic&lt;&lt; shiftiBitsoBitswidth Generated VerilogGenerated VHDL <pre><code>/* A basic left shifter */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LeftShiftBasic_defs.svh\"\n\nmodule LeftShiftBasic(\n  /* bits input */\n  input  wire logic [7:0] iBits,\n  /* requested shift */\n  input  wire logic [2:0] shift,\n  /* bits output */\n  output      logic [7:0] oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; shift;\nendmodule\n</code></pre> <pre><code>-- A basic left shifter \nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LeftShiftBasic_pkg.all;\n\nentity LeftShiftBasic is\nport (\n  -- bits input \n  iBits : in  std_logic_vector(7 downto 0);\n  -- requested shift \n  shift : in  unsigned(2 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(7 downto 0)\n);\nend LeftShiftBasic;\n\narchitecture LeftShiftBasic_arch of LeftShiftBasic is\nbegin\n  oBits &lt;= slv_sll(iBits, to_integer(shift));\nend LeftShiftBasic_arch;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A basic left shifter */\n@top class LeftShiftBasic(\n    val width: Int = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre> <p>The basic code shifter above did not generate the <code>width</code> parameter in the Verilog and VHDL backend code. The following example shows how to preserve the <code>width</code> parameter:</p> <p>DFHDL-parameterized top-app design example: a generic left shifter</p> <p>The DFHDL code below implements a generic left shifter design named <code>LeftShiftGen</code>. This design is similar to the earlier example of <code>LeftShiftBasic</code> except here the <code>width</code> parameter is now a DFHDL parameter as indicated by its <code>Int &lt;&gt; CONST</code> type. This enables the DFHDL compiler to preserve the parameter name and directly use it in the generated backend code where applicable.</p> <pre><code>/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LeftShiftGen(\n    val width: Int &lt;&gt; CONST = 8,\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre> LeftShiftGen&lt;&lt; shiftiBitsoBitswidth Generated VerilogGenerated VHDL <pre><code>/* A generic left shifter \n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LeftShiftGen_defs.svh\"\n\nmodule LeftShiftGen#(parameter int width = 8)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; shift;\nendmodule\n</code></pre> <pre><code>-- A generic left shifter \n--   \n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LeftShiftGen_pkg.all;\n\nentity LeftShiftGen is\ngeneric (\n  width : integer := 8\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend LeftShiftGen;\n\narchitecture LeftShiftGen_arch of LeftShiftGen is\nbegin\n  oBits &lt;= slv_sll(iBits, to_integer(shift));\nend LeftShiftGen_arch;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LeftShiftGen(\n    val width: Int &lt;&gt; CONST = 8,\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre>"},{"location":"user-guide/connectivity/#design-parameter-type-rules","title":"Design Parameter Type Rules","text":"<ul> <li>Any pure Scala parameter or DFHDL parameter types are acceptable.</li> <li>Top-app design parameters, to be modifiable from the CLI, must be one of the following types:<ul> <li>Pure Scala Types: <code>String</code>, <code>Boolean</code>, <code>Int</code>, and <code>Double</code>.</li> <li>DFHDL Types: <code>Int &lt;&gt; CONST</code>, <code>Bit &lt;&gt; CONST</code>, and <code>Boolean &lt;&gt; CONST</code>.</li> </ul> </li> </ul> <p>Top-app design with accepted and ignored arguments</p> <p>DFHDL code<pre><code>import dfhdl.*\nclass CustomArg\n@top class Foo(\n    val pureIntArg:   Int              = 5,\n    val dfhdlIntArg:  Int &lt;&gt; CONST     = 7,\n    val ignored:      CustomArg        = CustomArg(),\n    val dfhdlIgnored: Bits[8] &lt;&gt; CONST = all(0)\n) extends DFDesign\n</code></pre> CLI output, when running via sbt (truncated)<pre><code>Design Name: Foo\nUsage: sbt runMain \"top_Foo [design-args] &lt;mode&gt; [options]\"\n Design arguments:\n      --pureIntArg  &lt;Int&gt;    (default = 5)\n      --dfhdlIntArg  &lt;Int&gt;   (default = 7)\n</code></pre></p> Runnable example <pre><code>import dfhdl.*\n//this option forces the top-app to run help mode\n//by default\ngiven options.AppOptions.DefaultMode = options.AppOptions.DefaultMode.help\nclass CustomArg\n@top class Foo(\n    val pureIntArg:   Int              = 5,\n    val dfhdlIntArg:  Int &lt;&gt; CONST     = 7,\n    val ignored:      CustomArg        = CustomArg(),\n    val dfhdlIgnored: Bits[8] &lt;&gt; CONST = all(0)\n) extends DFDesign</code></pre>"},{"location":"user-guide/connectivity/#design-parameter-default-value-rules","title":"Design Parameter Default Value Rules","text":"<ul> <li>According to the Scala language rules, once a parameter has a default value defined, all parameters that follow it must also have default values defined. </li> <li>For top-app designs, all parameters must have default values.</li> </ul>"},{"location":"user-guide/connectivity/#design-class-inheritance","title":"Design Class Inheritance","text":"<p>It is possible to leverage the power of Scala inheritance to share design functionality between design class declarations.</p> <p>Generic left and right shifters, design class inheritance example</p> <p>The DFHDL code below demonstrates how to implement both left and right generic shifters efficiently by using a common <code>abstract class</code> named <code>ShiftGen</code>. The <code>width</code> parameter is declared as an abstract class field (without an assigned value) inside the <code>ShiftGen</code> class body. By extending <code>ShiftGen</code>, both <code>LeftShiftGen</code> and <code>RightShiftGen</code> can utilize the IOs already declared in <code>ShiftGen</code>. They only need to explicitly declare the <code>width</code> parameter and implement the shift functionality in their respective class bodies.</p> <pre><code>/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n</code></pre> LeftShiftGen&lt;&lt; shiftiBitsoBitswidthRightShiftGen&gt;&gt; shiftiBitsoBitswidth"},{"location":"user-guide/connectivity/#design-composition-instantiation","title":"Design Composition &amp; Instantiation","text":"<p>DFHDL supports three mechanisms to form a design hierarchy through design instantiation and composition:</p> <ul> <li>Direct Connection Composition - The most common and recommended mechanism to construct complex design hierarchies with multiple inputs and outputs. Within this mechanism, the design instantiation and port connection can be executed separately. This enables child design ports to be referenced without declaring and connecting intermediate variables.</li> <li>Via Connection Composition - A legacy mechanism to connect ports only within a design instantiation. This mechanism mainly exists for coexistence with the Verilog module instancing and VHDL component instancing mechanisms. The DFHDL compiler automatically transforms a direct connection composition into a via connection composition.</li> <li>Functional Composition - A method call mechanism to describe design composition. This mechanism is reserved for dataflow designs only and is mostly relevant for arithmetic/logic design functionality that has a single output port. The DFHDL compiler automatically transforms a functional composition into direct design composition.</li> </ul> <p>The following subsections dive into further details of the three design composition mechanisms. For this purpose, we continue with our running example of a bit shifter. To demonstrate composition, let's first describe a more complex shifter that has both left and right shift capabilities, as a flat (composition-less) design:</p> <p>Generic left-right shifter, flat design example</p> <p>The DFHDL code below implements a generic left-right shifter flat design named <code>LRShiftFlat</code>. This design expands on <code>LeftShiftGen</code> by adding a <code>dir</code> enum port value that specifies the shift direction and a shift operation multiplexer through a <code>match</code> statement.</p> <pre><code>enum ShiftDir extends Encode:\n  case Left, Right\n\n/** A left-right bits shifter (flat version)\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftFlat(\n    val width: Int &lt;&gt; CONST = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** direction of shift */\n  val dir   = ShiftDir          &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  dir match\n    case ShiftDir.Left  =&gt; oBits := iBits &lt;&lt; shift\n    case ShiftDir.Right =&gt; oBits := iBits &gt;&gt; shift\n</code></pre> LRShiftFlat&lt;&lt; &gt;&gt; mux dirshiftiBitsoBitswidth Generated VerilogGenerated VHDL LRShiftFlat.svLRShiftFlat_defs.svh <pre><code>/* A left-right bits shifter (flat version)\n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftFlat_defs.svh\"\n\nmodule LRShiftFlat#(parameter int width = 8)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* direction of shift */\n  input  wire t_enum_ShiftDir             dir,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  always_comb\n  begin\n    case (dir)\n      ShiftDir_Left:  oBits = iBits &lt;&lt; shift;\n      ShiftDir_Right: oBits = iBits &gt;&gt; shift;\n    endcase\n  end\nendmodule\n</code></pre> <pre><code>`ifndef LRSHIFTFLAT_DEFS\n`define LRSHIFTFLAT_DEFS\ntypedef enum logic [0:0] {\n  ShiftDir_Left  = 0,\n  ShiftDir_Right = 1\n} t_enum_ShiftDir;\n\n`endif\n</code></pre> LRShiftFlat.vhdLRShiftFlat_pkg.vhd <pre><code>-- A left-right bits shifter (flat version)\n--\n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftFlat_pkg.all;\n\nentity LRShiftFlat is\ngeneric (\n  width : integer := 8\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- direction of shift \n  dir   : in  t_enum_ShiftDir;\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend LRShiftFlat;\n\narchitecture LRShiftFlat_arch of LRShiftFlat is\nbegin\n  process (all)\n  begin\n    case dir is\n      when ShiftDir_Left  =&gt; oBits &lt;= slv_sll(iBits, to_integer(shift));\n      when ShiftDir_Right =&gt; oBits &lt;= slv_srl(iBits, to_integer(shift));\n    end case;\n  end process;\nend LRShiftFlat_arch;\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\n\npackage LRShiftFlat_pkg is\ntype t_enum_ShiftDir is (\n  ShiftDir_Left, ShiftDir_Right\n);\nfunction bitWidth(A: t_enum_ShiftDir) return integer;\nfunction to_slv(A: t_enum_ShiftDir) return std_logic_vector;\nfunction to_t_enum_ShiftDir(A: std_logic_vector) return t_enum_ShiftDir;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir;\n\n\nend package LRShiftFlat_pkg;\n\npackage body LRShiftFlat_pkg is\nfunction bitWidth(A : t_enum_ShiftDir) return integer is\nbegin\n  return 1;\nend;\nfunction to_slv(A : t_enum_ShiftDir) return std_logic_vector is\n  variable int_val : integer;\nbegin\n  case A is\n    when ShiftDir_Left  =&gt; int_val := 0;\n    when ShiftDir_Right =&gt; int_val := 1;\n  end case;\n  return resize(to_slv(int_val), 1);\nend;\nfunction to_t_enum_ShiftDir(A : std_logic_vector) return t_enum_ShiftDir is\nbegin\n  case to_integer(unsigned(A)) is\n    when 0              =&gt; return ShiftDir_Left;\n    when 1              =&gt; return ShiftDir_Right;\n    when others         =&gt; \n      assert false report \"Unknown state detected!\" severity error;\n      return ShiftDir_Left;\n  end case;\nend;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir is\nbegin\n  if C then\n    return T;\n  else\n    return F;\n  end if;\nend;\n\nend package body LRShiftFlat_pkg;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\nenum ShiftDir extends Encode:\n  case Left, Right\n\n/** A left-right bits shifter (flat version)\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftFlat(\n    val width: Int &lt;&gt; CONST = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** direction of shift */\n  val dir   = ShiftDir          &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  dir match\n    case ShiftDir.Left  =&gt; oBits := iBits &lt;&lt; shift\n    case ShiftDir.Right =&gt; oBits := iBits &gt;&gt; shift\n</code></pre>"},{"location":"user-guide/connectivity/#direct-connection-composition","title":"Direct Connection Composition","text":"<p>Generic left-right shifter, direct connection composed design example</p> <p>The DFHDL code below implements a generic left-right shifter composed (hierarchical) design named <code>LRShiftDirect</code>. This design implements the exact same functionality as seen earlier in <code>LeftShiftFlat</code>, but this time leveraging design composition and direct connectivity capabilities of DFHDL by splitting the left and right shift operations into their own separate designs named <code>LeftShiftGen</code> and <code>RightShiftGen</code>, respectively. Additionally, as already seen in the <code>ShiftGen</code> example, we use design class inheritance to avoid redefining the same IOs across the three design classes.</p> <p>Note</p> <p>This example is very simple to demonstrate the direct composition capabilities and generally for such simple designs the flat approach should be the preferred way. However, complex designs should be split into sub-components for purposes of reuse, simpler verification, and generally better design practices.</p> <pre><code>/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n\nenum ShiftDir extends Encode:\n  case Left, Right\n\n/** A left-right bits shifter, direct composition\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftDirect(\n    val width: Int &lt;&gt; CONST = 8\n) extends ShiftGen:\n  /** direction of shift */\n  val dir   = ShiftDir &lt;&gt; IN\n  val lshifter = LeftShiftGen(width)\n  val rshifter = RightShiftGen(width)\n  lshifter.iBits &lt;&gt; iBits\n  lshifter.shift &lt;&gt; shift\n  rshifter.iBits &lt;&gt; iBits\n  rshifter.shift &lt;&gt; shift\n  dir match\n    case ShiftDir.Left  =&gt; oBits := lshifter.oBits\n    case ShiftDir.Right =&gt; oBits := rshifter.oBits\nend LRShiftDirect\n</code></pre> LeftShiftGen&lt;&lt; shiftiBitsoBitswidthRightShiftGen&gt;&gt; shiftiBitsoBitswidthLRShiftDirectlshifterLeftShiftGenshiftiBitsoBitswidthrshifterRightShiftGenshiftiBitsoBitswidthmux dirshiftiBitsoBitswidth Generated VerilogGenerated VHDL LRShiftDirect.svLeftShiftGen.svRightShiftGen.svLRShiftDirect_defs.svh <pre><code>/* A left-right bits shifter, direct composition\n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftDirect_defs.svh\"\n\nmodule LRShiftDirect#(parameter int width = 8)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits,\n  /* direction of shift */\n  input  wire t_enum_ShiftDir             dir\n);\n  `include \"dfhdl_defs.svh\"\n  logic [width - 1:0] lshifter_iBits;\n  logic [$clog2(width) - 1:0] lshifter_shift;\n  logic [width - 1:0] lshifter_oBits;\n  logic [width - 1:0] rshifter_iBits;\n  logic [$clog2(width) - 1:0] rshifter_shift;\n  logic [width - 1:0] rshifter_oBits;\n  LeftShiftGen #(\n    .width (width)\n  ) lshifter(\n    .iBits /*&lt;--*/ (lshifter_iBits),\n    .shift /*&lt;--*/ (lshifter_shift),\n    .oBits /*--&gt;*/ (lshifter_oBits)\n  );\n  RightShiftGen #(\n    .width (width)\n  ) rshifter(\n    .iBits /*&lt;--*/ (rshifter_iBits),\n    .shift /*&lt;--*/ (rshifter_shift),\n    .oBits /*--&gt;*/ (rshifter_oBits)\n  );\n  assign lshifter_iBits = iBits;\n  assign lshifter_shift = shift;\n  assign rshifter_iBits = iBits;\n  assign rshifter_shift = shift;\n  always_comb\n  begin\n    case (dir)\n      ShiftDir_Left:  oBits = lshifter_oBits;\n      ShiftDir_Right: oBits = rshifter_oBits;\n    endcase\n  end\nendmodule\n</code></pre> <pre><code>/* A generic left shifter \n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftDirect_defs.svh\"\n\nmodule LeftShiftGen#(parameter int width)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; shift;\nendmodule\n</code></pre> <pre><code>/* A generic right shifter \n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftDirect_defs.svh\"\n\nmodule RightShiftGen#(parameter int width)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &gt;&gt; shift;\nendmodule\n</code></pre> <pre><code>`ifndef LRSHIFTDIRECT_DEFS\n`define LRSHIFTDIRECT_DEFS\ntypedef enum logic [0:0] {\n  ShiftDir_Left  = 0,\n  ShiftDir_Right = 1\n} t_enum_ShiftDir;\n\n`endif\n</code></pre> LRShiftDirect.vhdLeftShiftGen.vhdRightShiftGen.vhdLRShiftDirect_pkg.vhd <pre><code>-- A left-right bits shifter, direct composition\n--\n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftDirect_pkg.all;\n\nentity LRShiftDirect is\ngeneric (\n  width : integer := 8\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0);\n  -- direction of shift \n  dir   : in  t_enum_ShiftDir\n);\nend LRShiftDirect;\n\narchitecture LRShiftDirect_arch of LRShiftDirect is\n  signal lshifter_iBits : std_logic_vector(width - 1 downto 0);\n  signal lshifter_shift : unsigned(clog2(width) - 1 downto 0);\n  signal lshifter_oBits : std_logic_vector(width - 1 downto 0);\n  signal rshifter_iBits : std_logic_vector(width - 1 downto 0);\n  signal rshifter_shift : unsigned(clog2(width) - 1 downto 0);\n  signal rshifter_oBits : std_logic_vector(width - 1 downto 0);\nbegin\n  lshifter : entity work.LeftShiftGen(LeftShiftGen_arch) generic map (\n    width        =&gt; width\n  ) port map (\n    iBits        =&gt; lshifter_iBits,\n    shift        =&gt; lshifter_shift,\n    oBits        =&gt; lshifter_oBits\n  );\n  rshifter : entity work.RightShiftGen(RightShiftGen_arch) generic map (\n    width        =&gt; width\n  ) port map (\n    iBits        =&gt; rshifter_iBits,\n    shift        =&gt; rshifter_shift,\n    oBits        =&gt; rshifter_oBits\n  );\n  lshifter_iBits &lt;= iBits;\n  lshifter_shift &lt;= shift;\n  rshifter_iBits &lt;= iBits;\n  rshifter_shift &lt;= shift;\n  process (all)\n  begin\n    case dir is\n      when ShiftDir_Left  =&gt; oBits &lt;= lshifter_oBits;\n      when ShiftDir_Right =&gt; oBits &lt;= rshifter_oBits;\n    end case;\n  end process;\nend LRShiftDirect_arch;\n</code></pre> <pre><code>-- A generic left shifter \n--   \n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftDirect_pkg.all;\n\nentity LeftShiftGen is\ngeneric (\n  width : integer\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend LeftShiftGen;\n\narchitecture LeftShiftGen_arch of LeftShiftGen is\nbegin\n  oBits &lt;= slv_sll(iBits, to_integer(shift));\nend LeftShiftGen_arch;\n</code></pre> <pre><code>-- A generic right shifter \n--   \n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftDirect_pkg.all;\n\nentity RightShiftGen is\ngeneric (\n  width : integer\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend RightShiftGen;\n\narchitecture RightShiftGen_arch of RightShiftGen is\nbegin\n  oBits &lt;= slv_srl(iBits, to_integer(shift));\nend RightShiftGen_arch;\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\n\npackage LRShiftDirect_pkg is\ntype t_enum_ShiftDir is (\n  ShiftDir_Left, ShiftDir_Right\n);\nfunction bitWidth(A: t_enum_ShiftDir) return integer;\nfunction to_slv(A: t_enum_ShiftDir) return std_logic_vector;\nfunction to_t_enum_ShiftDir(A: std_logic_vector) return t_enum_ShiftDir;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir;\n\n\nend package LRShiftDirect_pkg;\n\npackage body LRShiftDirect_pkg is\nfunction bitWidth(A : t_enum_ShiftDir) return integer is\nbegin\n  return 1;\nend;\nfunction to_slv(A : t_enum_ShiftDir) return std_logic_vector is\n  variable int_val : integer;\nbegin\n  case A is\n    when ShiftDir_Left  =&gt; int_val := 0;\n    when ShiftDir_Right =&gt; int_val := 1;\n  end case;\n  return resize(to_slv(int_val), 1);\nend;\nfunction to_t_enum_ShiftDir(A : std_logic_vector) return t_enum_ShiftDir is\nbegin\n  case to_integer(unsigned(A)) is\n    when 0              =&gt; return ShiftDir_Left;\n    when 1              =&gt; return ShiftDir_Right;\n    when others         =&gt; \n      assert false report \"Unknown state detected!\" severity error;\n      return ShiftDir_Left;\n  end case;\nend;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir is\nbegin\n  if C then\n    return T;\n  else\n    return F;\n  end if;\nend;\n\nend package body LRShiftDirect_pkg;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n\nenum ShiftDir extends Encode:\n  case Left, Right\n\n/** A left-right bits shifter, direct composition\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftDirect(\n    val width: Int &lt;&gt; CONST = 8\n) extends ShiftGen:\n  /** direction of shift */\n  val dir   = ShiftDir &lt;&gt; IN\n  val lshifter = LeftShiftGen(width)\n  val rshifter = RightShiftGen(width)\n  lshifter.iBits &lt;&gt; iBits\n  lshifter.shift &lt;&gt; shift\n  rshifter.iBits &lt;&gt; iBits\n  rshifter.shift &lt;&gt; shift\n  dir match\n    case ShiftDir.Left  =&gt; oBits := lshifter.oBits\n    case ShiftDir.Right =&gt; oBits := rshifter.oBits\nend LRShiftDirect\n</code></pre>"},{"location":"user-guide/connectivity/#via-connection-composition","title":"Via Connection Composition","text":""},{"location":"user-guide/connectivity/#functional-composition","title":"Functional Composition","text":""},{"location":"user-guide/connectivity/#design-dcl-rules","title":"Rules","text":""},{"location":"user-guide/connectivity/#design-class-modifier-limitations","title":"Design class modifier limitations","text":"<p>A DFHDL design class cannot be declared as <code>final class</code> or <code>case class</code>. Attempting to do so produces an error: DFHDL design class modifier limitation example<pre><code>//error: DFHDL classes cannot be final classes.\nfinal class Foo extends DFDesign\n//error: DFHDL classes cannot be case classes.\ncase class Bar() extends DFDesign\n</code></pre> All other Scala class modifiers have no special effect or limitation from a DFHDL compiler perspective. Nonetheless, these modifiers can be relevant when defining a more complex design API, as part of the DFHDL meta-programming capabilities through the Scala language (e.g., changing class access to <code>protected</code>).</p>"},{"location":"user-guide/connectivity/#design-parameter-limitations","title":"Design parameter limitations","text":""},{"location":"user-guide/connectivity/#top-app-design-parameter-type-limitations","title":"Top-app design parameter type limitations","text":""},{"location":"user-guide/design-domains/","title":"Design Domains","text":"<p>DFHDL offers three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in the following figure. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through an intelligent compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p> </p>"},{"location":"user-guide/errors/","title":"Errors &amp; Warnings","text":"<p>DFiant-related compiler errors &amp; warnings and ways to resolve them</p>"},{"location":"user-guide/errors/#missing-context","title":"Missing Context","text":"<p>TBD</p>"},{"location":"user-guide/errors/#dont-use-var-with-dataflow-valuesvariables","title":"Don't use <code>var</code> with dataflow values/variables","text":"<p>TBD</p>"},{"location":"user-guide/interfaces/","title":"Interfaces [WIP]","text":""},{"location":"user-guide/meta/","title":"Meta Hardware Description","text":""},{"location":"user-guide/methods/","title":"Functions / Methods","text":""},{"location":"user-guide/naming/","title":"Naming","text":""},{"location":"user-guide/processes/","title":"Processes","text":""},{"location":"user-guide/simulation/","title":"Simulation","text":""},{"location":"user-guide/state/","title":"Index","text":""},{"location":"user-guide/state/#state-initialization","title":"State &amp; Initialization","text":"<p>Semantically, every DFiant dataflow variable references a token stream (TS). </p> <ul> <li> <p>Unless stated otherwise, all dataflow variables are always consuming and always producing.</p> </li> <li> <p>Previous token initialization:</p> </li> <li> <p>The token history stream can be initialized.</p> </li> <li> <p>Initialization does not mutate the dataflow variable.</p> </li> <li> <p>Initialization has no effect on the TS. Only when using <code>prev</code> the initialization is placed on the TS reference.</p> </li> <li> <p><code>init</code> returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. </p> </li> <li> <p>Bubble tokens (?) :</p> </li> <li> <p>Produced when a <code>prev</code> is called on a non-initialized dataflow variable. E.g.,</p> Code Init Token Stream <code>in : DFUInt[32]</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>in.prev</code> <code>?</code> <code>?, 2, 3, 1, 5, 9</code> <code>in.prev(2)</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>in.prev.prev</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>val in1 = in.init(1); in1</code> <code>1</code> <code>2, 3, 1, 5, 9</code> <code>in1.prev</code> <code>1</code> <code>1, 2, 3, 1, 5, 9</code> <code>in1.prev(2)</code> <code>1</code> <code>1, 1, 2, 3, 1, 5, 9</code> <code>in1.prev.init(8)</code> <code>8</code> <code>1, 2, 3, 1, 5, 9</code> <code>val innew = DFUInt(32) := in1; innew</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>val ins7 = in.init(7, ?); ins7</code> <code>(7, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins7.prev</code> <code>?</code> <code>7, 2, 3, 1, 5, 9</code> <code>val ins78 = in.init(7, 8, ?); ins78</code> <code>(7, 8, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins78.prev</code> <code>(8, ?)</code> <code>7, 2, 3, 1, 5, 9</code> <code>ins78.prev(2)</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> <code>in.init(7).prev.init(8, ?).prev</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> </li> <li> <p>Bubbles are like any regular-value tokens in terms of consumption and production rules.</p> </li> <li> <p>Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue.</p> </li> <li> <p>Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., </p> <pre><code>def foo(a : DFUInt(8)) = a + a.prev\n//'in' is token stream of:    2, 3, 1, 5, 9\n//'foo(in)' returns:          ?, 5, 4, 6, 14\n</code></pre> </li> <li> <p><code>prev</code> maintains Distributivity through basic operations e.g.: </p> <p><code>(a + b).prev</code> \u2257 <code>a.prev + b.prev</code> (timeless TS equality).</p> Code Init Token Stream <code>inL : DFUInt(32)</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>inR : DFUInt(32)</code> <code>?</code> <code>4, 0, 2</code> <code>inL + inR</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2</code> <code>=</code><code>6, 3, 3</code> <code>inL + inR.prev</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>?, 4, 0, 2</code> <code>=</code><code>?, 7, 1, 7</code> <code>inL.init(1) + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1, ?) + inR.init(3).prev</code> <code>(1, ?)</code> <code>+</code><code>3</code> <code>=</code><code>(4, ?)</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1) + inR.init(3, ?).prev</code> <code>1</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1).prev + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>1, 2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>4, 6, 3, 3</code> <code>(inL.init(1) + inR.init(3)).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>(2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2)</code> <code>.prev =</code><code>4, 6, 3, 3</code> </li> <li> <p>Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags.</p> </li> <li> <p>Casting:</p> </li> <li> <p>Parts of a bits vector can be bubbles while others normal values.</p> </li> <li> <p>However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.</p> </li> </ul>"},{"location":"user-guide/state/#time-invariance","title":"Time Invariance","text":""},{"location":"user-guide/synthesis/","title":"Synthesis","text":""},{"location":"user-guide/type-system/","title":"Index","text":""},{"location":"user-guide/type-system/#type-system","title":"Type System","text":"<p>DFHDL is a Scala library and thus inherently supports type-safe and modern language constructs. This chapter covers the rules and API of this type system. </p> Check out the benefits of the DFHDL type system <ul> <li> <p> Strongly-typed</p> <p>Most type checks are performed statically, enforcing strict rules that help avoid ambiguity.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN \n//2-bit unsigned input\nval u2 = UInt(2) &lt;&gt; IN \nval y1 = u8 - u2 //ok\n// Error prevents ambiguous behavior \n// when a wider num is subtracted from \n// a narrow num.\nval y2 = u2 - u8 //error\n</code></pre> </p> </li> <li> <p> Bit-accurate</p> <p>Each DFHDL value has a defined bit-width, which is used to enforce rules that prevent data loss.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN  \n//8-bit signed output\nval s8 = SInt(8) &lt;&gt; OUT \n// Error prevents data loss when u8 is \n// converted to a 9-bit signed to be \n// assigned to s8, which is only 8-bits \n// wide.\ns8 := u8 //error\n</code></pre> </p> </li> <li> <p> Composable</p> <p>Types can be composed through structs or tuples to form new, combined types.</p> <pre><code>//new Pixel type as a structure\n//of two unsigned 8-bit numbers\ncase class Pixel(\n  x: UInt[8] &lt;&gt; VAL,\n  y: UInt[8] &lt;&gt; VAL\n) extends Struct\n\nval pixel = Pixel &lt;&gt; VAR\n//select and assign fields\npixel.x := pixel.y\n</code></pre> </li> <li> <p> Expandable</p> <p>New types can be defined, and methods can be added for entirely new or existing types.</p> <pre><code>//new AESByte type of unsigned 8-bit num\ncase class AESByte() \n  extends Opaque(UInt(8))\n//define addition between two AESByte\n//values as a xor operation\nextension (lhs: AESByte &lt;&gt; VAL)\n  def +(rhs: AESByte &lt;&gt; VAL): AESByte &lt;&gt; DFRET =\n    (lhs.actual ^ rhs.actual).as(AESByte)\nval x, y = AESByte &lt;&gt; VAR\nval z = x + y //actually XOR\n</code></pre> </li> </ul> <p>DFHDL Values</p> <p>Each DFHDL value is simply a Scala object that has two critical fields:</p> <ul> <li> <p> (Shape) Type, aka DFType</p> <p>Determines the bit-width and bit-structure of the value. Currently the supported types are: </p> <ul> <li>DFHDL Bit/Boolean: <code>Bit</code>/<code>Boolean</code> </li> <li>DFHDL Bit Vector: <code>Bits</code></li> <li>DFHDL Integer: <code>UInt</code>/<code>SInt</code>/<code>Int</code></li> <li> <p>DFHDL Fix-Point (future work)</p> </li> <li> <p>DFHDL Flt-Point (future work)</p> </li> <li> <p>DFHDL String (future work)</p> </li> <li>DFHDL Enumeration: <code>... extends Encoding</code></li> <li>DFHDL Vector: <code>_CellType_ X _Dim_</code></li> <li>DFHDL Structure: <code>... extends Struct</code></li> <li>DFHDL Tuple: <code>(T1, T2, ..., Tn)</code></li> <li>DFHDL Opaque: <code>... extends Opaque</code></li> <li>DFHDL Unit (Void): <code>Unit</code></li> </ul> </li> <li> <p> (Access) Modifier</p> <p>Determines what kind of access the user has on the value. User explicit modifiers:</p> <ul> <li>Variable: <code>VAR[.REG][.SHARED]</code></li> <li>Port: <code>IN</code>/<code>OUT[.REG]</code>/<code>INOUT</code></li> <li>Constant: <code>CONST</code></li> <li>Struct Field: <code>VAL</code></li> <li>Method Param: <code>VAL</code></li> <li>Method Return: <code>DFRET</code>/<code>RTRET</code>/<code>EDRET</code></li> </ul> <p>Although this mechanism can be quite complex under the hood, the explicit modifiers available to the user are straightforward.</p> </li> </ul> Internal Type-System Hierarchy (For Advanced Users) <p>DFHDL brings type-driven development concepts to hardware design, by creating an extensible type class hierarchy. Any DFHDL value is a Scala object instance of the class <code>DFVal[T &lt;: DFTypeAny, M &lt;: ModifierAny]</code>, where <code>T</code> is the type (shape) of value and <code>M</code> is a modifier that sets additional characteristics of the DFHDL value, like if it's assignable, connectable, initializable, etc. </p> <p> </p> <p>For example, the Scala value <code>x</code> which references a port declared like <code>val x = Boolean &lt;&gt; IN</code> has the type <code>DFVal[DFBool, Modifier.Dcl]</code>.</p>"},{"location":"user-guide/type-system/#Dcl","title":"Variable and Port Declarations","text":"<p>Ports are DFHDL values that define the inputs and outputs of a design. Variables are DFHDL values that represent internal design wiring, logic, or state.</p>"},{"location":"user-guide/type-system/#dcl-syntax","title":"Syntax","text":"Port/Variable declaration syntax<pre><code>val\u00a0_name_\u00a0=\u00a0_dftype_\u00a0&lt;&gt;\u00a0_modifier_\u00a0[init\u00a0_const_]\n</code></pre> <ul> <li><code>_name_</code> is the Scala value name reference for the DFHDL port/variable you constructed. The DFHDL compiler preserves this name and uses it in error messages and the final generated artifacts (e.g., Verilog module or VHDL entity port names). <code>_name_</code> can also be a series of names separated by commas to declare several equivalent ports/variables. More information is available under the naming section.</li> <li><code>_dftype_</code> is set according to the shape type (DFType) of the DFHDL value. Each of the supported DFTypes have their own constructors. See relevant sections for the DFHDL DFType you wish to construct.</li> <li><code>&lt;&gt;</code> is the operator applied between a <code>_dftype_</code> and a <code>_modifier_</code> to construct the Scala value that represents a DFHDL variable or port accordingly. Note: the same <code>&lt;&gt;</code> operator is used as a language construct for declaring connections. Thanks to Scala method overloading, <code>&lt;&gt;</code> can be shared for both use-cases with no issues (due to the Scala argument type difference). </li> <li><code>_modifier_</code> is set with one of the following: <ul> <li><code>VAR</code> - to construct a variable</li> <li><code>IN</code> - to construct an input port</li> <li><code>OUT</code> - to construct an output port</li> <li><code>INOUT</code> - to construct a bidirectional input-output port</li> <li><code>VAR.REG</code> / <code>OUT.REG</code> - to construct a registered variable or output port (available only in RT domains) </li> <li><code>VAR.SHARED</code> - to construct a shared variable that can be assigned in more than one domain (this feature is to be used scarcely, to model unique designs like True Dual-Port RAM)</li> </ul> </li> <li><code>init</code> is an optional construct to initialize the DFHDL variable/port declaration history with the applied <code>_const_</code> value.</li> <li><code>_const_</code> is the state history initialization value which must be a constant that is supported by the DFType <code>_dftype_</code>. Under DF domain only, <code>_const_</code> can also be represented by a Scala Tuple sequence of constant initialization values that are supported by the DFType <code>_dftype_</code>.</li> </ul> Port/Variable declaration examples<pre><code>class Foo extends DFDesign:\n  //8-bit unsigned integer input port named 'i', \n  //initialized with the value 27\n  val i\u00a0=\u00a0UInt(8)\u00a0    &lt;&gt;\u00a0IN\u00a0\u00a0init\u00a027\n\n  //single bit output port named 'o' \n  //with a sequence history (0, 1, 0) init\n  //(possible under DF domain only)\n  val o =\u00a0Bit\u00a0        &lt;&gt;\u00a0OUT\u00a0init\u00a0(0, 1, 0)\n\n  //5 element vector of 8-bit vector cells \n  //variable named 'v' with no init\n  val v\u00a0=\u00a0Bits(8) X 5 &lt;&gt;\u00a0VAR\n\n  //multiple equivalent single bit input port \n  //declarations named 'a', 'b', and 'c'\n  val a, b, c = Bit\u00a0  &lt;&gt;\u00a0IN\n</code></pre> Transitioning from Verilog <ul> <li>Declaration Syntax: Port and variable declaration syntax is obviously very different</li> <li>Types: </li> <li>Scope</li> <li>The non-blocking assignment operator in DFHDL is <code>:==</code> instead of <code>&lt;=</code> in Verilog.</li> </ul> Transitioning from VHDL <ul> <li>VHDL has </li> </ul>"},{"location":"user-guide/type-system/#dcl-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#dcl-scope","title":"Scope","text":"<ul> <li> <p>Variables can be declared in any DFHDL scope, except global scope, meaning within DFHDL designs, domains, interfaces, methods, processes, and conditional blocks. <pre><code>//error: Port/Variable declarations cannot be global\nval x = Bit &lt;&gt; VAR \nclass Foo extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n</code></pre></p> </li> <li> <p>Ports can only be declared at the scopes of DFHDL designs, domains, and interfaces. Other scopes are not allowed. <pre><code>class Foo extends DFDesign:\n  val i = Boolean &lt;&gt; IN\n  if (i)\n    //error: Ports can only be directly owned by a design, a domain or an interface.\n    val o = Bit &lt;&gt; OUT \n    o := 0\n</code></pre></p> </li> </ul>"},{"location":"user-guide/type-system/#dcl-naming","title":"Naming","text":"<p>Ports and variables must always be named, and cannot be anonymous. </p> Anonymous declaration elaboration error example<pre><code>class Foo extends DFDesign:\n  //elaboration error: Unable to determine names for the members declared at the following positions\n  Bit &lt;&gt; OUT \n</code></pre> <p>As you'll read later on, constants and other values can be anonymous.</p>"},{"location":"user-guide/type-system/#dcl-connectable","title":"Connectable","text":"<p>Ports and variables are connectable, meaning they can be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.  For input ports this occurs outside their design scope, while connecting to an external value.  For output ports and variables this occurs only within their design scope, while connecting to an internal value. <pre><code>class ID extends DFDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  y &lt;&gt; x //connecting x to y\n</code></pre></p>"},{"location":"user-guide/type-system/#dcl-assignable","title":"Assignable (Mutable)","text":"<p>Output ports, input-output ports, and variables are assignable (mutable), when they can be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation, which occurs only within their design scope. Input ports can never be assigned (are immutable). Registered ports and variables are assignable only when referencing their registers' input via <code>.din</code> selection (referencing a register without <code>.din</code> is always considered to be its output, which is immutable). </p> <p>Assignment semantics are a key difference between the different design domains DFHDL has to offer. Here are some basic examples: <pre><code>class Foo1 extends DFDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  //dataflow assignment of x to y\n  y := x\n\nclass Foo2 extends RTDesign:\n  val x  = Bit &lt;&gt; IN\n  val y1 = Bit &lt;&gt; OUT\n  val y2 = Bit &lt;&gt; OUT.REG\n  //wire assignment of x to y1\n  y1     := x \n  //registered assignment of x to y2\n  y2.din := x \n\nclass Foo3 extends EDDesign:\n  val clk = Bit &lt;&gt; IN\n  val x   = Bit &lt;&gt; IN\n  val y1  = Bit &lt;&gt; OUT\n  val y2  = Bit &lt;&gt; OUT\n  process(all):\n    //blocking assignment of x to y1\n    y1 := x \n  process(clk):\n    if (clk.rising)\n      //non-blocking assignment of x to y2\n      y2 :== x \n\nclass Errors1 extends RTDesign:\n  val x  = Bit &lt;&gt; IN\n  val y1 = Bit &lt;&gt; OUT.REG\n  val y2 = Bit &lt;&gt; OUT\n  //error: Cannot assign to an immutable value.\n  x  := 1\n  //error: Cannot assign to a register output; it is immutable.\n  //To assign to the register's input, apply `.din` on the LHS argument of the assignment.\n  y1 := x\n  //error: Non-blocking assignments `:==` are allowed only inside an event-driven (ED) domain.\n  //Change the assignment to a regular assignment `:=` or the logic domain to ED.\n  y2 :== x\n\nclass Errors2 extends EDDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  //error: Blocking assignments `:=` are only allowed inside a process under an event-driven (ED) domain.\n  //Change the assignment to a connection `&lt;&gt;` or place it in a process.\n  y := x\n  //error: Non-blocking assignments `:==` are only allowed inside a process under an event-driven (ED) domain.\n  //Change the assignment to a connection `&lt;&gt;` or place it in a process.\n  y :== x\n</code></pre> Be sure to read more on assignment rules and semantics in the assignment section.</p>"},{"location":"user-guide/type-system/#dcl-variability","title":"Variability (Not Constant)","text":"<p>DFHDL ports and variables are never considered to be constant (even when connected/assigned only once and to a constant value) for elaboration. Later compilation stages can apply further constant propagation steps that reduce logic utilization. <pre><code>class Errors extends DFDesign:\n  val x  = Bit &lt;&gt; VAR\n  x := 1\n  val c: Bit &lt;&gt; CONST = 1\n  // error: Not a constant\n  val e: Bit &lt;&gt; CONST = x\n</code></pre></p>"},{"location":"user-guide/type-system/#inout-port-limitation","title":"<code>INOUT</code> Port Limitation","text":"<p><code>INOUT</code> (bidirectional) ports are generally used to define IO pins of top-level device connectivity (e.g., protocols like I<sup>2</sup>C benefit from such ability). They are not meant for inter-device wiring reduction, and thus should be used scarcely within their intended purpose. Throughout the years they were also used to workaround HDL limitations like reading from output ports in VHDL'93, or lack of interfaces. Since DFHDL has none of these limitations, we encourage you to use <code>INOUT</code> for their intended purpose only, as synthesis tools for FPGAs and even ASICs will not cooperate. Although, theoretically, in DF domain we can enable bidirectional communication that can later be compiled into two separate ports, there is no real value behind this. <pre><code>class I2CCore extends EDDesign:\n  val scl = Bit &lt;&gt; INOUT\n  val sda = Bit &lt;&gt; INOUT\n</code></pre></p>"},{"location":"user-guide/type-system/#dcl-variability","title":"Grouping","text":"<p>Ports can be grouped together in dedicated interfaces.</p>"},{"location":"user-guide/type-system/#dcl-transitioning","title":"Transitioning","text":"Transitioning from Verilog <ul> <li>Declaration Syntax: Port and variable declaration syntax is obviously very different</li> <li>Types: </li> <li>Scope</li> <li>The non-blocking assignment operator in DFHDL is <code>:==</code> instead of <code>&lt;=</code> in Verilog.</li> </ul> Transitioning from VHDL <p>TODO</p> Differences from Scala parameters/fields <p>TODO: Data validity, Number of outputs</p>"},{"location":"user-guide/type-system/#DFConst","title":"Constant/Literal Values","text":"<p>In DFHDL there are three methods to construct constant DFHDL values:</p> <ol> <li>Literal value generators: These language constructs directly generate constant DFHDL values. Currently, these are:<ul> <li>Binary <code>Bits</code> string interpolator</li> <li>Hexadecimal <code>Bits</code> string interpolator</li> <li>Decimal string interpolator</li> <li>Signed Decimal string interpolator</li> </ul> </li> <li>Constant candidates: Various Scala values can become DFHDL values, as. Constant declaration syntax<pre><code>val\u00a0_name_: _dftype_ &lt;&gt; CONST\u00a0=\u00a0_value_\n</code></pre></li> <li>Constant value propagation: Cleaners</li> </ol>"},{"location":"user-guide/type-system/#const-syntax","title":"Syntax","text":""},{"location":"user-guide/type-system/#const-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#unconnectable","title":"Unconnectable","text":"<p>Constant values are not connectable, meaning they can never be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.</p>"},{"location":"user-guide/type-system/#unassignable-immutable","title":"Unassignable (Immutable)","text":"<p>Constant values are immutable and cannot be assigned, meaning they can never be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation.</p>"},{"location":"user-guide/type-system/#dfhdl-value-statement-order-referencing","title":"DFHDL Value Statement Order &amp; Referencing","text":"<p>Any DFHDL value must be declared before it can be referenced in code. Other than this (pretty intuitive) limitation, no other limitations exist and ports, variables, constants, and other values may be freely distributed within their approved scope space. During the compilation process, you can notice that the compiler reorders the port declarations so that they always come second to constant declarations, and variables right after.</p>"},{"location":"user-guide/type-system/#connection","title":"DFHDL Value Connections","text":"<p>After (or during) a design instantiation, its ports need to be connected to other ports or values of the same DFType by applying the <code>&lt;&gt;</code> operator. Variables can also be connected and used as intermediate wiring between ports. Output ports can be directly referenced (read) without being connected to an intermediate variable. For more rules about design and port connectivity, see the relevant section. Successful port/variable connection example<pre><code>class ID extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  //internal connection between ports\n  y &lt;&gt; x \n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre></p> Failed port/variable connection example<pre><code>class Foo extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y1 = Bit     &lt;&gt; OUT\n  val y2 = UInt(8) &lt;&gt; OUT\n  y1 &lt;&gt; x //DFType mismatch error\n  y2 &lt;&gt; x\n  //connection error (cannot connect \n  //to the same port more than once)\n  y2 &lt;&gt; x \n</code></pre>"},{"location":"user-guide/type-system/#assignment","title":"DFHDL Value Assignment (Mutation)","text":"<p>Both output ports and variables are mutable and can be assigned with values of the same DFType and only within the scope of the design they belong to. Input ports cannot be directly assigned, and require an intermediate variable connected to them to modify their value. Generally assignments to DFHDL values are applied through the <code>:=</code> operator. In processes under ED domains there are two kind of assignments: blocking assignments via <code>:=</code>, and non-blocking assignments via <code>:==</code>. Other domains support only blocking assignments via <code>:=</code>. Read more on domain semantics in the next section. See the connectivity section for more rules about mixing connections and assignments.</p> Successful port/variable connection example<pre><code>class Shift extends DFDesign:\n  val x = Bits(8) &lt;&gt; IN\n  val y = Bits(8) &lt;&gt; OUT\n  //assigning `x` left-shifted by 1 \n  //to `y`\n  y := x &lt;&lt; 1\n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre> <p>Don't use <code>var</code> with DFHDL values/designs</p> <p>Because the semantics may get confusing, we enforced a compiler warning if a DFHDL value/design is constructed and fed into a Scala <code>var</code> reference. You can apply a Scala <code>@nowarn</code> annotation to suppress this warning.</p> Warning when using a Scala `var` and suppression example<pre><code>import scala.annotation.nowarn\nclass Foo extends DFDesign:\n  //warning: \n  //Scala `var` modifier for DFHDL \n  //values/designs is highly discouraged!\n  //Consider changing to `val`.   \n  var a = UInt(8) &lt;&gt; IN\n  //this specific warning is suppressed\n  @nowarn(\"msg=Scala `var` modifier for DFHDL\")\n  var ok = UInt(8) &lt;&gt; IN \n</code></pre>"},{"location":"user-guide/type-system/#mutability","title":"DFHDL Value Mutation","text":"<p>DFiant supports dataflow variables mutability via the <code>:=</code> operator. Do not confuse with Scala-level mutability which is enabled by using <code>var</code> instead of <code>val</code>. Each dataflow class has two variations: an immutable class, which inherits from <code>DFAny.Val</code> and a mutable class, which inherits from <code>DFAny.Var</code> and accepts <code>:=</code>. The difference between the types enforces an immutable right-hand-side (RHS), where required, and a mutable variable creation. </p> <p>Consider, for instance, the DFiant implementation of <code>g</code> in Table \\ref<code>tbl:StateExDefImpl</code>: <code>a</code> is immutable because it is a RHS addition between the dataflow variable <code>i</code> and a literal value <code>5</code>. Contrarily, <code>c</code> is mutable, since it is a dataflow variable constructor (<code>.init</code> constructs a new initialized variable, while preserving the mutability trait). </p> <p>Fig. 1 demonstrates a dual class definition for every type  (immutable and mutable). The naming convention helps to reason about the mutability. For example, <code>DFBits</code> and <code>DFBits.Var</code> are immutable and mutable classes, respectively. Constructing a new variable via <code>DFBits</code> (e.g, <code>val a = DFBits[5]</code>) returns the mutable <code>DFBits.Var[5]</code>. Usually, we either receive or return an immutable type, hence we do not require annotating a type with its mutable variation. In cases where we want to return a mutable type, we annotate it as an output port (see Section~\\ref<code>sec:io_ports</code>).</p>"},{"location":"user-guide/type-system/#bit-accurate-operations-type-inference-and-data-structures","title":"Bit-Accurate Operations, Type Inference, and Data Structures","text":"<p>All DFiant's dataflow types are bit-accurate and structurally static, with their bit-width set upon construction (e.g., <code>DFBits[5]</code> is a 5-bit vector). Operations between dataflow variables produce a bit-accurate result with the proper type inference. For example, an addition between an unsigned 5-bit variable (<code>DFUInt[5]</code>) and a signed 10-bit variable (<code>DFSInt[10]</code>) produces an adder that can be implicitly converted to a 10-bit signed variable, if carry is not required, or an 11-bit signed variable by explicitly invoking <code>.wc</code> from the addition.</p> <p>DFiant also allows operations between dataflow types and their corresponding Scala numeric types, by treating the Scala numeric types as constants (e.g., addition between <code>DFSInt</code> and <code>Integer</code> variables). A constant in the dataflow graph is a node that can produce infinite tokens of the same value.   </p>"},{"location":"user-guide/type-system/#bit-aliasing-and-casting","title":"Bit Aliasing and Casting","text":"<p>Aliasing in DFiant enables referencing a part of a dataflow variable, by invoking <code>.bits(hiIdx, loIdx)</code>, which creates a bits vector alias that references the original variable at the given index parameters. Every change of a dataflow variable affects its alias and vice versa (similar to VHDL's signal aliasing). Since this function also casts the variable as <code>DFBits</code>, this feature is used as a raw-data cast between different dataflow types. Aliasing of an alias is also possible, while maintaining relative bits indexing. Aliasing preserves the mutability trait: an alias of an immutable value is immutable, while an alias of a mutable variable is mutable. </p> <p>Fig.~\\ref<code>fig:Aliasing</code> demonstrates aliasing code and its effect on the contents of a dataflow variable (<code>bits128</code>). Each line code does as follows:</p> <ol> <li>Constructs a new 128-bit vector, <code>bits128</code>, and clears it.</li> <li>Creates a new alias, <code>alias64</code>, which references the most significant 64 bits of <code>bits128</code>. Since <code>bits128</code> is a <code>DFBits</code> variable, there is no need to invoke <code>.bits()</code>, and we can apply the required indexes directly.</li> <li>Creates a new alias, <code>alias32</code>, which references the least significant 32 bits of <code>alias64</code>, which reference bits 64 to 95 of <code>bits128</code>.</li> <li>Constructs a new double precision floating point dataflow variable, <code>dbl</code>, and initialize its value as <code>1.0</code> (hexadecimal value of <code>0x3FF00...0</code>).</li> <li>Modifies the least significant byte of <code>dbl</code>.</li> <li>Sets the most significant bit of <code>bits128</code>.</li> <li>Assigns <code>dbl</code> to the least significant 64 bits of <code>bits128</code> through casting. All the bits of <code>dbl</code> are selected because <code>.bits()</code> is invoked without index parameters.</li> <li>Modifies a byte of <code>bits128</code>.</li> </ol>"},{"location":"user-guide/type-system/#bubble","title":"Bubble Values","text":"<ul> <li>RT and ED - Don't Care / Unknown</li> <li>DF - Stall</li> </ul>"},{"location":"user-guide/type-system/#dfhdl-value-candidates","title":"DFHDL Value Candidates","text":"<p>TODO: requires explanation The candidate produces a constant DFHDL value if the candidate argument is a constant.</p> <p>Operation supported values for an argument of DFType <code>T</code></p> `T`Candidate`T`ValueAnyValue`T`OperationCandidate . is! .. is? .. is? .. is! .. is? . Bits assignment and concatenation operation candidates example<pre><code>val b8 = Bits(8) &lt;&gt; VAR //8-bits variable\nval b9 = Bits(9) &lt;&gt; VAR //9-bits variable\n\n//Assignment operations to b8 accept either\n//Bits candidates that are 8-bit wide or\n//a same-element-vector (SEV) of \n//0/1/true/false, via `all(elem)`.\nb8 := h\"FF\"  //ok: 8-bits constant\nb8 := all(0) //ok: SEV of 0\nb8 := 5      //fails `Bits` candidate\nb8 := b9     //fails `:=` candidate\n\n//Bits `++` concatenation operation with b8\n//only accepts Bits candidate, while SEV\n//is not a Bits candidate.\nval x = b8 ++ h\"FF\"  //ok\nval y = b8 ++ all(0) //error\n</code></pre>"},{"location":"user-guide/type-system/#DFBitOrBool","title":"<code>Bit</code>/<code>Boolean</code> DFHDL Values","text":"<p><code>Bit</code> DFHDL values represent binary <code>1</code> or <code>0</code> values, whereas <code>Boolean</code> DFHDL values represent <code>true</code> or <code>false</code> values, respectively. The <code>Bit</code> and <code>Boolean</code> DFHDL values are generally interchangeable, and automatically converted between one and the other. </p> <p>Should I use <code>Bit</code> or <code>Boolean</code> DFTypes?</p> <p>Although they are interchangeable, it's generally recommended to use <code>Boolean</code> DFHDL values with conditional <code>if</code> statements, guards, or expressions, and <code>Bit</code> DFHDL values for everything else. There could be constant parameters that are better defined as a <code>true</code> or <code>false</code> <code>Boolean</code> values rather than <code>0</code> or <code>1</code> <code>Bit</code> values.</p> Why have both <code>Bit</code> and <code>Boolean</code> DFTypes? <p>The main reason to differentiate between <code>Bit</code> and <code>Boolean</code> is that VHDL has both <code>std_logic</code> and <code>boolean</code> types, respectively. Verilog has only a single <code>logic</code> or <code>wire</code> to represent both. Indeed VHDL'2008 has relaxed some of the type constraints, but not enough. And nevertheless, DFHDL aims to support various HDL dialects, and thus enables simple implicit or explicit conversion between these two DFType values.</p>"},{"location":"user-guide/type-system/#dftype-constructors","title":"DFType Constructors","text":"<p>Use the <code>Bit</code> or <code>Boolean</code> objects/types to construct <code>Bit</code> or <code>Boolean</code> DFHDL values, respectively.</p> <pre><code>val bit   = Bit     &lt;&gt; VAR\nval bool  = Boolean &lt;&gt; VAR\nval c_bit:  Bit     &lt;&gt; CONST = 1\nval c_bool: Boolean &lt;&gt; CONST = false\n</code></pre>"},{"location":"user-guide/type-system/#candidates","title":"Candidates","text":"<ul> <li>DFHDL <code>Bit</code> values.</li> <li>DFHDL <code>Boolean</code> values. </li> <li>Scala <code>1</code> or <code>0</code> literal values. A regular Scala <code>Int</code> is not accepted. This candidate always produces a constant DFHDL value.</li> <li>Scala <code>Boolean</code> values. This candidate always produces a constant DFHDL value.</li> </ul> <pre><code>val bit  = Bit     &lt;&gt; VAR\nval bool = Boolean &lt;&gt; VAR\n//`bool` is implicitly converted to a \n//Bit DFHDL value.\nbit := bool \n//`1` is implicitly converted to a DFHDL\n//Bit constant value.\nbit := 1\n//`false` is implicitly converted to a \n//DFHDL Boolean constant, and then\n//converted to a Bit constant value.\nbit := false\nval one: Int = 1\n//error (only 1/0 literals are ok)\nbit := one \n//`bit` is implicitly converted to a\n//DFHDL Boolean\nbool := bit \n//`true` is implicitly converted to a \n//DFHDL Boolean constant value.\nbool := true\n//`0` is implicitly converted to a \n//DFHDL Bit constant, and then\n//converted to a Boolean constant value.\nbool := 0\nval TrueVal: Boolean = 1\n//`TrueVal` is implicitly converted to\n//a DFHDL Boolean value.\nbool := TrueVal \n</code></pre>"},{"location":"user-guide/type-system/#operations","title":"Operations","text":""},{"location":"user-guide/type-system/#explicit-casting-operations","title":"Explicit Casting Operations","text":"<p>These operations propagate constant modifiers, meaning that if the casted argument is a constant, the returned value is also a constant.</p> Operation Description LHS Constraints Returns <code>lhs.bool</code> Cast to a DFHDL <code>Boolean</code> value <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.bit</code> Cast to a DFHDL <code>Bit</code> value <code>Boolean</code> DFHDL value <code>Bit</code> DFHDL value <pre><code>val bt1 = Bit &lt;&gt; VAR\nval bl1 = bt1.bool\nval bl2 = Boolean &lt;&gt; VAR\nval bt2 = bl2.bit\nval bt3: Bit     &lt;&gt; CONST = 0\nval bl3: Boolean &lt;&gt; CONST = bt3.bool\nval bl4: Boolean &lt;&gt; CONST = true\nval bt4: Bit     &lt;&gt; CONST = bt4.bit\n// error: bt1 is not a constant\nval err: Bit     &lt;&gt; CONST = bt1\n</code></pre>"},{"location":"user-guide/type-system/#bit-history-operations","title":"Bit History Operations","text":"<p>Currently these operations are only supported under ED domains. However, in upcoming DFHDL updates, support will be added across all domain abstractions.</p> Operation Description LHS Constraints Returns <code>lhs.rising</code> True when a value changes from <code>0</code> to <code>1</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.falling</code> True when a value changes from <code>1</code> to <code>0</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <pre><code>class Foo extends EDDesign:\n  val clk  = Bit &lt;&gt; IN\n\n  /* VHDL-style */\n  process(clk):\n    if (clk.rising) \n      //some sequential logic\n\n  /* Verilog-style */\n  process(clk.rising):\n    //some sequential logic\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the Verilog <code>posedge x</code> and <code>negedge x</code>, respectively.  In future releases these operations will have an expanded functionality under the other design domains.</p> Transitioning from VHDL <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the VHDL <code>rising_edge(x)</code> and <code>falling_edge(x)</code>, respectively. In future releases these operations will have an expanded functionality under the other design domains.</p> <p>For more information see either the design domains or processes sections.</p>"},{"location":"user-guide/type-system/#logical-operations","title":"Logical Operations","text":"<p>Logical operations' return type always match the LHS argument's type. These operations propagate constant modifiers, meaning that if all arguments are constant, the returned value is also a constant.</p> Operation Description LHS/RHS Constraints Returns <code>lhs &amp;&amp; rhs</code> Logical AND The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs || rhs</code> Logical OR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs ^ rhs</code> Logical XOR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>!lhs</code> Logical NOT The argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. LHS-Type DFHDL value <pre><code>val bt = Bit     &lt;&gt; VAR\nval bl = Boolean &lt;&gt; VAR\nval t1 = bt &amp;&amp; bl    //result type: Bit\nval t2 = bt ^ 1      //result type: Bit\nval t3 = bl || false //result type: Boolean\nval t4 = bt &amp;&amp; true  //result type: Bit\nval t5 = bl || bt    //result type: Boolean\nval t6 = bl ^ 0 || !bt\n//`t7` after the candidate implicit\n//conversions, looks like so:\n//(bl &amp;&amp; bt.bool) ^ (!(bt || bl.bit)).bool\nval t7 = (bl &amp;&amp; bt) ^ !(bt || bl)\n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e1 = 0 ^ bt      \n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e2 = false ^ bt\n//not supported since both arguments\n//are just candidates\nval e3 = 0 ^ true\n//This just yields a Scala Boolean, \n//as a basic operation between Scala\n//Boolean values.\nval sc: Boolean = true &amp;&amp; true\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation Verilog Operation <code>lhs &amp;&amp; rhs</code> <code>lhs &amp; rhs</code> <code>lhs || rhs</code> <code>lhs | rhs</code> <code>lhs ^ rhs</code> <code>lhs ^ rhs</code> <code>!lhs</code> <code>!lhs</code> Transitioning from VHDL <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation VHDL Operation <code>lhs &amp;&amp; rhs</code> <code>lhs and rhs</code> <code>lhs || rhs</code> <code>lhs or rhs</code> <code>lhs ^ rhs</code> <code>lhs xor rhs</code> <code>!lhs</code> <code>not lhs</code>"},{"location":"user-guide/type-system/#constant-meta-operations","title":"Constant Meta Operations","text":"<p>These operations are activated during the elaboration stage of the DFHDL compilation, and are only available for constant <code>Bit</code>/<code>Boolean</code> DFHDL values.  Their use case is for meta-programming purposes, to control the generated code without the knowledge of the DFHDL compiler (could be considered as pre-processing steps).</p> Operation Description LHS Constraints Returns <code>lhs.toScalaBitNum</code> Extracts the known elaboration Scala <code>BitNum</code>(<code>1 | 0</code>) value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>BitNum</code> value <code>lhs.toScalaBoolean</code> Extracts the known elaboration Scala <code>Boolean</code> value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>Boolean</code> value <p>The following runnable example demonstrates how such meta operation affect the elaborated design.  The <code>Boolean</code> argument <code>arg</code> of a design <code>Foo</code> is used twice within the design:  first, in an <code>if</code> condition directly; and second, in an <code>if</code> condition after a Scala value extraction.  When referenced directly, the <code>if</code> is elaborated as-is, but when the <code>if</code> is applied on the extracted Scala value,  the <code>if</code> is completely removed and either the block inside the <code>if</code> is elaborated when the argument is true or completely removed if false.</p> <code>Foo</code><code>Foo(true)</code><code>Foo(false)</code> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n    if (arg.toScalaBoolean) o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n    o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n</code></pre> Runnable example <pre><code>import dfhdl.*\n\n@top(false) class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n  if (arg.toScalaBoolean) o := 0\n\n@main def main = \n  println(\"Foo(true) Elaboration:\")\n  Foo(true).printCodeString\n  println(\"Foo(false) Elaboration:\")\n  Foo(false).printCodeString</code></pre>"},{"location":"user-guide/type-system/#DFBits","title":"<code>Bits</code> DFHDL Values","text":"<p><code>Bits</code> DFHDL values represent vectors of DFHDL <code>Bit</code> values as elements.  The vector bits width (length) is a positive constant number (nilable [zero-width] vectors will be supported in the future).</p> <p>Differences between DFHDL <code>Bits</code> and DFHDL Vector of <code>Bit</code></p> <p>In addition to <code>Bits</code>, DFHDL also supports generic vectors of any DFHDL values.  One could therefore construct a generic vector with <code>Bit</code> as the element DFType.  This vector has a different type than <code>Bits</code>, since <code>Bits</code> is a special case, both internally  in their implementations and externally in their API. Where applicable, both <code>Bits</code> and generic vector of <code>Bits</code> have overlapping equivalent APIs. </p>"},{"location":"user-guide/type-system/#dftype-constructors_1","title":"DFType Constructors","text":"Constructor Description Arg Constraints Returns <code>Bits(width)</code> Construct a <code>Bits</code> DFType with the given <code>width</code> as number of bits. <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[width.type]</code> DFType <code>Bits.until(sup)</code> Construct a <code>Bits</code> DFType with the given <code>sup</code> supremum number the vector is expected to reach. The number of bits is set as <code>clog2(sup)</code>. <code>sup</code> is a Scala <code>Int</code> or constant DFHDL <code>Int</code> value larger than 1. <code>Bits[CLog2[width.type]]</code> DFType <code>Bits.to(max)</code> Construct a <code>Bits</code> DFType with the given <code>max</code> maximum number the vector is expected to reach. The number of bits is set as <code>clog2(max+1)</code>. <code>max</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[CLog2[width.type+1]]</code> DFType <code>Bits[W]</code> Construct a <code>Bits</code> DFType with the given <code>W</code> width as Scala type argument (for advanced users). <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> Singleton type. <code>Bits[W]</code> DFType <pre><code>val b8 = Bits(8)       &lt;&gt; VAR\nval b3 = Bits.until(8) &lt;&gt; VAR\nval b4 = Bits.to(8)    &lt;&gt; VAR\nval b9 = Bits[9]       &lt;&gt; VAR\nval w: Int &lt;&gt; CONST = 7\nval b7 = Bits(w)       &lt;&gt; VAR\nval b6: Bits[6] &lt;&gt; CONST = all(0)\n</code></pre> Transitioning from Verilog <ul> <li>Specifying a width instead of an index range: In Verilog bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>[width-1:0]</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common Verilog bit vector declaration. For example, instead of declaring <code>reg [$clog2(DEPTH)-1:0] addr</code> in Verilog, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul> Transitioning from VHDL <ul> <li>Specifying a width instead of an index range: In VHDL bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>(width-1 downto 0)</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common VHDL bit vector declaration. For example, instead of declaring <code>signal addr: std_logic_vector(clog2(DEPTH)-1 downto 0)</code> in VHDL, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul>"},{"location":"user-guide/type-system/#literal-constant-value-generation","title":"Literal (Constant) Value Generation","text":"<p>Literal (constant) DFHDL <code>Bits</code> value generation is carried out through binary and hexadecimal string interpolation, a core Scala feature that was customized for DFHDL's exact use-case. There are also bit-accurate decimal and signed decimal interpolations available that produce <code>UInt</code> and <code>SInt</code> DFHDL values. If needed, those values can be cast to <code>Bits</code>. No octal interpolation is currently available or planned.</p>"},{"location":"user-guide/type-system/#b-interp","title":"Binary Bits String-Interpolator","text":"Binary Bits string-interpolation syntax<pre><code>b\"width'bin\"\n</code></pre> <ul> <li>bin is a sequence of <code>0</code>, <code>1</code>, and <code>?</code> characters, each representing a single bit.  <code>?</code> indicates a bit bubble.    The leftest (first) character is the most-significant bit (MSB), and the rightest (last) character is    the least-significant bit (LSB). </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>bin</code> are ignored.</li> <li><code>bin</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>width, followed by a <code>'</code> (apostrophe), is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added at the left of the sequence or the sequence is truncated based on the <code>width</code>.    Truncation only occurs if the MSBits being removed are zeros; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Binary Bits string-interpolation examples<pre><code>b\"1\"        // Value = 1\nb\"1000\"     // Value = 1000\nb\"8'1000\"   // Value = 00001000\nb\"3'0100\"   // Value = 100\nb\"3'1100\"   // Compilation error\nb\"1?11\"     // Value = 1?11 (? indicates a bit bubble)\nb\"11_00\"    // Value = 1100\nval value = \"100\"\nval width = 10\nb\"$width'1${value}1\" //Value = 0000011001\nval p: Int &lt;&gt; CONST = 10\nb\"$p'0\" // Value = 0....0 (p-bits wide)\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#h-interp","title":"Hexadecimal Bits String-Interpolator","text":"Hexadecimal Bits string-interpolation syntax<pre><code>h\"width'hex\"\n</code></pre> <ul> <li>hex is a sequence of hexadecimal characters (<code>0</code>-<code>9</code>, <code>A</code>-<code>F</code>, <code>a</code>-<code>f</code>, and <code>?</code>)   where <code>?</code> indicates a 4-bit bubble. Each character represents a 4-bit nibble,    encoded such that the leftest bit is the most-significant bit.    The leftest (first) character is the most-significant nibble, and the rightest (last) character is    the least-significant nibble. </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>hex</code> are ignored.</li> <li><code>hex</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>Binary sequences can be embedded within <code>{bin}</code> tags, allowing integration of binary   bit sequences of any length, not necessarily divisible by 4, between hex nibbles.</li> <li>width, followed by a <code>'</code>, is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added or the sequence is truncated based on the <code>width</code>. Truncation only occurs if   the most significant bits being removed are zeros or bubbles; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Hexadecimal Bits string-interpolation examples<pre><code>h\"1\"        // Value = 0001\nh\"27\"       // Value = 00100111\nh\"6'27\"     // Value = 100111\nh\"5'27\"     // Compilation error\nh\"2?\"       // Value = 0010????\nh\"F{00}F\"   // Value = 1111001111\nh\"3_3\"      // Value = 00110011\nval value = \"FF\"\nval width = 10\nh\"$width'${value}\" //Value = 0011111111\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#candidates_1","title":"Candidates","text":"<ul> <li>DFHDL <code>Bits</code> values</li> <li>DFHDL <code>Bit</code> or <code>Boolean</code> values. This candidate produces a single bit <code>Bits[1]</code> vector. </li> <li>DFHDL <code>UInt</code> values</li> <li>Scala <code>Tuple</code> combination of any DFHDL values and <code>1</code>/<code>0</code> literal values. This candidate performs bit concatenation of all values, according their order in the tuple, encoded from the most-significant value position down to the least-significant value position.</li> <li>Application-only candidate - Same-Element Vector (<code>all(elem)</code>).  </li> </ul> <pre><code>val b8   = Bits(8) &lt;&gt; VAR\nval b1   = Bits(1) &lt;&gt; VAR\n//`bit` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bit  = Bit     &lt;&gt; VAR\nb1 := bit\n//`bool` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bool = Boolean &lt;&gt; VAR\nbool := bit\n//`u8` is implicitly converted to a \n//Bits[8] DFHDL value.\nval u8   = UInt(8) &lt;&gt; VAR\nb8 := u8\nval s4   = SInt(4) &lt;&gt; VAR\n//the tuple is implicitly converted\n//to a Bits[8] DFHDL value.\nb8 := (1, s4, b1, b\"10\")\n</code></pre>"},{"location":"user-guide/type-system/#concatenated-assignment","title":"Concatenated Assignment","text":"<p>DFHDL supports a special-case assignment of concatenated DFHDL Bits variables, using a Scala <code>Tuple</code> syntax on LHS of the assignment operator. Both LHS and RHS bits width must be the same. This assignment is just syntactic sugar for multiple separate assignments and carried out during the design elaboration. The assignment ordering is from the first value at most-significant position down to the last value at least-significant position.</p> <code>Foo Declaration</code><code>Foo Elaboration</code> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")\n</code></pre> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  b2 := b\"10\"\n  b5 := (b\"1\", i4).toBits\n  b3 := b\"111\"\n</code></pre> Runnable example <pre><code>import dfhdl.*\n\n//print the code after elaboration\ngiven options.ElaborationOptions.PrintDFHDLCode = true\n//set mode to elaborate only\ngiven options.AppOptions.DefaultMode = options.AppOptions.DefaultMode.elaborate\n\n@top class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")</code></pre>"},{"location":"user-guide/type-system/#DFDecimal","title":"<code>UInt</code>/<code>SInt</code>/<code>Int</code> DFHDL Values","text":""},{"location":"user-guide/type-system/#constant-generation","title":"Constant Generation","text":""},{"location":"user-guide/type-system/#d-interp","title":"Decimal String-Interpolator","text":""},{"location":"user-guide/type-system/#sd-interp","title":"Signed Decimal String-Interpolator","text":""},{"location":"user-guide/type-system/#DFEnum","title":"Enumeration DFHDL Values","text":""},{"location":"user-guide/type-system/#DFVector","title":"Vector DFHDL Values","text":""},{"location":"user-guide/type-system/#DFStruct","title":"Struct DFHDL Values","text":""},{"location":"user-guide/type-system/#DFTuple","title":"Tuple DFHDL Values","text":""},{"location":"user-guide/type-system/#DFOpaque","title":"Opaque DFHDL Values","text":""},{"location":"user-guide/type-system/#DFUnit","title":"Unit (Void) DFHDL Values","text":""}]}