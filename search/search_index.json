{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DFiant HDL Docs (DFDocs) \ud83d\udd17 The Official DFiant Hardware Description Language (HDL) Documentation Welcome to the DFiant hardware description language (HDL) documentation! DFiant is a dataflow HDL and is embedded as a library in the Scala programming language . DFiant enables timing-agnostic and device-agnostic hardware description by using dataflow firing rules as logical constructs, coupled with modern software language features (e.g., inheritance, polymorphism) and classic HDL features (e.g., bit-accuracy, input/output ports). By this point you may already have some questions: Why do we need yet another HDL? Why are high-level synthesis (HLS) tools not enough? What is a dataflow HDL? Answers to these questions await you at the linked sections. But , if you're curious about the DFiant language, checkout our first-look section first. Required Knowledge \ud83d\udd17 You are not required to know Scala , yet you are expected to understand basic object oriented concepts. This documentation attempts to bridge over any syntactic gaps you may arrive at. Nonetheless, as you attempt to create more complex and generic designs, more Scala knowledge will be required of you. You are not required to be an FPGA/ASIC expert , yet you are expected to understand fundamental hardware description concepts found in languages such as Verilog and VHDL. You are required to keep an open mind . Some of these concepts may seem strange at first, but they were set after careful thought and planning. However, we are not infallible so feel free to file an issue with questions and/or suggestions of different approaches we can take. First release and more info coming soon... \ud83d\udd17","title":"DFDocs"},{"location":"#dfiant-hdl-docs-dfdocs","text":"The Official DFiant Hardware Description Language (HDL) Documentation Welcome to the DFiant hardware description language (HDL) documentation! DFiant is a dataflow HDL and is embedded as a library in the Scala programming language . DFiant enables timing-agnostic and device-agnostic hardware description by using dataflow firing rules as logical constructs, coupled with modern software language features (e.g., inheritance, polymorphism) and classic HDL features (e.g., bit-accuracy, input/output ports). By this point you may already have some questions: Why do we need yet another HDL? Why are high-level synthesis (HLS) tools not enough? What is a dataflow HDL? Answers to these questions await you at the linked sections. But , if you're curious about the DFiant language, checkout our first-look section first.","title":"DFiant HDL Docs (DFDocs)"},{"location":"#required-knowledge","text":"You are not required to know Scala , yet you are expected to understand basic object oriented concepts. This documentation attempts to bridge over any syntactic gaps you may arrive at. Nonetheless, as you attempt to create more complex and generic designs, more Scala knowledge will be required of you. You are not required to be an FPGA/ASIC expert , yet you are expected to understand fundamental hardware description concepts found in languages such as Verilog and VHDL. You are required to keep an open mind . Some of these concepts may seem strange at first, but they were set after careful thought and planning. However, we are not infallible so feel free to file an issue with questions and/or suggestions of different approaches we can take.","title":"Required Knowledge"},{"location":"#first-release-and-more-info-coming-soon","text":"","title":"First release and more info coming soon..."},{"location":"about/LICENSE/","text":"License \ud83d\udd17 Copyright (c) 2019 Oron Port and Yoav Etsion This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see https://www.gnu.org/licenses/ . GNU General Public License version 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS 0. Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. 14. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see <https://www.gnu.org/licenses/>. The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read <https://www.gnu.org/licenses/why-not-lgpl.html>. GNU Lesser General Public License version 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. 0. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. 1. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. 2. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. 3. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. 4. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) 5. Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 6. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"License"},{"location":"about/LICENSE/#license","text":"Copyright (c) 2019 Oron Port and Yoav Etsion This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see https://www.gnu.org/licenses/ . GNU General Public License version 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS 0. Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. 14. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see <https://www.gnu.org/licenses/>. The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read <https://www.gnu.org/licenses/why-not-lgpl.html>. GNU Lesser General Public License version 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. 0. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. 1. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. 2. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. 3. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. 4. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) 5. Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 6. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"License"},{"location":"about/acknowledgements/","text":"Acknowledgements \ud83d\udd17 This work has been supported by EU H2020 ICT project LEGaTO, contract #780681.","title":"Acknowledgements"},{"location":"about/acknowledgements/#acknowledgements","text":"This work has been supported by EU H2020 ICT project LEGaTO, contract #780681.","title":"Acknowledgements"},{"location":"about/contributing/","text":"Contributing \ud83d\udd17 We will most likely adopt the code of conduct of Django . This page will be updated soon.","title":"Contributing"},{"location":"about/contributing/#contributing","text":"We will most likely adopt the code of conduct of Django . This page will be updated soon.","title":"Contributing"},{"location":"about/release-notes/","text":"Release Notes \ud83d\udd17 v0.1.0 \ud83d\udd17 This is the first official version release of DFiant.","title":"Release Notes"},{"location":"about/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"about/release-notes/#v010","text":"This is the first official version release of DFiant.","title":"v0.1.0"},{"location":"getting-started/hello-dfiant-world/","text":"The Scala code in Fig. 1b describes a program that runs the DFiant compiler on an identity function dataflow design, ID . Since DFiant is a Scala library some if its compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. Writing a DFiant compilation program \u2013 easy as 1-2-3! import DFiant._ to import all the required namespace fields trait _design_name_ extends DFDesign {} to define your dataflow design. Populate your design with the required dataflow functionality. object _program_name_ extends DFApp . VHDLCompiler [ _ design_name_ ] to create your compilation program entry point.","title":"Index"},{"location":"getting-started/initial-setup/","text":"Initial Setup \ud83d\udd17","title":"Initial Setup"},{"location":"getting-started/initial-setup/#initial-setup","text":"","title":"Initial Setup"},{"location":"include/abbr/","text":"","title":"Abbr"},{"location":"intro/dataflow-abstraction/","text":"A Dataflow Hardware Description Abstraction \ud83d\udd17 How dataflow abstractions help decouple the functionality from its constraints? What dataflow HDL constructs are required to achieve maximum portable code? Fig.1: HDL abstraction layer summary (lowest=netlist, highest=dataflow) Each layer subsumes the capabilities of the layer below it. Dataflow constructs replace RTL registers with their true functionality (e.g., state) or insert them implicitly (e.g., pipelining) Fig. 1 summarizes the basic elements that make up HDLs at different abstraction layers, from a netlist up to the dataflow constructs presented in this paper. Each layer includes the expressive capabilities of the lowest layer (e.g., structural instance composition is possible in all HDLs). The layers are tagged with the relevant HDL names. Note that HLS languages and simulation constructs are not included in this summary. The basic notion of a dataflow abstraction is that instead of wires and registers we have dataflow token streams. This key difference between RTL and dataflow abstractions reveals why the former is coupled to device and timing constraints, while the latter is agnostic to them. Primarily, the RTL model requires designers to express what operations take place in each cycle, whereas the dataflow model only require the designer to order the operations based on their data dependencies . More specifically, the RTL model utilizes combinational operations that must complete (their propagation delay) within a given cycle if fed to a register, while the dataflow abstraction only assumes order and not on which cycle operations begin or complete. By decoupling operations from fixed clock cycles the dataflow model enables the compilation toolchain to map operations to cycles and thereby independently pipeline the design. Furthermore, the RTL model requires designers to use registers for a variety of uses and thus binds the design to specific timing conditions. Specifically, we find three main uses for registers in the RTL model: synchronous technology backend , synchronous technology interface , and design functionality (i.e., state). We now turn to discuss these different uses for registers and how the dataflow model can derive the first two uses without explicit user description. Synchronous Technology Backend Registers \ud83d\udd17 Registers are often required in a low-level design due to the underlying synchronous technology. Since they are unrelated to the functional requirement, a dataflow HDL can derive them automatically based on the functional requirements and design constraints. We differentiate between the following backend uses of registers: Pipelining and Path-Balancing \ud83d\udd17 Pipeline registers are inserted to split long combinational paths, and their placement is determined by designer-specified constraints, such as the maximum path cycle latency or the maximum propagation delay between registers. Pipelining increases the path cycle latency, and if the path converges with another path that requires no pipelining, then additional path-balancing registers are added to maintain correctness of the design. Because a balanced pipelining does not affect the design functionality, it can be automatically applied by the dataflow HDL compiler. Synchronizers \ud83d\udd17 Clock domain crossing (CDC) and asynchronous signals are exposed to metastability. Synchronizers, often composed of registers, are used to mitigate its effect and bring the design to the proper reliability. Since we wish to have a a clockless design frontend, we want the synchronizers to be implicit. A dataflow HDL compiler needs to infer synchronizers according to the design constraints without designer intervention. Note: our work currently focuses on single clock designs so the compiler we implemented does not yet support this feature. Synchronous Technology Interface Registers \ud83d\udd17 Functional design requirements are often accompanied by synchronous input/output (IO) timing constraints such as clocked protocol interfaces or real-time restrictions. However, these constraints only affect the interface and are unrelated to the design itself. To maximize design portability, we apply timed or legacy constructs solely in the periphery , while coding the design core with only clockless dataflow constructs. We differentiate between the following synchronous signaling: External IO and Blackbox Interfaces \ud83d\udd17 External IOs that are exposed to the top design hierarchy or blackboxes that are exposed to the internal design core may impose synchronous protocols (e.g., data is valid one clock cycle after address is set). A dataflow HDL supports legacy RTL constructs to synchronously interface external IOs and instantiate blackboxes. Timers \ud83d\udd17 Timers are design constructs for generating real-time signals or creating derivations of timed signal inputs. For example, a design using a 100MHz clock may drive a UART stream at 10Mbps or toggle a led at 1Hz. Rather than directly using registers as clock dividers or employing clock generation components (e.g., PLLs), one can create functional representation of their timed use-cases. A dataflow HDL has timer constructs that generate tokens at a given or derived rate. The compiler can take all clocks into consideration and generate the proper clock tree based on the available device resources and other design constraints. Design Functionality (State) Registers \ud83d\udd17 Functional registers, or state, are needed when a design must access (previous) values that are no longer available on an input signal (e.g., cumulative sum or a state-machine's state). RTL designs invoke registers (behaviorally) to store the state. But, registers not only store the state, but also enforce specific cycle latencies. Furthermore, typical RTL languages declare additional variables and place extra assignments just to save the state. A dataflow HDL overcomes all these issues by including a construct to reuse a token from the stream history. Additionally, a related construct should set a token history to be used at initialization time. We differentiate between two kinds of state: derived state , and feedback state . Derived State \ud83d\udd17 A derived state is a state whose current output value is independent of its previous and can thereby be deduced by the compiler. For example, checking if a dataflow stream value has changed requires reusing the previous token and comparing to the current token. Feedback State \ud83d\udd17 A feedback state is a state whose current output value is dependent on its previous state value. For example, the current cumulative sum value is dependent on the previous sum value. Therefore, a dataflow HDL requires not only to fetch previous token values, but also set the future state value. Addressable memory pools also hold feedback state (e.g., a processor register-file, memory blocks) and can be expressed as a large selectable state array or available dedicated memory components. The two kinds of state differ heavily in performance improvement when the design is pipelined. A derived state path can produce a token for every clock tick, and pipelining a combination operation to reduce its cycle time will also increase its throughput. In contrast, a feedback state path is circular and cannot be pipelined as-is. Feedback state causes bottlenecks in many systems. For instance, a RISC-V processor program counter (PC) register manifests as a feedback state. The processor pipeline can only be improved thanks to a speculative mechanism that predicts the next PC value to prefetch instructions (e.g., PC+4 for a branch-not-taken prediction). In case of a miss-prediction other mechanisms take place. Further work may expand on dataflow abstractions that solve such problems functionally.","title":"A Dataflow Hardware Description Abstraction"},{"location":"intro/dataflow-abstraction/#a-dataflow-hardware-description-abstraction","text":"How dataflow abstractions help decouple the functionality from its constraints? What dataflow HDL constructs are required to achieve maximum portable code? Fig.1: HDL abstraction layer summary (lowest=netlist, highest=dataflow) Each layer subsumes the capabilities of the layer below it. Dataflow constructs replace RTL registers with their true functionality (e.g., state) or insert them implicitly (e.g., pipelining) Fig. 1 summarizes the basic elements that make up HDLs at different abstraction layers, from a netlist up to the dataflow constructs presented in this paper. Each layer includes the expressive capabilities of the lowest layer (e.g., structural instance composition is possible in all HDLs). The layers are tagged with the relevant HDL names. Note that HLS languages and simulation constructs are not included in this summary. The basic notion of a dataflow abstraction is that instead of wires and registers we have dataflow token streams. This key difference between RTL and dataflow abstractions reveals why the former is coupled to device and timing constraints, while the latter is agnostic to them. Primarily, the RTL model requires designers to express what operations take place in each cycle, whereas the dataflow model only require the designer to order the operations based on their data dependencies . More specifically, the RTL model utilizes combinational operations that must complete (their propagation delay) within a given cycle if fed to a register, while the dataflow abstraction only assumes order and not on which cycle operations begin or complete. By decoupling operations from fixed clock cycles the dataflow model enables the compilation toolchain to map operations to cycles and thereby independently pipeline the design. Furthermore, the RTL model requires designers to use registers for a variety of uses and thus binds the design to specific timing conditions. Specifically, we find three main uses for registers in the RTL model: synchronous technology backend , synchronous technology interface , and design functionality (i.e., state). We now turn to discuss these different uses for registers and how the dataflow model can derive the first two uses without explicit user description.","title":"A Dataflow Hardware Description Abstraction"},{"location":"intro/dataflow-abstraction/#synchronous-technology-backend-registers","text":"Registers are often required in a low-level design due to the underlying synchronous technology. Since they are unrelated to the functional requirement, a dataflow HDL can derive them automatically based on the functional requirements and design constraints. We differentiate between the following backend uses of registers:","title":"Synchronous Technology Backend Registers"},{"location":"intro/dataflow-abstraction/#pipelining-and-path-balancing","text":"Pipeline registers are inserted to split long combinational paths, and their placement is determined by designer-specified constraints, such as the maximum path cycle latency or the maximum propagation delay between registers. Pipelining increases the path cycle latency, and if the path converges with another path that requires no pipelining, then additional path-balancing registers are added to maintain correctness of the design. Because a balanced pipelining does not affect the design functionality, it can be automatically applied by the dataflow HDL compiler.","title":"Pipelining and Path-Balancing"},{"location":"intro/dataflow-abstraction/#synchronizers","text":"Clock domain crossing (CDC) and asynchronous signals are exposed to metastability. Synchronizers, often composed of registers, are used to mitigate its effect and bring the design to the proper reliability. Since we wish to have a a clockless design frontend, we want the synchronizers to be implicit. A dataflow HDL compiler needs to infer synchronizers according to the design constraints without designer intervention. Note: our work currently focuses on single clock designs so the compiler we implemented does not yet support this feature.","title":"Synchronizers"},{"location":"intro/dataflow-abstraction/#synchronous-technology-interface-registers","text":"Functional design requirements are often accompanied by synchronous input/output (IO) timing constraints such as clocked protocol interfaces or real-time restrictions. However, these constraints only affect the interface and are unrelated to the design itself. To maximize design portability, we apply timed or legacy constructs solely in the periphery , while coding the design core with only clockless dataflow constructs. We differentiate between the following synchronous signaling:","title":"Synchronous Technology Interface Registers"},{"location":"intro/dataflow-abstraction/#external-io-and-blackbox-interfaces","text":"External IOs that are exposed to the top design hierarchy or blackboxes that are exposed to the internal design core may impose synchronous protocols (e.g., data is valid one clock cycle after address is set). A dataflow HDL supports legacy RTL constructs to synchronously interface external IOs and instantiate blackboxes.","title":"External IO and Blackbox Interfaces"},{"location":"intro/dataflow-abstraction/#timers","text":"Timers are design constructs for generating real-time signals or creating derivations of timed signal inputs. For example, a design using a 100MHz clock may drive a UART stream at 10Mbps or toggle a led at 1Hz. Rather than directly using registers as clock dividers or employing clock generation components (e.g., PLLs), one can create functional representation of their timed use-cases. A dataflow HDL has timer constructs that generate tokens at a given or derived rate. The compiler can take all clocks into consideration and generate the proper clock tree based on the available device resources and other design constraints.","title":"Timers"},{"location":"intro/dataflow-abstraction/#design-functionality-state-registers","text":"Functional registers, or state, are needed when a design must access (previous) values that are no longer available on an input signal (e.g., cumulative sum or a state-machine's state). RTL designs invoke registers (behaviorally) to store the state. But, registers not only store the state, but also enforce specific cycle latencies. Furthermore, typical RTL languages declare additional variables and place extra assignments just to save the state. A dataflow HDL overcomes all these issues by including a construct to reuse a token from the stream history. Additionally, a related construct should set a token history to be used at initialization time. We differentiate between two kinds of state: derived state , and feedback state .","title":"Design Functionality (State) Registers"},{"location":"intro/dataflow-abstraction/#derived-state","text":"A derived state is a state whose current output value is independent of its previous and can thereby be deduced by the compiler. For example, checking if a dataflow stream value has changed requires reusing the previous token and comparing to the current token.","title":"Derived State"},{"location":"intro/dataflow-abstraction/#feedback-state","text":"A feedback state is a state whose current output value is dependent on its previous state value. For example, the current cumulative sum value is dependent on the previous sum value. Therefore, a dataflow HDL requires not only to fetch previous token values, but also set the future state value. Addressable memory pools also hold feedback state (e.g., a processor register-file, memory blocks) and can be expressed as a large selectable state array or available dedicated memory components. The two kinds of state differ heavily in performance improvement when the design is pipelined. A derived state path can produce a token for every clock tick, and pipelining a combination operation to reduce its cycle time will also increase its throughput. In contrast, a feedback state path is circular and cannot be pipelined as-is. Feedback state causes bottlenecks in many systems. For instance, a RISC-V processor program counter (PC) register manifests as a feedback state. The processor pipeline can only be improved thanks to a speculative mechanism that predicts the next PC value to prefetch instructions (e.g., PC+4 for a branch-not-taken prediction). In case of a miss-prediction other mechanisms take place. Further work may expand on dataflow abstractions that solve such problems functionally.","title":"Feedback State"},{"location":"intro/first-look/","text":"DFiant: First Look \ud83d\udd17 Your first encounter with the DFiant syntax, semantics and language features In this section we provide simple examples to demonstrate various DFiant syntax, semantics and languages features. If you wish to understand how to run these examples yourself, please refer to the Getting Started chapter of this documentation. Main Feature Overview \ud83d\udd17 Concise and simple syntax Write portable code: Target and timing agnostic dataflow hardware description Strong bit-accurate type-safety Simplified port connections Automatic latency path balancing Automatic/manual pipelining Meta hardware description via rich Scala language constructs Basic Example: An Identity Function \ud83d\udd17 Let's begin with a basic example. The dataflow design ID has a signed 16-bit input port x and a signed 16-bit output port y . We implemented an identity function between the input and output, meaning that for an input series \\(x_k\\) the output series shall be \\(y_k=x_k\\) . Fig. 1a depicts a functional drawing of the design and Fig. 1b contains three tabs: the ID.scala DFiant compilation program code which implements ID and compiles it to VHDL (2008) and the generated VHDL files. Fig. 1a: Functional drawing of the dataflow design 'ID' with an input port 'x' and an output port 'y' ID.scala 1 2 3 4 5 6 7 import DFiant._ @df class ID extends DFDesign { //This our `ID` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer y := x //trivial direct input-to-output assignment } ID.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.ID_pkg. all ; entity ID is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end ID ; architecture ID_arch of ID is begin async_proc : process ( all ) begin y <= x ; end process ; end ID_arch ; ID_pkg.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; package ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector ; function to_sl ( b : boolean ) return std_logic ; function to_sl ( arg : std_logic_vector ) return std_logic ; function to_slv ( arg : std_logic ) return std_logic_vector ; function to_slv ( arg : unsigned ) return std_logic_vector ; function to_slv ( arg : signed ) return std_logic_vector ; function to_slv ( arg : boolean ) return std_logic_vector ; end package ID_pkg ; package body ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector is variable v_s : std_logic_vector ( s 'high downto s 'low ); begin for i in s 'high downto s 'low loop v_s ( i ) := s ( s 'high - i ); end loop ; return v_s ; end bit_reverse ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector is begin return to_slv ( resize ( unsigned ( arg ), size )); end resize ; function to_sl ( b : boolean ) return std_logic is begin if ( b ) then return '1' ; else return '0' ; end if ; end to_sl ; function to_sl ( arg : std_logic_vector ) return std_logic is begin return arg ( arg 'low ); end to_sl ; function to_slv ( arg : std_logic ) return std_logic_vector is begin if ( arg = '1' ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; function to_slv ( arg : unsigned ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : signed ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : boolean ) return std_logic_vector is begin if ( arg ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; end package body ID_pkg ; ID.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none `timescale 1 ns / 1 ps `include \"ID_defs.v\" module ID ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); always @( * ) begin y = x ; end endmodule ID_defs.v 1 2 3 `ifndef ID_DEFS_H `define ID_DEFS_H `endif Fig. 1b: A DFiant implementation of the identity function as a toplevel design and the generated VHDL/Verilog files The Scala code in Fig. 1b describes our ID design as a Scala class. To compile this further to RTL or simulate it we need to create a program that instantiates the class and invokes additional commands. See the getting started guide for further details. Defining a new dataflow design import DFiant._ once per source file. @df class _design_name_ extends DFDesign {} to define your dataflow design. Populate your design with the required dataflow functionality. ID.scala line-by-line breakdown Line 1 : This import statement summons all the DFiant classes, types and objects into the current scope. This is a must for every dataflow design source file. Lines 3-7 : The ID Scala class is extended from the DFDesign (abstract) class and therefore declares it as a dataflow design. In addition, we also need to annotate the class with the @df dataflow context annotation. This annotation provides an implicit context that is required for the DFiant compilation. In case this annotation is missing, you will get a missing context error. Note: currently in Scala 2.xx we populate a class within braces {} . For those of you who dislike braces, a braceless syntax is expected to be available in Scala 3, where DFiant will migrate to in the future. Lines 4-5 : Here we construct the input port x and output port y . Both were set as a 16-bit signed integer dataflow variable via the DFSInt(width) constructor, where width is any positive integer. DFiant also support various types such as DFBits , DFUInt , and DFBool . All these dataflow variable construction options and more are discussed later in this documentation. The syntax val _name_ = _dataflow_type_constructor_ <> _direction_ is used to construct a port and give it a named Scala reference. The Scala reference name will affect the name of this port when compiled to the required backend representation. Line 6 : The assignment operator := sets the dataflow output port to consume all input port tokens as they are. Generated RTL files observations The ID.vhdl/ID.v files are readable and maintain the names set in the DFiant design. The generated files follow various writing conventions such as lowercase keywords and proper code alignment. The ID_pkg.vhdl is a package file that is shared between all VHDL files generated by DFiant and contains common conversion functions that may be required. Additionally it may contain other definitions like enumeration types. Hierarchy and Connection Example \ud83d\udd17 One of the most qualifying characteristics of hardware design is the composition of modules/entities via hierarchies and IO port connections. DFiant is no exception and easily enables dataflow design compositions. Fig. 2a demonstrates such a composition that creates yet another identity function, but this time as a chained composition of two identity functions. The top-level design IDTop introduces two instances of ID we saw in the previous example and connects them accordingly. Fig. 2a: Functional drawing of the dataflow design 'IDTop' with an input port 'x' and an output port 'y' IDTop.scala 1 2 3 4 5 6 7 8 9 10 11 import DFiant._ @df class IDTop extends DFDesign { //This our `IDTop` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer val id1 = new ID //First instance of the `ID` design val id2 = new ID //Second instance of the `ID` design id1 . x <> x //Connecting parent input port to child input port id1 . y <> id2 . x //Connecting sibling instance ports id2 . y <> y //Connecting parent output port to child output port } IDTop.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.IDTop_pkg. all ; entity IDTop is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end IDTop ; architecture IDTop_arch of IDTop is signal id1_x : signed ( 15 downto 0 ); signal id1_y : signed ( 15 downto 0 ); signal id2_x : signed ( 15 downto 0 ); signal id2_y : signed ( 15 downto 0 ); begin id1 : entity work . ID ( ID_arch ) port map ( x => id1_x , y => id1_y ); id2 : entity work . ID ( ID_arch ) port map ( x => id2_x , y => id2_y ); async_proc : process ( all ) begin id1_x <= x ; id2_x <= id1_y ; y <= id2_y ; end process ; end IDTop_arch ; IDTop.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 `default_nettype none `timescale 1 ns / 1 ps `include \"IDTop_defs.v\" module IDTop ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); wire signed [ 15 : 0 ] id1_y ; wire signed [ 15 : 0 ] id2_y ; reg signed [ 15 : 0 ] id1_x ; reg signed [ 15 : 0 ] id2_x ; ID id1 ( . x ( id1_x ), . y ( id1_y ) ); ID id2 ( . x ( id2_x ), . y ( id2_y ) ); always @( * ) begin id1_x = x ; id2_x = id1_y ; y = id2_y ; end endmodule Fig. 2b: A DFiant implementation of IDTop as a toplevel design and the generated VHDL/Verilog files Finite Step (State) Machine (FSM) Example \ud83d\udd17 SeqDet.scala 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import DFiant._ @df class SeqDet extends DFDesign { val seqIn = DFBit <> IN val detOut = DFBit <> OUT @df def detStep ( out : Int , trueNS : => FSM , falseNS : => FSM ) : FSM = FSM { detOut := out ifdf ( seqIn ){ trueNS . goto () }. elsedf { falseNS . goto () } } val S0 : FSM = detStep ( 0 , S1 , S0 ) val S1 : FSM = detStep ( 0 , S1 , S10 ) val S10 : FSM = detStep ( 0 , S1 , S100 ) val S100 : FSM = detStep ( 0 , S1001 , S0 ) val S1001 : FSM = detStep ( 1 , S1 , S10 ) } SeqDet.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SeqDet_pkg. all ; entity SeqDet is port ( clk : in std_logic ; rst : in std_logic ; seqIn : in std_logic ; detOut : out std_logic ); end SeqDet ; architecture SeqDet_arch of SeqDet is type E_fsm_states is ( E_fsm_states_S0 , E_fsm_states_S1 , E_fsm_states_S10 , E_fsm_states_S100 , E_fsm_states_S1001 ); signal fsm_state_prev1 : E_fsm_states := E_fsm_states_S0 ; signal fsm_state_sig : E_fsm_states ; begin async_proc : process ( all ) variable fsm_state : E_fsm_states := E_fsm_states_S0 ; begin fsm_state := fsm_state_prev1 ; case fsm_state is when E_fsm_states_S0 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; when E_fsm_states_S10 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S100 ; end if ; when E_fsm_states_S100 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1001 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1001 => detOut <= '1' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; end case ; fsm_state_sig <= fsm_state ; end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then fsm_state_prev1 <= E_fsm_states_S0 ; elsif rising_edge ( clk ) then fsm_state_prev1 <= fsm_state_sig ; end if ; end process ; end SeqDet_arch ; SeqDet.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 `default_nettype none `timescale 1 ns / 1 ps `include \"SeqDet_defs.v\" module SeqDet ( input wire clk , input wire rst , input wire seqIn , output reg detOut ); reg [ 2 : 0 ] fsm_state = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_prev1 = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_sig ; `define E_fsm_states_S0 0 `define E_fsm_states_S1 1 `define E_fsm_states_S10 2 `define E_fsm_states_S100 3 `define E_fsm_states_S1001 4 always @( * ) begin fsm_state = fsm_state_prev1 ; case ( fsm_state ) `E_fsm_states_S0 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end `E_fsm_states_S10 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S100 ; end `E_fsm_states_S100 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1001 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1001 : begin detOut = 1 'b1 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end default : begin fsm_state = 3 ' b ??? ; detOut = 1 ' b ? ; end endcase fsm_state_sig = fsm_state ; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) fsm_state_prev1 <= `E_fsm_states_S0 ; else fsm_state_prev1 <= fsm_state_sig ; end endmodule Simple Moving Average \ud83d\udd17 In this simple moving average (SMA) example, the signed 16-bit input, \\(x\\) No feedback implementation \ud83d\udd17 \\[ y_k=\\left(x_k+x_{k-1}+x_{k-2}+x_{k-3}\\right)/4 \\] SMA.scala 1 2 3 4 5 6 7 8 import DFiant._ @df class SMA extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val sum = ( x +^ x . prev ) +^ ( x . prev ( 2 ) +^ x . prev ( 3 )) y := ( sum >> 2 ). resize ( 16 ) } SMA.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_pkg. all ; entity SMA is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA ; architecture SMA_arch of SMA is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); begin async_proc : process ( all ) variable sum : signed ( 17 downto 0 ) := 18 d \"0\" ; begin sum := resize ( resize ( x , 17 ) + x_prev1 , 18 ) + ( resize ( x_prev2 , 17 ) + x_prev3 ); x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; y <= resize ( sum sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end if ; end process ; end SMA_arch ; SMA.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_defs.v\" module SMA ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 16 : 0 ] sum_part = 17 ' sd0 ; reg signed [ 17 : 0 ] sum = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; always @( * ) begin sum_part = ({ x [ 15 ], x [ 15 : 0 ]}) + x_prev1 ; sum = ({ sum_part [ 16 ], sum_part [ 16 : 0 ]}) + (({ x_prev2 [ 15 ], x_prev2 [ 15 : 0 ]}) + x_prev3 ); y_part = sum >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end end endmodule Feedback implementation \ud83d\udd17 \\[\\begin{eqnarray} a_0 &=& 0 \\\\ a_k &=& a_{k-1} - x_{k-4}+x_k \\\\ y_k &=& a_k/4 \\end{eqnarray}\\] SMA_FB.scala 1 2 3 4 5 6 7 8 9 import DFiant._ @df class SMA_FB extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val acc = DFSInt ( 18 ) <> VAR init 0 acc := acc - x . prev ( 4 ) + x y := ( acc >> 2 ). resize ( 16 ) } SMA_FB.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_FB_pkg. all ; entity SMA_FB is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA_FB ; architecture SMA_FB_arch of SMA_FB is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev4 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal acc_prev1 : signed ( 17 downto 0 ) := 18 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); signal x_prev3_sig : signed ( 15 downto 0 ); signal acc_sig : signed ( 17 downto 0 ); begin async_proc : process ( all ) variable acc : signed ( 17 downto 0 ) := 18 d \"0\" ; begin acc := acc_prev1 ; acc := ( acc - x_prev4 ) + x ; x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; x_prev3_sig <= x_prev3 ; acc_sig <= acc ; y <= resize ( acc sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; x_prev4 <= 16 d \"0\" ; acc_prev1 <= 18 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end if ; end process ; end SMA_FB_arch ; SMA_FB.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_FB_defs.v\" module SMA_FB ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev4 = 16 ' sd0 ; reg signed [ 17 : 0 ] acc = 18 ' sd0 ; reg signed [ 17 : 0 ] acc_prev1 = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; reg signed [ 15 : 0 ] x_prev3_sig ; reg signed [ 17 : 0 ] acc_sig ; always @( * ) begin acc = acc_prev1 ; acc = ( acc - x_prev4 ) + x ; y_part = acc >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; x_prev3_sig = x_prev3 ; acc_sig = acc ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; x_prev4 <= 16 ' sd0 ; acc_prev1 <= 18 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end end endmodule Looks cool! I wish to know more \ud83d\udd17","title":"DFiant: First Look"},{"location":"intro/first-look/#dfiant-first-look","text":"Your first encounter with the DFiant syntax, semantics and language features In this section we provide simple examples to demonstrate various DFiant syntax, semantics and languages features. If you wish to understand how to run these examples yourself, please refer to the Getting Started chapter of this documentation.","title":"DFiant: First Look"},{"location":"intro/first-look/#main-feature-overview","text":"Concise and simple syntax Write portable code: Target and timing agnostic dataflow hardware description Strong bit-accurate type-safety Simplified port connections Automatic latency path balancing Automatic/manual pipelining Meta hardware description via rich Scala language constructs","title":"Main Feature Overview"},{"location":"intro/first-look/#basic-example-an-identity-function","text":"Let's begin with a basic example. The dataflow design ID has a signed 16-bit input port x and a signed 16-bit output port y . We implemented an identity function between the input and output, meaning that for an input series \\(x_k\\) the output series shall be \\(y_k=x_k\\) . Fig. 1a depicts a functional drawing of the design and Fig. 1b contains three tabs: the ID.scala DFiant compilation program code which implements ID and compiles it to VHDL (2008) and the generated VHDL files. Fig. 1a: Functional drawing of the dataflow design 'ID' with an input port 'x' and an output port 'y' ID.scala 1 2 3 4 5 6 7 import DFiant._ @df class ID extends DFDesign { //This our `ID` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer y := x //trivial direct input-to-output assignment } ID.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.ID_pkg. all ; entity ID is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end ID ; architecture ID_arch of ID is begin async_proc : process ( all ) begin y <= x ; end process ; end ID_arch ; ID_pkg.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; package ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector ; function to_sl ( b : boolean ) return std_logic ; function to_sl ( arg : std_logic_vector ) return std_logic ; function to_slv ( arg : std_logic ) return std_logic_vector ; function to_slv ( arg : unsigned ) return std_logic_vector ; function to_slv ( arg : signed ) return std_logic_vector ; function to_slv ( arg : boolean ) return std_logic_vector ; end package ID_pkg ; package body ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector is variable v_s : std_logic_vector ( s 'high downto s 'low ); begin for i in s 'high downto s 'low loop v_s ( i ) := s ( s 'high - i ); end loop ; return v_s ; end bit_reverse ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector is begin return to_slv ( resize ( unsigned ( arg ), size )); end resize ; function to_sl ( b : boolean ) return std_logic is begin if ( b ) then return '1' ; else return '0' ; end if ; end to_sl ; function to_sl ( arg : std_logic_vector ) return std_logic is begin return arg ( arg 'low ); end to_sl ; function to_slv ( arg : std_logic ) return std_logic_vector is begin if ( arg = '1' ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; function to_slv ( arg : unsigned ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : signed ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : boolean ) return std_logic_vector is begin if ( arg ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; end package body ID_pkg ; ID.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none `timescale 1 ns / 1 ps `include \"ID_defs.v\" module ID ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); always @( * ) begin y = x ; end endmodule ID_defs.v 1 2 3 `ifndef ID_DEFS_H `define ID_DEFS_H `endif Fig. 1b: A DFiant implementation of the identity function as a toplevel design and the generated VHDL/Verilog files The Scala code in Fig. 1b describes our ID design as a Scala class. To compile this further to RTL or simulate it we need to create a program that instantiates the class and invokes additional commands. See the getting started guide for further details. Defining a new dataflow design import DFiant._ once per source file. @df class _design_name_ extends DFDesign {} to define your dataflow design. Populate your design with the required dataflow functionality. ID.scala line-by-line breakdown Line 1 : This import statement summons all the DFiant classes, types and objects into the current scope. This is a must for every dataflow design source file. Lines 3-7 : The ID Scala class is extended from the DFDesign (abstract) class and therefore declares it as a dataflow design. In addition, we also need to annotate the class with the @df dataflow context annotation. This annotation provides an implicit context that is required for the DFiant compilation. In case this annotation is missing, you will get a missing context error. Note: currently in Scala 2.xx we populate a class within braces {} . For those of you who dislike braces, a braceless syntax is expected to be available in Scala 3, where DFiant will migrate to in the future. Lines 4-5 : Here we construct the input port x and output port y . Both were set as a 16-bit signed integer dataflow variable via the DFSInt(width) constructor, where width is any positive integer. DFiant also support various types such as DFBits , DFUInt , and DFBool . All these dataflow variable construction options and more are discussed later in this documentation. The syntax val _name_ = _dataflow_type_constructor_ <> _direction_ is used to construct a port and give it a named Scala reference. The Scala reference name will affect the name of this port when compiled to the required backend representation. Line 6 : The assignment operator := sets the dataflow output port to consume all input port tokens as they are. Generated RTL files observations The ID.vhdl/ID.v files are readable and maintain the names set in the DFiant design. The generated files follow various writing conventions such as lowercase keywords and proper code alignment. The ID_pkg.vhdl is a package file that is shared between all VHDL files generated by DFiant and contains common conversion functions that may be required. Additionally it may contain other definitions like enumeration types.","title":"Basic Example: An Identity Function"},{"location":"intro/first-look/#hierarchy-and-connection-example","text":"One of the most qualifying characteristics of hardware design is the composition of modules/entities via hierarchies and IO port connections. DFiant is no exception and easily enables dataflow design compositions. Fig. 2a demonstrates such a composition that creates yet another identity function, but this time as a chained composition of two identity functions. The top-level design IDTop introduces two instances of ID we saw in the previous example and connects them accordingly. Fig. 2a: Functional drawing of the dataflow design 'IDTop' with an input port 'x' and an output port 'y' IDTop.scala 1 2 3 4 5 6 7 8 9 10 11 import DFiant._ @df class IDTop extends DFDesign { //This our `IDTop` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer val id1 = new ID //First instance of the `ID` design val id2 = new ID //Second instance of the `ID` design id1 . x <> x //Connecting parent input port to child input port id1 . y <> id2 . x //Connecting sibling instance ports id2 . y <> y //Connecting parent output port to child output port } IDTop.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.IDTop_pkg. all ; entity IDTop is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end IDTop ; architecture IDTop_arch of IDTop is signal id1_x : signed ( 15 downto 0 ); signal id1_y : signed ( 15 downto 0 ); signal id2_x : signed ( 15 downto 0 ); signal id2_y : signed ( 15 downto 0 ); begin id1 : entity work . ID ( ID_arch ) port map ( x => id1_x , y => id1_y ); id2 : entity work . ID ( ID_arch ) port map ( x => id2_x , y => id2_y ); async_proc : process ( all ) begin id1_x <= x ; id2_x <= id1_y ; y <= id2_y ; end process ; end IDTop_arch ; IDTop.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 `default_nettype none `timescale 1 ns / 1 ps `include \"IDTop_defs.v\" module IDTop ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); wire signed [ 15 : 0 ] id1_y ; wire signed [ 15 : 0 ] id2_y ; reg signed [ 15 : 0 ] id1_x ; reg signed [ 15 : 0 ] id2_x ; ID id1 ( . x ( id1_x ), . y ( id1_y ) ); ID id2 ( . x ( id2_x ), . y ( id2_y ) ); always @( * ) begin id1_x = x ; id2_x = id1_y ; y = id2_y ; end endmodule Fig. 2b: A DFiant implementation of IDTop as a toplevel design and the generated VHDL/Verilog files","title":"Hierarchy and Connection Example"},{"location":"intro/first-look/#finite-step-state-machine-fsm-example","text":"SeqDet.scala 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import DFiant._ @df class SeqDet extends DFDesign { val seqIn = DFBit <> IN val detOut = DFBit <> OUT @df def detStep ( out : Int , trueNS : => FSM , falseNS : => FSM ) : FSM = FSM { detOut := out ifdf ( seqIn ){ trueNS . goto () }. elsedf { falseNS . goto () } } val S0 : FSM = detStep ( 0 , S1 , S0 ) val S1 : FSM = detStep ( 0 , S1 , S10 ) val S10 : FSM = detStep ( 0 , S1 , S100 ) val S100 : FSM = detStep ( 0 , S1001 , S0 ) val S1001 : FSM = detStep ( 1 , S1 , S10 ) } SeqDet.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SeqDet_pkg. all ; entity SeqDet is port ( clk : in std_logic ; rst : in std_logic ; seqIn : in std_logic ; detOut : out std_logic ); end SeqDet ; architecture SeqDet_arch of SeqDet is type E_fsm_states is ( E_fsm_states_S0 , E_fsm_states_S1 , E_fsm_states_S10 , E_fsm_states_S100 , E_fsm_states_S1001 ); signal fsm_state_prev1 : E_fsm_states := E_fsm_states_S0 ; signal fsm_state_sig : E_fsm_states ; begin async_proc : process ( all ) variable fsm_state : E_fsm_states := E_fsm_states_S0 ; begin fsm_state := fsm_state_prev1 ; case fsm_state is when E_fsm_states_S0 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; when E_fsm_states_S10 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S100 ; end if ; when E_fsm_states_S100 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1001 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1001 => detOut <= '1' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; end case ; fsm_state_sig <= fsm_state ; end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then fsm_state_prev1 <= E_fsm_states_S0 ; elsif rising_edge ( clk ) then fsm_state_prev1 <= fsm_state_sig ; end if ; end process ; end SeqDet_arch ; SeqDet.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 `default_nettype none `timescale 1 ns / 1 ps `include \"SeqDet_defs.v\" module SeqDet ( input wire clk , input wire rst , input wire seqIn , output reg detOut ); reg [ 2 : 0 ] fsm_state = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_prev1 = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_sig ; `define E_fsm_states_S0 0 `define E_fsm_states_S1 1 `define E_fsm_states_S10 2 `define E_fsm_states_S100 3 `define E_fsm_states_S1001 4 always @( * ) begin fsm_state = fsm_state_prev1 ; case ( fsm_state ) `E_fsm_states_S0 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end `E_fsm_states_S10 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S100 ; end `E_fsm_states_S100 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1001 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1001 : begin detOut = 1 'b1 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end default : begin fsm_state = 3 ' b ??? ; detOut = 1 ' b ? ; end endcase fsm_state_sig = fsm_state ; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) fsm_state_prev1 <= `E_fsm_states_S0 ; else fsm_state_prev1 <= fsm_state_sig ; end endmodule","title":"Finite Step (State) Machine (FSM) Example"},{"location":"intro/first-look/#simple-moving-average","text":"In this simple moving average (SMA) example, the signed 16-bit input, \\(x\\)","title":"Simple Moving Average"},{"location":"intro/first-look/#no-feedback-implementation","text":"\\[ y_k=\\left(x_k+x_{k-1}+x_{k-2}+x_{k-3}\\right)/4 \\] SMA.scala 1 2 3 4 5 6 7 8 import DFiant._ @df class SMA extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val sum = ( x +^ x . prev ) +^ ( x . prev ( 2 ) +^ x . prev ( 3 )) y := ( sum >> 2 ). resize ( 16 ) } SMA.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_pkg. all ; entity SMA is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA ; architecture SMA_arch of SMA is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); begin async_proc : process ( all ) variable sum : signed ( 17 downto 0 ) := 18 d \"0\" ; begin sum := resize ( resize ( x , 17 ) + x_prev1 , 18 ) + ( resize ( x_prev2 , 17 ) + x_prev3 ); x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; y <= resize ( sum sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end if ; end process ; end SMA_arch ; SMA.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_defs.v\" module SMA ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 16 : 0 ] sum_part = 17 ' sd0 ; reg signed [ 17 : 0 ] sum = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; always @( * ) begin sum_part = ({ x [ 15 ], x [ 15 : 0 ]}) + x_prev1 ; sum = ({ sum_part [ 16 ], sum_part [ 16 : 0 ]}) + (({ x_prev2 [ 15 ], x_prev2 [ 15 : 0 ]}) + x_prev3 ); y_part = sum >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end end endmodule","title":"No feedback implementation"},{"location":"intro/first-look/#feedback-implementation","text":"\\[\\begin{eqnarray} a_0 &=& 0 \\\\ a_k &=& a_{k-1} - x_{k-4}+x_k \\\\ y_k &=& a_k/4 \\end{eqnarray}\\] SMA_FB.scala 1 2 3 4 5 6 7 8 9 import DFiant._ @df class SMA_FB extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val acc = DFSInt ( 18 ) <> VAR init 0 acc := acc - x . prev ( 4 ) + x y := ( acc >> 2 ). resize ( 16 ) } SMA_FB.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_FB_pkg. all ; entity SMA_FB is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA_FB ; architecture SMA_FB_arch of SMA_FB is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev4 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal acc_prev1 : signed ( 17 downto 0 ) := 18 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); signal x_prev3_sig : signed ( 15 downto 0 ); signal acc_sig : signed ( 17 downto 0 ); begin async_proc : process ( all ) variable acc : signed ( 17 downto 0 ) := 18 d \"0\" ; begin acc := acc_prev1 ; acc := ( acc - x_prev4 ) + x ; x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; x_prev3_sig <= x_prev3 ; acc_sig <= acc ; y <= resize ( acc sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; x_prev4 <= 16 d \"0\" ; acc_prev1 <= 18 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end if ; end process ; end SMA_FB_arch ; SMA_FB.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_FB_defs.v\" module SMA_FB ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev4 = 16 ' sd0 ; reg signed [ 17 : 0 ] acc = 18 ' sd0 ; reg signed [ 17 : 0 ] acc_prev1 = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; reg signed [ 15 : 0 ] x_prev3_sig ; reg signed [ 17 : 0 ] acc_sig ; always @( * ) begin acc = acc_prev1 ; acc = ( acc - x_prev4 ) + x ; y_part = acc >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; x_prev3_sig = x_prev3 ; acc_sig = acc ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; x_prev4 <= 16 ' sd0 ; acc_prev1 <= 18 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end end endmodule","title":"Feedback implementation"},{"location":"intro/first-look/#looks-cool-i-wish-to-know-more","text":"","title":"Looks cool! I wish to know more"},{"location":"intro/motivation/","text":"Motivation \ud83d\udd17 Why do we need yet another HDL? Why high-level synthesis is not enough? The register-transfer level (RTL) programming model paved the road for Verilog and VHDL to flourish as the leading hardware description languages (HDLs). That road, however, is steadily nearing its end as both hardware designs and devices become increasingly more complex. While the software world is striving for a \"write once, run anywhere\" programmability, the complexity of an RTL design implementing a given functionality may vary greatly across different FPGA and ASIC devices that incorporate various technologies and core components. Moreover, minor requirement changes may lead to significant redesigns, since RTL abstraction tightly couples functionality with timing constraints. For example, registers serve various roles such as preserving a state, pipelining and balancing a data path, deriving timed signals from an input clock, and synchronizing an input signal. This coupling between functionality, timing constraints, and device constraints leads to verbose and unportable RTL designs. Ongoing efforts to bridge this hardware programmability gap [1] , [2] , [3] can be largely split into two classes: high-level synthesis (HLS) tools and high-level RTL (HL-RTL) languages. On the one hand, HLS tools (such as Vivado [4] , Catapult [5] , and others [6] , [7] ) rely on programming languages like C and incorporate auto-pipelining and optimization mechanisms to make hardware accelerators accessible for non-hardware engineers. While this approach is successful in algorithmic acceleration domains, such languages carry von Neumann sequential semantics and thus hinder construction of parallel hardware, which is crucial for hardware design [8] . Moreover, some trivial periodic hardware operations (like toggling a LED) are unbearably difficult to implement in HLS languages. On the other hand, HL-RTL languages (such as Chisel [9] , Bluespec [10] , PyRTL [11] , and others [12] , [13] , [14] , [15] , [16] , [17] ) aim to enhance productivity by introducing new hardware generation constructs and semantics but do not abstract away register-level description (even Bluespec, which uses concurrent guarded atomic actions, assumes rules complete within a single clock cycle). Therefore, HL-RTL designs are still subjected to the \" tyranny of the clock \" [18] and are bound to specific timing and target constraints. Fig.1: DFiant bridges the gap between RTL and HLS languages In this work we introduce dataflow-based HDL constructs that abstract away registers and clocks. We also introduce DFiant, a Scala-embedded HDL that utilizes these dataflow constructs to decouple functionality from implementation constraints. DFiant brings together constructs and semantics from dataflow [19] , [20] , [21] , [22] , hardware, and software programming languages to enable truly portable and composable hardware designs. The dataflow model offers implicit concurrency between independent paths while freeing the designer from explicit register placement that binds the design to fixed pipelined paths and timing constraints. Recent related dataflow-for-hardware efforts are the Maxeler framework [23] and its MaxJ Java-based programming language, the OpenDF framework [24] which is based on the CAL actor language [25] , and CAPH [26] . MaxJ indeed shares common traits with DFiant, but it is tailored for its target hardware framework and is not designed to be a general purpose HDL. Both OpenDF and CAPH share similar goals with our work, but they use actors and networks to describe hardware, which is completely different than a conventional HDL composition based on component instances and port connections. This work focuses on applying dataflow principles through the DFiant language and compiler. DFiant is not an HLS language, nor is it an RTL language. Instead, DFiant is an HDL that provides abstractions beyond the RTL behavioral model, which reduce verbosity and maintain portable code. Since DFiant is implemented as a Scala library, it offers a rich type safe ecosystem alongside its own hardware-focused type system (e.g., bit-accurate dataflow types, input/output port types). The library performs two main tasks: first, the frontend compilation, which enforces the type-safe rule-system and constructs a dataflow dependency graph; and second, the backend compilation, which translates the graph into a pipelined RTL code and a TCL constraints file. The resulting code can be synthesized using commercial tools.","title":"Motivation (Why Another HDL)"},{"location":"intro/motivation/#motivation","text":"Why do we need yet another HDL? Why high-level synthesis is not enough? The register-transfer level (RTL) programming model paved the road for Verilog and VHDL to flourish as the leading hardware description languages (HDLs). That road, however, is steadily nearing its end as both hardware designs and devices become increasingly more complex. While the software world is striving for a \"write once, run anywhere\" programmability, the complexity of an RTL design implementing a given functionality may vary greatly across different FPGA and ASIC devices that incorporate various technologies and core components. Moreover, minor requirement changes may lead to significant redesigns, since RTL abstraction tightly couples functionality with timing constraints. For example, registers serve various roles such as preserving a state, pipelining and balancing a data path, deriving timed signals from an input clock, and synchronizing an input signal. This coupling between functionality, timing constraints, and device constraints leads to verbose and unportable RTL designs. Ongoing efforts to bridge this hardware programmability gap [1] , [2] , [3] can be largely split into two classes: high-level synthesis (HLS) tools and high-level RTL (HL-RTL) languages. On the one hand, HLS tools (such as Vivado [4] , Catapult [5] , and others [6] , [7] ) rely on programming languages like C and incorporate auto-pipelining and optimization mechanisms to make hardware accelerators accessible for non-hardware engineers. While this approach is successful in algorithmic acceleration domains, such languages carry von Neumann sequential semantics and thus hinder construction of parallel hardware, which is crucial for hardware design [8] . Moreover, some trivial periodic hardware operations (like toggling a LED) are unbearably difficult to implement in HLS languages. On the other hand, HL-RTL languages (such as Chisel [9] , Bluespec [10] , PyRTL [11] , and others [12] , [13] , [14] , [15] , [16] , [17] ) aim to enhance productivity by introducing new hardware generation constructs and semantics but do not abstract away register-level description (even Bluespec, which uses concurrent guarded atomic actions, assumes rules complete within a single clock cycle). Therefore, HL-RTL designs are still subjected to the \" tyranny of the clock \" [18] and are bound to specific timing and target constraints. Fig.1: DFiant bridges the gap between RTL and HLS languages In this work we introduce dataflow-based HDL constructs that abstract away registers and clocks. We also introduce DFiant, a Scala-embedded HDL that utilizes these dataflow constructs to decouple functionality from implementation constraints. DFiant brings together constructs and semantics from dataflow [19] , [20] , [21] , [22] , hardware, and software programming languages to enable truly portable and composable hardware designs. The dataflow model offers implicit concurrency between independent paths while freeing the designer from explicit register placement that binds the design to fixed pipelined paths and timing constraints. Recent related dataflow-for-hardware efforts are the Maxeler framework [23] and its MaxJ Java-based programming language, the OpenDF framework [24] which is based on the CAL actor language [25] , and CAPH [26] . MaxJ indeed shares common traits with DFiant, but it is tailored for its target hardware framework and is not designed to be a general purpose HDL. Both OpenDF and CAPH share similar goals with our work, but they use actors and networks to describe hardware, which is completely different than a conventional HDL composition based on component instances and port connections. This work focuses on applying dataflow principles through the DFiant language and compiler. DFiant is not an HLS language, nor is it an RTL language. Instead, DFiant is an HDL that provides abstractions beyond the RTL behavioral model, which reduce verbosity and maintain portable code. Since DFiant is implemented as a Scala library, it offers a rich type safe ecosystem alongside its own hardware-focused type system (e.g., bit-accurate dataflow types, input/output port types). The library performs two main tasks: first, the frontend compilation, which enforces the type-safe rule-system and constructs a dataflow dependency graph; and second, the backend compilation, which translates the graph into a pipelined RTL code and a TCL constraints file. The resulting code can be synthesized using commercial tools.","title":"Motivation"},{"location":"user-guide/compilation/","text":"Compilation \ud83d\udd17","title":"Compilation"},{"location":"user-guide/compilation/#compilation","text":"","title":"Compilation"},{"location":"user-guide/connectivity/","text":"Dataflow Ports & Connectivity \ud83d\udd17 Legend \ud83d\udd17 Shape Meaning or A dataflow design A dataflow port. Arrow enters a dataflow design shape = INPUT port Arrow exists a dataflow design shape = OUTPUT port A dataflow variable (mutable) A constant (immutable literal). In this case, the value is 5. A dataflow join calculation junction (immutable). In this case, the calculation is the addition + arithmetic operation. A dataflow state element, via .prev(rank) (immutable). In this case, the rank is 3. A single-line arrow indicates a dataflow dependency assignment from a producer (arrow tail) to a consumer (arrow head) A double-line diamond arrow indicates a dataflow dependency connection from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency A double-line arrow indicates a dataflow dependency reference from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency Table of Contents \ud83d\udd17 Dataflow Ports & Connectivity Legend Table of Contents Key Differences Between <> and := Connection <> Rules Dataflow Port Connections Dataflow Value Connections Dataflow Input Port Assignment := Rule Immutable Value Connections Different Type Connections Multiple Connections Mixing Assignments and Connections Connection Statement Order Connection and Initial Conditions Open (Unconnected) Ports Initial Condition Cyclic Loop Errors Valid Connection and Assignment Examples Future Work Key Differences Between <> and := \ud83d\udd17 Criteria <> Connection := Assignment Code Functional Diagram We use a double line arrow to indicate a dataflow dependency with an initial condition dependency. We use a single line arrow to indicate a dataflow dependency without affecting initial conditions of the consumer. Directionality & Commutativity The operator is commutative, meaning a <> b is equivalent to b b <> a . One argument is the producer , while the other consumer . The dataflow direction is sensitive to the context in which the operator is applied. The operator is non-commutative, meaning a := b determines that b is the producer , transferring data to the consumer a . Initialization Initialization is transferred to the consumer. The consumer initialization is not affected. Mutation A consumer can only be connected once. Consumer assignments are unlimited. Statement Order Connections statements can be placed in any order. Assignment statements Connection <> Rules \ud83d\udd17 Dataflow Port Connections \ud83d\udd17 Connections annotation is generally used to connect parent designs to their child designs (components) and connect between sibling designs (children of the same parent). Opposed to VHDL/Verilog, there is no need to go through 'signals' to connect sibling design ports, e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 trait IODesign extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i } trait Container2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io1 = new IODesign {} val io2 = new IODesign {} i <> io1 . i //Connecting between owner input and child input io1 . o <> io2 . i //Connecting between siblings (output <> input) io2 . o <> o //Connecting between child output and owner output } Dataflow Value Connections \ud83d\udd17 At least one of the connected sides must be a dataflow port (cannot connect two dataflow values together), e.g.: 1 2 3 4 5 6 7 trait Conn1 { val port = DFUInt ( 8 ) <> OUT val temp1 = DFUInt ( 8 ) val temp2 = DFUInt ( 8 ) port <> temp1 //OK! temp1 <> temp2 //Bad connection! At least one connection side must be a port } Dataflow Input Port Assignment := Rule \ud83d\udd17 An input port cannot be assigned to. A connection must be used to transfer data to an input port, e.g.: 1 2 3 4 5 6 7 8 9 10 11 trait IO extends DFDesign { val in = DFUInt ( 8 ) <> IN val out = DFUInt ( 8 ) <> OUT out := in //OK! Can assign internally to an output port } trait Assign1 extends DFDesign { val io = new IO {} io . in := 1 //Bad assignment! Must use a connection annotation io . in <> 1 //OK! io . out := 1 //Bad assignment! Output ports can only be assigned internally } Immutable Value Connections \ud83d\udd17 When connecting a port to an immutable value, the port must be a consumer, meaning the connection is done internally to an output port or externally to an input port, e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 trait IO extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT //For brevity, we consider every connection/assignment in this example separately. //We ignore multiple connection issues that should arise. o <> 1 //OK! i <> 1 //Bad connection! 1 is immutable (constant) i <> o . prev //Bad connection! o.prev is immutable i . prev <> o //OK! } trait IOUser extends DFDesign { val io = new IO {} io . i <> 1 //OK! io . o <> 1 //Bad connection! 1 is immutable } Different Type Connections \ud83d\udd17 Connecting between different types is possible, but depends on the specific type: if it enables automatic conversion for the connection to succeed. Different port widths are considered different types and casting is required. An alias/casted/converted dataflow value is considered immutable for the connection (see above). Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 trait DifferentTypesConn extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val ob9 = DFBits ( 9 ) <> OUT val u7 = DFUInt ( 7 ) val u9 = DFUInt ( 9 ) val b8 = DFBits ( 8 ) //For brevity, we consider every connection/assignment in this example separately. //We ignore multiple connection issues that should arise. u7 <> o //OK! u7 is automatically extended to connect to u7 <> i //Bad connection! u7 is considered immutable when extended to 8 bits o <> b8 //Bad connection! There is not automatic casting between bits and uint o <> b8 . uint //OK! o . bits <> b8 //Bad connection! An alias of output port cannot be connected to //This may change in the future. o . bits := b8 //OK! u9 <> i //OK! In this example u9 is the consumer ob9 <> b8 //Bad connection! Bit vectors are NOT automatically extended. ob9 := b8 //Bad assignment! Bit vectors are NOT automatically extended. } Multiple Connections \ud83d\udd17 Two or more dataflow producers cannot be connected to the same consumer (a single producer can be connected to more than one consumer), e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 trait Gen extends DFDesign { val out1 = DFUInt ( 8 ) <> OUT init 1 val out2 = DFUInt ( 8 ) <> OUT init 2 } trait Conn2 extends DFDesign { val in1 = DFUInt ( 8 ) <> IN val in2 = DFUInt ( 8 ) <> IN val out = DFUInt ( 8 ) <> OUT val temp1 = DFUInt ( 8 ) temp1 <> in1 //OK! out <> in1 //Also OK! (Same producer can connect to more than one cosumer) temp1 <> in2 //Bad connection! Second producer connection to temp1 val gen = new Gen {} val temp2 = DFUInt ( 8 ) val temp3 = DFUInt ( 8 ) gen . out1 <> temp2 //OK! gen . out1 <> temp3 //Also OK! (Same producer can connect to more than one cosumer) gen . out2 <> temp2 //Bad connection! Second producer connection to temp2 } Mixing Assignments and Connections \ud83d\udd17 The same consumer cannot be both assigned to and connected to as the consumer, e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 trait Conn3 extends DFDesign { val out1 = DFUInt ( 8 ) <> OUT val out2 = DFUInt ( 8 ) <> OUT val out3 = DFUInt ( 8 ) <> OUT out1 <> 1 //OK! out1 := 1 //Bad assignment! Cannot assign to a connected dataflow variable out2 := 2 //OK! out2 <> 2 //Bad connection! Cannot connect to an assigned dataflow variable out3 := 1 //OK! out3 := 2 //Also OK! (Multiple assignments are accepted) } Connection Statement Order \ud83d\udd17 The connection <> statement ordering does not matter. Connection and Initial Conditions \ud83d\udd17 A connection <> transfers initial conditions to the consumer, but if the consumer is already initialized then the consumer keeps its existing initial conditions. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 trait IOInit extends DFDesign { val i = DFUInt ( 8 ) //init = (11, 12) Overriden from TopInit connection val o = DFUInt ( 8 ) init 5 //init = (5) Not overridden due to assignment val ip = i . prev //init = (12) Prev moves down the init queue o := ip } trait TopInit extends DFDesign { val i = DFUInt ( 8 ) <> IN . init ( 1 , 2 ) //init = (1, 2) The top-level initial conditions val o = DFUInt ( 8 ) <> OUT init 1 //init = (1) Keeps its initializaion val iPlus10 = in + 10 //init = (11, 12) Arithmetics affect init val io = new IOInit {} io . i <> inPlus10 o <> io . o } We learn from the above that port initial conditions are often overridden due to connections. So why should we apply initial conditions to a port? Answer: If we want to define what happens when a port is open (unconnected). Read the next two sections for more information. Open (Unconnected) Ports \ud83d\udd17 Ports have two connection sides: a consumer side and a producer side. Typically ports have both sides connected, except for top-level ports. When either port side is unconnected, we refer to it as open , and expect the following behavior: When the port consumer side is open, the port produces tokens according to its initial condition. Uninitialized open-consumer ports generate bubble tokens. When the port producer side is open (unless it is a top-level output port), the port is considered as not used, and is pruned during compilation. All dataflow streams that are only used by this port will be pruned as well. Note : the current compiler implementation does not warn of open ports. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 trait IOInit2 extends DFDesign { val i1 = DFUInt ( 8 ) <> IN init 5 val o1 = DFUInt ( 8 ) <> OUT val i2 = DFUInt ( 8 ) <> IN val o2 = DFUInt ( 8 ) <> OUT init 2 o1 <> i1 } trait TopIO2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT //Will generate infinite tokens of 2, due to io.o2 init val io = new IO5 {} o <> io . o2 i <> io . i1 io . i2 <> 5 } Initial Condition Cyclic Loop Errors \ud83d\udd17 Connections enable dataflow feedbacks and even dataflow dependency loops. There is no problem in dependency loops, other than pipelining limitations (see chapter TBD for more information). However, if we only apply connections and references that transfer initial conditions, we end up with a cyclic dependency for initial condition which is illegal. Therefore to enable dependency loops, at least one link in the loop must be an assignment, which has an implicit state and does not affect initial conditions. Consider the following examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 trait IO1 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i //Connection transfers initial conditions from i to o } trait BadConnLoop1 extends DFDesign { val o = DFUInt ( 8 ) <> OUT val io = new IO1 {} io . i <> io . o //Bad connection! An initial conditions cyclic loop o <> io . o } trait IO2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i . prev //prev transfers initial conditions } trait BadConnLoop2 extends DFDesign { val o = DFUInt ( 8 ) <> OUT val io = new IO2 {} io . i <> io . o //Bad connection! An initial conditions cyclic loop o <> io . o } trait IO3 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o := i //Assignment does not affect initial conditions and therefore breaks the loop } trait OKConnLoop extends DFDesign { val o = DFUInt ( 8 ) <> OUT val io = new IO3 {} io . i <> io . o //OK! o <> io . o } Note : when following the drawing convention within this document, we want to avoid a double-lined loop in order to avoid a cyclic initial conditions dependency. Valid Connection and Assignment Examples \ud83d\udd17 1 2 3 4 5 trait IODesign extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i } 1 2 3 4 5 6 7 trait IODesign1 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val tmp = DFUInt ( 8 ) tmp <> i o <> tmp } 1 2 3 4 5 6 7 8 trait IODesign2 extends DFDesign { val i1 = DFUInt ( 8 ) <> IN val o1 = DFUInt ( 8 ) <> OUT val i2 = DFUInt ( 8 ) <> IN val o2 = DFUInt ( 8 ) <> OUT o1 <> i1 o2 <> i2 } 1 2 3 4 5 6 7 trait Container extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new IODesign {} i <> io . i //Connecting between owner input and child input io . o <> o //Connecting between child output and owner output } 1 2 3 4 5 6 7 8 9 trait Container2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io1 = new IODesign {} val io2 = new IODesign {} i <> io1 . i //Connecting between owner input and child input io1 . o <> io2 . i //Connecting between siblings (output <> input) io2 . o <> o //Connecting between child output and owner output } 1 2 3 4 5 6 7 8 trait Container3 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new IODesign2 {} i <> io . i1 //Connecting between owner input and child input i <> io . i2 //Connecting between owner input and child input o <> ( io . o1 + io . o2 ) } 1 2 3 4 5 6 7 8 trait Container4 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new IODesign2 {} i <> io . i1 //Connecting between owner input and child input io . i2 <> 5 //Connecting between constant value and child input o <> io . o2 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 trait Blank2 extends DFDesign { val i1 = DFUInt ( 8 ) <> IN val o1 = DFUInt ( 8 ) <> OUT val i2 = DFUInt ( 8 ) <> IN val o2 = DFUInt ( 8 ) <> OUT } trait Container5 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new Blank2 { o1 <> i1 //Assignment o2 <> i2 //Internal connection } i <> io . i1 //Connecting between owner input and child input io . i2 <> io . o1 //External connection between child input/output creates a feeback o <> io . o2 } Note: although there is a feedback in this design, there is no circular initial conditions dependency. Future Work \ud83d\udd17 In the future <> will be used to connect multi-port interfaces. We will add support to treat an alias of a port as a port when connection <> rules are enforced. Connecting between any ancestor which is not a parent and child. Currently not supported fully.","title":"Connectivity"},{"location":"user-guide/connectivity/#dataflow-ports-connectivity","text":"","title":"Dataflow Ports &amp; Connectivity"},{"location":"user-guide/connectivity/#legend","text":"Shape Meaning or A dataflow design A dataflow port. Arrow enters a dataflow design shape = INPUT port Arrow exists a dataflow design shape = OUTPUT port A dataflow variable (mutable) A constant (immutable literal). In this case, the value is 5. A dataflow join calculation junction (immutable). In this case, the calculation is the addition + arithmetic operation. A dataflow state element, via .prev(rank) (immutable). In this case, the rank is 3. A single-line arrow indicates a dataflow dependency assignment from a producer (arrow tail) to a consumer (arrow head) A double-line diamond arrow indicates a dataflow dependency connection from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency A double-line arrow indicates a dataflow dependency reference from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency","title":"Legend"},{"location":"user-guide/connectivity/#table-of-contents","text":"Dataflow Ports & Connectivity Legend Table of Contents Key Differences Between <> and := Connection <> Rules Dataflow Port Connections Dataflow Value Connections Dataflow Input Port Assignment := Rule Immutable Value Connections Different Type Connections Multiple Connections Mixing Assignments and Connections Connection Statement Order Connection and Initial Conditions Open (Unconnected) Ports Initial Condition Cyclic Loop Errors Valid Connection and Assignment Examples Future Work","title":"Table of Contents"},{"location":"user-guide/connectivity/#key-differences-between-and","text":"Criteria <> Connection := Assignment Code Functional Diagram We use a double line arrow to indicate a dataflow dependency with an initial condition dependency. We use a single line arrow to indicate a dataflow dependency without affecting initial conditions of the consumer. Directionality & Commutativity The operator is commutative, meaning a <> b is equivalent to b b <> a . One argument is the producer , while the other consumer . The dataflow direction is sensitive to the context in which the operator is applied. The operator is non-commutative, meaning a := b determines that b is the producer , transferring data to the consumer a . Initialization Initialization is transferred to the consumer. The consumer initialization is not affected. Mutation A consumer can only be connected once. Consumer assignments are unlimited. Statement Order Connections statements can be placed in any order. Assignment statements","title":"Key Differences Between &lt;&gt; and :="},{"location":"user-guide/connectivity/#connection-rules","text":"","title":"Connection &lt;&gt; Rules"},{"location":"user-guide/connectivity/#dataflow-port-connections","text":"Connections annotation is generally used to connect parent designs to their child designs (components) and connect between sibling designs (children of the same parent). Opposed to VHDL/Verilog, there is no need to go through 'signals' to connect sibling design ports, e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 trait IODesign extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i } trait Container2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io1 = new IODesign {} val io2 = new IODesign {} i <> io1 . i //Connecting between owner input and child input io1 . o <> io2 . i //Connecting between siblings (output <> input) io2 . o <> o //Connecting between child output and owner output }","title":"Dataflow Port Connections"},{"location":"user-guide/connectivity/#dataflow-value-connections","text":"At least one of the connected sides must be a dataflow port (cannot connect two dataflow values together), e.g.: 1 2 3 4 5 6 7 trait Conn1 { val port = DFUInt ( 8 ) <> OUT val temp1 = DFUInt ( 8 ) val temp2 = DFUInt ( 8 ) port <> temp1 //OK! temp1 <> temp2 //Bad connection! At least one connection side must be a port }","title":"Dataflow Value Connections"},{"location":"user-guide/connectivity/#dataflow-input-port-assignment-rule","text":"An input port cannot be assigned to. A connection must be used to transfer data to an input port, e.g.: 1 2 3 4 5 6 7 8 9 10 11 trait IO extends DFDesign { val in = DFUInt ( 8 ) <> IN val out = DFUInt ( 8 ) <> OUT out := in //OK! Can assign internally to an output port } trait Assign1 extends DFDesign { val io = new IO {} io . in := 1 //Bad assignment! Must use a connection annotation io . in <> 1 //OK! io . out := 1 //Bad assignment! Output ports can only be assigned internally }","title":"Dataflow Input Port Assignment := Rule"},{"location":"user-guide/connectivity/#immutable-value-connections","text":"When connecting a port to an immutable value, the port must be a consumer, meaning the connection is done internally to an output port or externally to an input port, e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 trait IO extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT //For brevity, we consider every connection/assignment in this example separately. //We ignore multiple connection issues that should arise. o <> 1 //OK! i <> 1 //Bad connection! 1 is immutable (constant) i <> o . prev //Bad connection! o.prev is immutable i . prev <> o //OK! } trait IOUser extends DFDesign { val io = new IO {} io . i <> 1 //OK! io . o <> 1 //Bad connection! 1 is immutable }","title":"Immutable Value Connections"},{"location":"user-guide/connectivity/#different-type-connections","text":"Connecting between different types is possible, but depends on the specific type: if it enables automatic conversion for the connection to succeed. Different port widths are considered different types and casting is required. An alias/casted/converted dataflow value is considered immutable for the connection (see above). Here are some examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 trait DifferentTypesConn extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val ob9 = DFBits ( 9 ) <> OUT val u7 = DFUInt ( 7 ) val u9 = DFUInt ( 9 ) val b8 = DFBits ( 8 ) //For brevity, we consider every connection/assignment in this example separately. //We ignore multiple connection issues that should arise. u7 <> o //OK! u7 is automatically extended to connect to u7 <> i //Bad connection! u7 is considered immutable when extended to 8 bits o <> b8 //Bad connection! There is not automatic casting between bits and uint o <> b8 . uint //OK! o . bits <> b8 //Bad connection! An alias of output port cannot be connected to //This may change in the future. o . bits := b8 //OK! u9 <> i //OK! In this example u9 is the consumer ob9 <> b8 //Bad connection! Bit vectors are NOT automatically extended. ob9 := b8 //Bad assignment! Bit vectors are NOT automatically extended. }","title":"Different Type Connections"},{"location":"user-guide/connectivity/#multiple-connections","text":"Two or more dataflow producers cannot be connected to the same consumer (a single producer can be connected to more than one consumer), e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 trait Gen extends DFDesign { val out1 = DFUInt ( 8 ) <> OUT init 1 val out2 = DFUInt ( 8 ) <> OUT init 2 } trait Conn2 extends DFDesign { val in1 = DFUInt ( 8 ) <> IN val in2 = DFUInt ( 8 ) <> IN val out = DFUInt ( 8 ) <> OUT val temp1 = DFUInt ( 8 ) temp1 <> in1 //OK! out <> in1 //Also OK! (Same producer can connect to more than one cosumer) temp1 <> in2 //Bad connection! Second producer connection to temp1 val gen = new Gen {} val temp2 = DFUInt ( 8 ) val temp3 = DFUInt ( 8 ) gen . out1 <> temp2 //OK! gen . out1 <> temp3 //Also OK! (Same producer can connect to more than one cosumer) gen . out2 <> temp2 //Bad connection! Second producer connection to temp2 }","title":"Multiple Connections"},{"location":"user-guide/connectivity/#mixing-assignments-and-connections","text":"The same consumer cannot be both assigned to and connected to as the consumer, e.g.: 1 2 3 4 5 6 7 8 9 10 11 12 13 trait Conn3 extends DFDesign { val out1 = DFUInt ( 8 ) <> OUT val out2 = DFUInt ( 8 ) <> OUT val out3 = DFUInt ( 8 ) <> OUT out1 <> 1 //OK! out1 := 1 //Bad assignment! Cannot assign to a connected dataflow variable out2 := 2 //OK! out2 <> 2 //Bad connection! Cannot connect to an assigned dataflow variable out3 := 1 //OK! out3 := 2 //Also OK! (Multiple assignments are accepted) }","title":"Mixing Assignments and Connections"},{"location":"user-guide/connectivity/#connection-statement-order","text":"The connection <> statement ordering does not matter.","title":"Connection Statement Order"},{"location":"user-guide/connectivity/#connection-and-initial-conditions","text":"A connection <> transfers initial conditions to the consumer, but if the consumer is already initialized then the consumer keeps its existing initial conditions. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 trait IOInit extends DFDesign { val i = DFUInt ( 8 ) //init = (11, 12) Overriden from TopInit connection val o = DFUInt ( 8 ) init 5 //init = (5) Not overridden due to assignment val ip = i . prev //init = (12) Prev moves down the init queue o := ip } trait TopInit extends DFDesign { val i = DFUInt ( 8 ) <> IN . init ( 1 , 2 ) //init = (1, 2) The top-level initial conditions val o = DFUInt ( 8 ) <> OUT init 1 //init = (1) Keeps its initializaion val iPlus10 = in + 10 //init = (11, 12) Arithmetics affect init val io = new IOInit {} io . i <> inPlus10 o <> io . o } We learn from the above that port initial conditions are often overridden due to connections. So why should we apply initial conditions to a port? Answer: If we want to define what happens when a port is open (unconnected). Read the next two sections for more information.","title":"Connection and Initial Conditions"},{"location":"user-guide/connectivity/#open-unconnected-ports","text":"Ports have two connection sides: a consumer side and a producer side. Typically ports have both sides connected, except for top-level ports. When either port side is unconnected, we refer to it as open , and expect the following behavior: When the port consumer side is open, the port produces tokens according to its initial condition. Uninitialized open-consumer ports generate bubble tokens. When the port producer side is open (unless it is a top-level output port), the port is considered as not used, and is pruned during compilation. All dataflow streams that are only used by this port will be pruned as well. Note : the current compiler implementation does not warn of open ports. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 trait IOInit2 extends DFDesign { val i1 = DFUInt ( 8 ) <> IN init 5 val o1 = DFUInt ( 8 ) <> OUT val i2 = DFUInt ( 8 ) <> IN val o2 = DFUInt ( 8 ) <> OUT init 2 o1 <> i1 } trait TopIO2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT //Will generate infinite tokens of 2, due to io.o2 init val io = new IO5 {} o <> io . o2 i <> io . i1 io . i2 <> 5 }","title":"Open (Unconnected) Ports"},{"location":"user-guide/connectivity/#initial-condition-cyclic-loop-errors","text":"Connections enable dataflow feedbacks and even dataflow dependency loops. There is no problem in dependency loops, other than pipelining limitations (see chapter TBD for more information). However, if we only apply connections and references that transfer initial conditions, we end up with a cyclic dependency for initial condition which is illegal. Therefore to enable dependency loops, at least one link in the loop must be an assignment, which has an implicit state and does not affect initial conditions. Consider the following examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 trait IO1 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i //Connection transfers initial conditions from i to o } trait BadConnLoop1 extends DFDesign { val o = DFUInt ( 8 ) <> OUT val io = new IO1 {} io . i <> io . o //Bad connection! An initial conditions cyclic loop o <> io . o } trait IO2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i . prev //prev transfers initial conditions } trait BadConnLoop2 extends DFDesign { val o = DFUInt ( 8 ) <> OUT val io = new IO2 {} io . i <> io . o //Bad connection! An initial conditions cyclic loop o <> io . o } trait IO3 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o := i //Assignment does not affect initial conditions and therefore breaks the loop } trait OKConnLoop extends DFDesign { val o = DFUInt ( 8 ) <> OUT val io = new IO3 {} io . i <> io . o //OK! o <> io . o } Note : when following the drawing convention within this document, we want to avoid a double-lined loop in order to avoid a cyclic initial conditions dependency.","title":"Initial Condition Cyclic Loop Errors"},{"location":"user-guide/connectivity/#valid-connection-and-assignment-examples","text":"1 2 3 4 5 trait IODesign extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT o <> i } 1 2 3 4 5 6 7 trait IODesign1 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val tmp = DFUInt ( 8 ) tmp <> i o <> tmp } 1 2 3 4 5 6 7 8 trait IODesign2 extends DFDesign { val i1 = DFUInt ( 8 ) <> IN val o1 = DFUInt ( 8 ) <> OUT val i2 = DFUInt ( 8 ) <> IN val o2 = DFUInt ( 8 ) <> OUT o1 <> i1 o2 <> i2 } 1 2 3 4 5 6 7 trait Container extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new IODesign {} i <> io . i //Connecting between owner input and child input io . o <> o //Connecting between child output and owner output } 1 2 3 4 5 6 7 8 9 trait Container2 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io1 = new IODesign {} val io2 = new IODesign {} i <> io1 . i //Connecting between owner input and child input io1 . o <> io2 . i //Connecting between siblings (output <> input) io2 . o <> o //Connecting between child output and owner output } 1 2 3 4 5 6 7 8 trait Container3 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new IODesign2 {} i <> io . i1 //Connecting between owner input and child input i <> io . i2 //Connecting between owner input and child input o <> ( io . o1 + io . o2 ) } 1 2 3 4 5 6 7 8 trait Container4 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new IODesign2 {} i <> io . i1 //Connecting between owner input and child input io . i2 <> 5 //Connecting between constant value and child input o <> io . o2 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 trait Blank2 extends DFDesign { val i1 = DFUInt ( 8 ) <> IN val o1 = DFUInt ( 8 ) <> OUT val i2 = DFUInt ( 8 ) <> IN val o2 = DFUInt ( 8 ) <> OUT } trait Container5 extends DFDesign { val i = DFUInt ( 8 ) <> IN val o = DFUInt ( 8 ) <> OUT val io = new Blank2 { o1 <> i1 //Assignment o2 <> i2 //Internal connection } i <> io . i1 //Connecting between owner input and child input io . i2 <> io . o1 //External connection between child input/output creates a feeback o <> io . o2 } Note: although there is a feedback in this design, there is no circular initial conditions dependency.","title":"Valid Connection and Assignment Examples"},{"location":"user-guide/connectivity/#future-work","text":"In the future <> will be used to connect multi-port interfaces. We will add support to treat an alias of a port as a port when connection <> rules are enforced. Connecting between any ancestor which is not a parent and child. Currently not supported fully.","title":"Future Work"},{"location":"user-guide/errors/","text":"Errors & Warnings \ud83d\udd17 DFiant-related compiler errors & warnings and ways to resolve them Missing Context \ud83d\udd17 TBD Don't use var with dataflow values/variables \ud83d\udd17 TBD","title":"Errors"},{"location":"user-guide/errors/#errors-warnings","text":"DFiant-related compiler errors & warnings and ways to resolve them","title":"Errors &amp; Warnings"},{"location":"user-guide/errors/#missing-context","text":"TBD","title":"Missing Context"},{"location":"user-guide/errors/#dont-use-var-with-dataflow-valuesvariables","text":"TBD","title":"Don't use var with dataflow values/variables"},{"location":"user-guide/meta/","text":"Meta Hardware Description \ud83d\udd17","title":"Meta Hardware Description"},{"location":"user-guide/meta/#meta-hardware-description","text":"","title":"Meta Hardware Description"},{"location":"user-guide/simulation/","text":"Simulation \ud83d\udd17","title":"Simulation"},{"location":"user-guide/simulation/#simulation","text":"","title":"Simulation"},{"location":"user-guide/state/","text":"State & Initialization \ud83d\udd17 Semantically, every DFiant dataflow variable references a token stream (TS). Unless stated otherwise, all dataflow variables are always consuming and always producing. Previous token initialization: The token history stream can be initialized. Initialization does not mutate the dataflow variable. Initialization has no effect on the TS. Only when using prev the initialization is placed on the TS reference. init returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. Bubble tokens (?) : Produced when a prev is called on a non-initialized dataflow variable. E.g., Code Init Token Stream in : DFUInt[32] ? 2, 3, 1, 5, 9 in.prev ? ?, 2, 3, 1, 5, 9 in.prev(2) ? ?, ?, 2, 3, 1, 5, 9 in.prev.prev ? ?, ?, 2, 3, 1, 5, 9 val in1 = in.init(1); in1 1 2, 3, 1, 5, 9 in1.prev 1 1, 2, 3, 1, 5, 9 in1.prev(2) 1 1, 1, 2, 3, 1, 5, 9 in1.prev.init(8) 8 1, 2, 3, 1, 5, 9 val innew = DFUInt(32) := in1; innew ? 2, 3, 1, 5, 9 val ins7 = in.init(7, ?); ins7 (7, ?) 2, 3, 1, 5, 9 ins7.prev ? 7, 2, 3, 1, 5, 9 val ins78 = in.init(7, 8, ?); ins78 (7, 8, ?) 2, 3, 1, 5, 9 ins78.prev (8, ?) 7, 2, 3, 1, 5, 9 ins78.prev(2) ? 8, 7, 2, 3, 1, 5, 9 in.init(7).prev.init(8, ?).prev ? 8, 7, 2, 3, 1, 5, 9 Bubbles are like any regular-value tokens in terms of consumption and production rules. Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue. Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., 1 2 3 def foo ( a : DFUInt ( 8 )) = a + a . prev //'in' is token stream of: 2, 3, 1, 5, 9 //'foo(in)' returns: ?, 5, 4, 6, 14 prev maintains Distributivity through basic operations e.g.: (a + b).prev \u2257 a.prev + b.prev (timeless TS equality). Code Init Token Stream inL : DFUInt(32) ? 2, 3, 1, 5, 9 inR : DFUInt(32) ? 4, 0, 2 inL + inR ? + ? = ? 2, 3, 1, 5, 9 + 4, 0, 2 = 6, 3, 3 inL + inR.prev ? + ? = ? 2, 3, 1, 5, 9 + ?, 4, 0, 2 = ?, 7, 1, 7 inL.init(1) + inR.init(3).prev 1 + 3 = 4 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1, ?) + inR.init(3).prev (1, ?) + 3 = (4, ?) 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1) + inR.init(3, ?).prev 1 + ? = ? 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1).prev + inR.init(3).prev 1 + 3 = 4 1, 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 4, 6, 3, 3 (inL.init(1) + inR.init(3)).prev 1 + 3 = 4 (2, 3, 1, 5, 9 + 4, 0, 2) .prev = 4, 6, 3, 3 Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags. Casting: Parts of a bits vector can be bubbles while others normal values. However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.","title":"State (Memory)"},{"location":"user-guide/state/#state-initialization","text":"Semantically, every DFiant dataflow variable references a token stream (TS). Unless stated otherwise, all dataflow variables are always consuming and always producing. Previous token initialization: The token history stream can be initialized. Initialization does not mutate the dataflow variable. Initialization has no effect on the TS. Only when using prev the initialization is placed on the TS reference. init returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. Bubble tokens (?) : Produced when a prev is called on a non-initialized dataflow variable. E.g., Code Init Token Stream in : DFUInt[32] ? 2, 3, 1, 5, 9 in.prev ? ?, 2, 3, 1, 5, 9 in.prev(2) ? ?, ?, 2, 3, 1, 5, 9 in.prev.prev ? ?, ?, 2, 3, 1, 5, 9 val in1 = in.init(1); in1 1 2, 3, 1, 5, 9 in1.prev 1 1, 2, 3, 1, 5, 9 in1.prev(2) 1 1, 1, 2, 3, 1, 5, 9 in1.prev.init(8) 8 1, 2, 3, 1, 5, 9 val innew = DFUInt(32) := in1; innew ? 2, 3, 1, 5, 9 val ins7 = in.init(7, ?); ins7 (7, ?) 2, 3, 1, 5, 9 ins7.prev ? 7, 2, 3, 1, 5, 9 val ins78 = in.init(7, 8, ?); ins78 (7, 8, ?) 2, 3, 1, 5, 9 ins78.prev (8, ?) 7, 2, 3, 1, 5, 9 ins78.prev(2) ? 8, 7, 2, 3, 1, 5, 9 in.init(7).prev.init(8, ?).prev ? 8, 7, 2, 3, 1, 5, 9 Bubbles are like any regular-value tokens in terms of consumption and production rules. Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue. Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., 1 2 3 def foo ( a : DFUInt ( 8 )) = a + a . prev //'in' is token stream of: 2, 3, 1, 5, 9 //'foo(in)' returns: ?, 5, 4, 6, 14 prev maintains Distributivity through basic operations e.g.: (a + b).prev \u2257 a.prev + b.prev (timeless TS equality). Code Init Token Stream inL : DFUInt(32) ? 2, 3, 1, 5, 9 inR : DFUInt(32) ? 4, 0, 2 inL + inR ? + ? = ? 2, 3, 1, 5, 9 + 4, 0, 2 = 6, 3, 3 inL + inR.prev ? + ? = ? 2, 3, 1, 5, 9 + ?, 4, 0, 2 = ?, 7, 1, 7 inL.init(1) + inR.init(3).prev 1 + 3 = 4 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1, ?) + inR.init(3).prev (1, ?) + 3 = (4, ?) 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1) + inR.init(3, ?).prev 1 + ? = ? 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1).prev + inR.init(3).prev 1 + 3 = 4 1, 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 4, 6, 3, 3 (inL.init(1) + inR.init(3)).prev 1 + 3 = 4 (2, 3, 1, 5, 9 + 4, 0, 2) .prev = 4, 6, 3, 3 Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags. Casting: Parts of a bits vector can be bubbles while others normal values. However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.","title":"State &amp; Initialization"},{"location":"user-guide/synthesis/","text":"Synthesis \ud83d\udd17","title":"Synthesis"},{"location":"user-guide/synthesis/#synthesis","text":"","title":"Synthesis"},{"location":"user-guide/type-system/","text":"Type System \ud83d\udd17 DFiant is a Scala library, hence it inherently supports type safe and rich language constructs. DFiant brings type driven development concepts to hardware design, by creating an extensible dataflow class hierarchy, with the trait DFAny at its head (similar concept to Scala's Unified Types hierarchy). DFAny contains all fields that are common to every dataflow variable (e.g., .width represents the number of bits contained by the variable). Fig. 1 illustrates a simplified inheritance diagram of DFiant's dataflow types. Further explanation is given in the next section . Fig. 1: DFiant dataflow types: simplified inheritance diagram Mutable Dataflow Variables and Immutable Dataflow Values \ud83d\udd17 DFiant supports dataflow variables mutability via the := operator. Do not confuse with Scala-level mutability which is enabled by using var instead of val . Each dataflow class has two variations: an immutable class, which inherits from DFAny.Val and a mutable class, which inherits from DFAny.Var and accepts := . The difference between the types enforces an immutable right-hand-side (RHS), where required, and a mutable variable creation. Consider, for instance, the DFiant implementation of g in Table \\ref tbl:StateExDefImpl : a is immutable because it is a RHS addition between the dataflow variable i and a literal value 5 . Contrarily, c is mutable, since it is a dataflow variable constructor ( .init constructs a new initialized variable, while preserving the mutability trait). Fig. 1 demonstrates a dual class definition for every type (immutable and mutable). The naming convention helps to reason about the mutability. For example, DFBits and DFBits.Var are immutable and mutable classes, respectively. Constructing a new variable via DFBits (e.g, val a = DFBits [ 5 ] ) returns the mutable DFBits.Var[5] . Usually, we either receive or return an immutable type, hence we do not require annotating a type with its mutable variation. In cases where we want to return a mutable type, we annotate it as an output port (see Section~\\ref sec:io_ports ). Don't use var with dataflow values/variables Because the semantics may get confusing, we enforced a compiler error if a dataflow variable is constructed and fed into a Scala var reference. For example var a = DFUInt ( 8 ) will generate a Scala compiler error. Bit-Accurate Operations, Type Inference, and Data Structures \ud83d\udd17 All DFiant's dataflow types are bit-accurate and structurally static, with their bit-width set upon construction (e.g., DFBits[5] is a 5-bit vector). Operations between dataflow variables produce a bit-accurate result with the proper type inference. For example, an addition between an unsigned 5-bit variable ( DFUInt[5] ) and a signed 10-bit variable ( DFSInt[10] ) produces an adder that can be implicitly converted to a 10-bit signed variable, if carry is not required, or an 11-bit signed variable by explicitly invoking .wc from the addition. DFiant also allows operations between dataflow types and their corresponding Scala numeric types, by treating the Scala numeric types as constants (e.g., addition between DFSInt and Integer variables). A constant in the dataflow graph is a node that can produce infinite tokens of the same value. Bit Aliasing and Casting \ud83d\udd17 Aliasing in DFiant enables referencing a part of a dataflow variable, by invoking .bits(hiIdx, loIdx) , which creates a bits vector alias that references the original variable at the given index parameters. Every change of a dataflow variable affects its alias and vice versa (similar to VHDL's signal aliasing). Since this function also casts the variable as DFBits , this feature is used as a raw-data cast between different dataflow types. Aliasing of an alias is also possible, while maintaining relative bits indexing. Aliasing preserves the mutability trait: an alias of an immutable value is immutable, while an alias of a mutable variable is mutable. Fig.~\\ref fig:Aliasing demonstrates aliasing code and its effect on the contents of a dataflow variable ( bits128 ). Each line code does as follows: Constructs a new 128-bit vector, bits128 , and clears it. Creates a new alias, alias64 , which references the most significant 64 bits of bits128 . Since bits128 is a DFBits variable, there is no need to invoke .bits() , and we can apply the required indexes directly. Creates a new alias, alias32 , which references the least significant 32 bits of alias64 , which reference bits 64 to 95 of bits128 . Constructs a new double precision floating point dataflow variable, dbl , and initialize its value as 1.0 (hexadecimal value of 0x3FF00...0 ). Modifies the least significant byte of dbl . Sets the most significant bit of bits128 . Assigns dbl to the least significant 64 bits of bits128 through casting. All the bits of dbl are selected because .bits() is invoked without index parameters. Modifies a byte of bits128 . Basic Types \ud83d\udd17 DFiant pays DFBits \ud83d\udd17 DFBool \ud83d\udd17 DFUInt \ud83d\udd17 DFSInt \ud83d\udd17 DFEnum \ud83d\udd17","title":"Type System"},{"location":"user-guide/type-system/#type-system","text":"DFiant is a Scala library, hence it inherently supports type safe and rich language constructs. DFiant brings type driven development concepts to hardware design, by creating an extensible dataflow class hierarchy, with the trait DFAny at its head (similar concept to Scala's Unified Types hierarchy). DFAny contains all fields that are common to every dataflow variable (e.g., .width represents the number of bits contained by the variable). Fig. 1 illustrates a simplified inheritance diagram of DFiant's dataflow types. Further explanation is given in the next section . Fig. 1: DFiant dataflow types: simplified inheritance diagram","title":"Type System"},{"location":"user-guide/type-system/#mutable-dataflow-variables-and-immutable-dataflow-values","text":"DFiant supports dataflow variables mutability via the := operator. Do not confuse with Scala-level mutability which is enabled by using var instead of val . Each dataflow class has two variations: an immutable class, which inherits from DFAny.Val and a mutable class, which inherits from DFAny.Var and accepts := . The difference between the types enforces an immutable right-hand-side (RHS), where required, and a mutable variable creation. Consider, for instance, the DFiant implementation of g in Table \\ref tbl:StateExDefImpl : a is immutable because it is a RHS addition between the dataflow variable i and a literal value 5 . Contrarily, c is mutable, since it is a dataflow variable constructor ( .init constructs a new initialized variable, while preserving the mutability trait). Fig. 1 demonstrates a dual class definition for every type (immutable and mutable). The naming convention helps to reason about the mutability. For example, DFBits and DFBits.Var are immutable and mutable classes, respectively. Constructing a new variable via DFBits (e.g, val a = DFBits [ 5 ] ) returns the mutable DFBits.Var[5] . Usually, we either receive or return an immutable type, hence we do not require annotating a type with its mutable variation. In cases where we want to return a mutable type, we annotate it as an output port (see Section~\\ref sec:io_ports ). Don't use var with dataflow values/variables Because the semantics may get confusing, we enforced a compiler error if a dataflow variable is constructed and fed into a Scala var reference. For example var a = DFUInt ( 8 ) will generate a Scala compiler error.","title":"Mutable Dataflow Variables and Immutable Dataflow Values"},{"location":"user-guide/type-system/#bit-accurate-operations-type-inference-and-data-structures","text":"All DFiant's dataflow types are bit-accurate and structurally static, with their bit-width set upon construction (e.g., DFBits[5] is a 5-bit vector). Operations between dataflow variables produce a bit-accurate result with the proper type inference. For example, an addition between an unsigned 5-bit variable ( DFUInt[5] ) and a signed 10-bit variable ( DFSInt[10] ) produces an adder that can be implicitly converted to a 10-bit signed variable, if carry is not required, or an 11-bit signed variable by explicitly invoking .wc from the addition. DFiant also allows operations between dataflow types and their corresponding Scala numeric types, by treating the Scala numeric types as constants (e.g., addition between DFSInt and Integer variables). A constant in the dataflow graph is a node that can produce infinite tokens of the same value.","title":"Bit-Accurate Operations, Type Inference, and Data Structures"},{"location":"user-guide/type-system/#bit-aliasing-and-casting","text":"Aliasing in DFiant enables referencing a part of a dataflow variable, by invoking .bits(hiIdx, loIdx) , which creates a bits vector alias that references the original variable at the given index parameters. Every change of a dataflow variable affects its alias and vice versa (similar to VHDL's signal aliasing). Since this function also casts the variable as DFBits , this feature is used as a raw-data cast between different dataflow types. Aliasing of an alias is also possible, while maintaining relative bits indexing. Aliasing preserves the mutability trait: an alias of an immutable value is immutable, while an alias of a mutable variable is mutable. Fig.~\\ref fig:Aliasing demonstrates aliasing code and its effect on the contents of a dataflow variable ( bits128 ). Each line code does as follows: Constructs a new 128-bit vector, bits128 , and clears it. Creates a new alias, alias64 , which references the most significant 64 bits of bits128 . Since bits128 is a DFBits variable, there is no need to invoke .bits() , and we can apply the required indexes directly. Creates a new alias, alias32 , which references the least significant 32 bits of alias64 , which reference bits 64 to 95 of bits128 . Constructs a new double precision floating point dataflow variable, dbl , and initialize its value as 1.0 (hexadecimal value of 0x3FF00...0 ). Modifies the least significant byte of dbl . Sets the most significant bit of bits128 . Assigns dbl to the least significant 64 bits of bits128 through casting. All the bits of dbl are selected because .bits() is invoked without index parameters. Modifies a byte of bits128 .","title":"Bit Aliasing and Casting"},{"location":"user-guide/type-system/#basic-types","text":"DFiant pays","title":"Basic Types"},{"location":"user-guide/type-system/#dfbits","text":"","title":"DFBits"},{"location":"user-guide/type-system/#dfbool","text":"","title":"DFBool"},{"location":"user-guide/type-system/#dfuint","text":"","title":"DFUInt"},{"location":"user-guide/type-system/#dfsint","text":"","title":"DFSInt"},{"location":"user-guide/type-system/#dfenum","text":"","title":"DFEnum"}]}