{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DFiant HDL (DFHDL) Docs","text":"<p>The Official DFiant Hardware Description Language (DFHDL) Documentation</p> <p> </p> <p>Welcome to the DFiant hardware description language (DFHDL) documentation! </p> <p>DFHDL is a dataflow HDL and is embedded as a library in the Scala programming language. DFiant enables timing-agnostic and device-agnostic hardware description by using dataflow firing rules as logical constructs, coupled with modern software language features (e.g., inheritance, polymorphism, pattern matching) and classic HDL features (e.g., bit-accuracy, input/output ports). Additionally, DFHDL integrates two additional levels of hardware description abstractions: register-transfer (RT), which is equivalent to languages like Chisel and Amaranth; and event-driven (ED), which is equivalent to Verilog and VHDL. </p> <p> Get started</p> <p> Read more about the technology</p> <p> Run examples in your browser</p>"},{"location":"#documentation-status","title":"Documentation Status","text":"<p>We are actively working on a comprehensive user guide. We hope to be releasing it in the coming days.</p> <p>In the meanwhile, checkout our getting-started guide, to setup your system and try out a basic example. Additionally, we placed several examples under the Run In Browser section of the documentation, where you can try them right now.</p>"},{"location":"#required-knowledge","title":"Required Knowledge","text":"<p>You are not required to know Scala, yet you are expected to understand basic object oriented concepts. This documentation attempts to bridge over any syntactic gaps you may arrive at. Nonetheless, as you attempt to create more complex and generic designs, more Scala knowledge will be required of you.</p> <p>You are not required to be an FPGA/ASIC expert, yet you are expected to understand fundamental hardware description concepts found in languages such as Verilog and VHDL.  </p> <p>You are required to keep an open mind. Some of these concepts may seem strange at first, but they were set after careful thought and planning. However, we are not infallible so feel free to file an issue with questions and/or suggestions of different approaches we can take.</p>"},{"location":"about/LICENSE/","title":"License","text":"<p>Copyright (c) 2021 DFiant Inc.</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> GNU Lesser General Public License version 3 <pre><code>                    GNU LESSER GENERAL PUBLIC LICENSE\n                        Version 3, 29 June 2007\n\n  Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n  Everyone is permitted to copy and distribute verbatim copies\n  of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n    a) under this License, provided that you make a good faith effort to\n    ensure that, in the event an Application does not supply the\n    function or data, the facility still operates, and performs\n    whatever part of its purpose remains meaningful, or\n\n    b) under the GNU GPL, with none of the additional permissions of\n    this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n    a) Give prominent notice with each copy of the object code that the\n    Library is used in it and that the Library and its use are\n    covered by this License.\n\n    b) Accompany the object code with a copy of the GNU GPL and this license\n    document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n    a) Give prominent notice with each copy of the Combined Work that\n    the Library is used in it and that the Library and its use are\n    covered by this License.\n\n    b) Accompany the Combined Work with a copy of the GNU GPL and this license\n    document.\n\n    c) For a Combined Work that displays copyright notices during\n    execution, include the copyright notice for the Library among\n    these notices, as well as a reference directing the user to the\n    copies of the GNU GPL and this license document.\n\n    d) Do one of the following:\n\n        0) Convey the Minimal Corresponding Source under the terms of this\n        License, and the Corresponding Application Code in a form\n        suitable for, and under terms that permit, the user to\n        recombine or relink the Application with a modified version of\n        the Linked Version to produce a modified Combined Work, in the\n        manner specified by section 6 of the GNU GPL for conveying\n        Corresponding Source.\n\n        1) Use a suitable shared library mechanism for linking with the\n        Library.  A suitable mechanism is one that (a) uses at run time\n        a copy of the Library already present on the user's computer\n        system, and (b) will operate properly with a modified version\n        of the Library that is interface-compatible with the Linked\n        Version.\n\n    e) Provide Installation Information, but only if you would otherwise\n    be required to provide such information under section 6 of the\n    GNU GPL, and only to the extent that such information is\n    necessary to install and execute a modified version of the\n    Combined Work produced by recombining or relinking the\n    Application with a modified version of the Linked Version. (If\n    you use option 4d0, the Installation Information must accompany\n    the Minimal Corresponding Source and Corresponding Application\n    Code. If you use option 4d1, you must provide the Installation\n    Information in the manner specified by section 6 of the GNU GPL\n    for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n    a) Accompany the combined library with a copy of the same work based\n    on the Library, uncombined with any other library facilities,\n    conveyed under the terms of this License.\n\n    b) Give prominent notice with the combined library that part of it\n    is a work based on the Library, and explaining where to find the\n    accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n</code></pre>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>We would like to thank the opensource community, namely the Scala community, and great many others for their work and support!</p> Previous version EU support <p>Previous version of this work (simply called \"DFiant\" at the time) has been supported by EU H2020 ICT project LEGaTO, contract #780681.</p> <p></p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>We will most likely adopt the code of conduct of Django. </p> <p>This page will be updated soon.</p> <p>Our Stance on Opensource</p> <p>We are standing on the shoulders of giants, so lets at least wipe down our feet first.   Be kind, be respectful, and take no-one and nothing for granted.</p>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#v010","title":"v0.1.0","text":"<p>This is the first official version release of DFiant.</p>"},{"location":"getting-started/hello-world/","title":"Hello Hardware World","text":""},{"location":"getting-started/hello-world/#the-basic-dfhdl-program","title":"The Basic DFHDL Program","text":"<p>Since DFHDL is a Scala library, we are creating a Scala program that takes DFHDL designs and compiles (transpiles) them into lower representations (e.g., VHDL or Verilog). As such, some of DFHDL's compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. The Scala code below describes a program that runs the DFHDL compiler on an 8-bit overlapping counter design, <code>Counter8</code>. </p> <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> <p>Writing a DFHDL compilation program \u2013 as easy as 01-10-11!</p> <ol> <li><code>import dfhdl.*</code> once per source file, to import all the required namespace objects, types, and functionality.</li> <li><code>class _design_name_ extends RTDesign:</code> to define your register-transfer (RT) domain design. Populate your design with the required interface and functionality. DFHDL supports two additional design domains: dataflow (DF), and event-driven (ED).</li> <li>Add <code>@top</code> annotation to your top-level design (e.g., <code>@top class top_design_name_ ...</code>) to automatically create a compilation program entry point for the design, instantiate it, elaborate it, compile it to Verilog or VHDL (see compiler options), and finally commit the files to disk.</li> </ol>"},{"location":"getting-started/hello-world/#run-it-in-your-browser","title":"Run It In Your Browser","text":"Run it here <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> <p>For more examples that are available to run in your browser, see the relevant section.</p>"},{"location":"getting-started/hello-world/#run-it-on-your-system","title":"Run It On Your System","text":"<p>To run this example on your system, make sure to first follow the initial setup instructions.</p> <p>You have several options to run Scala programs on your system:</p> <ul> <li>For this simple <code>Counter8</code> example, you can just use the simplest scala-single-file approach. </li> <li>For common DFHDL projects, we recommend using the scala project approach. </li> <li>For complex, full-production DFHDL projects, you may need to use an sbt project, but this is usually not required.</li> </ul>"},{"location":"getting-started/hello-world/#scala-single-file","title":"Scala Single File","text":"View the scala single file example Counter8.scala<pre><code>//&gt; using scala 3.5.2\n//&gt; using dep io.github.dfianthdl::dfhdl::0.9.0\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.9.0\n//&gt; using option -deprecation -language:implicitConversions\n\nimport dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> Download and run in your terminal<pre><code>curl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-single-file/Counter8.scala\nscala run ./Counter8.scala\n</code></pre> <p>For more information, please run <code>scala run --help</code> or consult the online documentation.</p>"},{"location":"getting-started/hello-world/#scala-project","title":"Scala Project","text":"View the scala project files example projectFolder/project.scala<pre><code>//&gt; using scala 3.5.2\n//&gt; using dep io.github.dfianthdl::dfhdl::0.9.0\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.9.0\n//&gt; using option -deprecation -language:implicitConversions\n</code></pre> projectFolder/Counter8.scala<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> Download and run in your terminal<pre><code>curl -o project.scala https://dfianthdl.github.io/getting-started/hello-world/scala-project/project.scala\ncurl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-project/Counter8.scala\nscala run .\n</code></pre> <p>For more information, please run <code>scala run --help</code> or consult the online documentation.</p>"},{"location":"getting-started/hello-world/#sbt-project","title":"sbt Project","text":"<p>The best way to get started with a DFHDL sbt project is to clone our template from GitHub:</p> Clone and run in your terminal<pre><code>git clone https://github.com/DFiantHDL/dfhdl-template\ncd dfhdl-template\nsbt run\n</code></pre> <p>For more information, please consult the sbt documentation.</p>"},{"location":"getting-started/hello-world/#recommended-scala-formatting-for-dfhdl","title":"Recommended Scala Formatting for DFHDL","text":"<p>We recommend actively using Scalafmt, a code formatter for Scala that integrates well with your toolchain. The following setting is recommended for DFHDL designs:</p> View the Scalafmt recommended configuration file projectFolder/.scalafmt.conf<pre><code>version = 3.8.3\nrunner.dialect = scala3\n\nmaxColumn = 100\nalign.tokens = [{code = \"&lt;&gt;\"}, {code = \"=\"}, {code = \"=&gt;\"}, {code = \":=\"}, {code = \":==\"}]\nrewrite.scala3.removeOptionalBraces = oldSyntaxToo\nrewrite.scala3.insertEndMarkerMinLines = 15\n\nbinPack.literalArgumentLists = true\nbinPack.literalsMinArgCount = 5\nbinPack.literalsInclude = [\".*\"]\nbinPack.literalsIncludeSimpleExpr = true\nbinPack.literalsSingleLine = false\n\nnewlines.selectChains = keep\n</code></pre> Download it via your terminal<pre><code>curl -o .scalafmt.conf https://dfianthdl.github.io/getting-started/hello-world/scala-project/.scalafmt.conf\n</code></pre> <p>For more information, please consult the Scalafmt documentation.</p>"},{"location":"getting-started/initial-setup/","title":"Initial Setup","text":"<p>DFHDL is a domain specific language (DSL) library written in the Scala programming language (Scala 3.5.2), and as such it lets you utilize the entire Scala ecosystem, including IDEs, various tools, and other libraries. </p> <p>Is your system already fit for Scala development? Jump to the DFHDL hello-world section</p>"},{"location":"getting-started/initial-setup/#installing-scala-and-other-dependencies","title":"Installing Scala and Other Dependencies","text":"<p>We recommend directly installing Scala 3.5.2 (no need to install either Coursier, Scala CLI, or sbt):</p> <ul> <li> <p> Windows Instructions</p> Using Chocolatey <p>Run the following in Windows command or powershell:</p> <pre><code>choco install scala --version=3.5.2 \n</code></pre> </li> <li> <p> Linux Instructions</p> Using SDKMAN! <p>Run the following in your shell:</p> <pre><code>sdk install scala 3.5.2 \n</code></pre> </li> <li> <p> macOS Instructions</p> Using Homebrew <p>Run the following in your shell:</p> <pre><code>brew update\nbrew install scala\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>If for some reason the instructions above don't work for you, you can try to install Scala via Coursier using the information below.</p> </li> </ul> Installing Scala via Coursier <p>We recommend directly installing Scala, as instructed above. However, if you are experiencing issues, you can try installing Scala via Coursier, as follows:</p> <ul> <li> <p> Windows Instructions</p> ManualCMDPowershell <ol> <li> <p>Download the installer zip file.</p> </li> <li> <p>Open the zip.</p> </li> <li> <p>Double click the <code>cs-x86_64-pc-win32.exe</code> executable to extract and run Coursier setup.</p> </li> </ol> <p>Run the following in Windows command:</p> <pre><code>curl -fLo cs-x86_64-pc-win32.zip https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\ntar -xf cs-x86_64-pc-win32.zip\nmove cs-x86_64-pc-win32.exe cs.exe\n.\\cs setup\n</code></pre> <p>Run the following in Windows Powershell:</p> <pre><code>Invoke-WebRequest -Uri \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\" -OutFile \"cs-x86_64-pc-win32.zip\"\nExpand-Archive -Path \"cs-x86_64-pc-win32.zip\"\nRename-Item -Path \"cs-x86_64-pc-win32.exe\" -NewName \"cs.exe\"\nRemove-Item -Path \"cs-x86_64-pc-win32.zip\"\n.\\cs setup\n</code></pre> </li> <li> <p> Linux Instructions</p> x86-64 (aka AMD64)ARM64Other linux <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p> Goto Coursier's website</p> </li> <li> <p> macOS Instructions</p> via Brewaarch64 (M1,M2,...)x86-64 <p>Run the following in your shell:</p> <pre><code>brew install coursier/formulas/coursier\ncs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/coursier/launchers/raw/master/cs-x86_64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>For other OS or instructions please consult the Coursier website.</p> <p> Goto Coursier's website</p> </li> </ul>"},{"location":"getting-started/initial-setup/#ide-setup","title":"IDE Setup","text":"<p>Many IDEs support Scala development. The most popular are VS Code and IntelliJ IDEA. We recommend VS Code with the Metals plugin.</p> <p>Here is a summary of relevant IDEs:</p> <ul> <li> <p> VS Code (Recommended)</p> <p> Download VS Code</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> IntelliJ IDEA</p> <p> Download IntelliJ via ToolBox</p> <p> Scala Development Guide</p> </li> <li> <p> Vim</p> <p> Download Vim</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Sublime Text</p> <p> Download Sublime Text</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Emacs</p> <p> Download Emacs</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Other IDE/Instructions</p> <p> For other OS or instructions please consult the Metals website.</p> </li> </ul>"},{"location":"in-browser/1-bit-full-adder/","title":"1-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; a ^ b ^ c_in\n  c_out &lt;&gt; a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/alu/","title":"ALU","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nenum ALUSel extends Encode:\n  case ADD, SUB, SLL, SRL, SRA, AND, OR, XOR, SLT, SLTU, COPY1\n\n@top class ALU extends DFDesign:\n  val op1    = Bits(32) &lt;&gt; IN\n  val op2    = Bits(32) &lt;&gt; IN\n  val aluSel = ALUSel   &lt;&gt; IN\n  val aluOut = Bits(32) &lt;&gt; OUT\n\n  private val shamt = op2(4, 0)\n\n  import ALUSel.*\n  val outCalc: Bits[32] &lt;&gt; VAL = aluSel match\n    case ADD   =&gt; op1 + op2\n    case SUB   =&gt; op1 - op2\n    case AND   =&gt; op1 &amp; op2\n    case OR    =&gt; op1 | op2\n    case XOR   =&gt; op1 ^ op2\n    case SLT   =&gt; (op1.sint &lt; op2.sint).extend\n    case SLTU  =&gt; (op1 &lt; op2).extend\n    case SLL   =&gt; op1 &lt;&lt; shamt\n    case SRL   =&gt; op1 &gt;&gt; shamt\n    case SRA   =&gt; (op1.sint &gt;&gt; shamt).bits\n    case COPY1 =&gt; op1\n    case _     =&gt; ?\n  aluOut := outCalc\nend ALU\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/counter/","title":"Counter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class Counter(val width: Int &lt;&gt; CONST = 8) extends RTDesign:\n  val en  = Bit         &lt;&gt; IN\n  val cnt = UInt(width) &lt;&gt; OUT.REG init 0\n  if (en)\n    cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/led-blinker/","title":"LED Blinker","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** This is a led blinker */\n@top class Blinker(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST = 50000,\n    val LED_FREQ_Hz: Int &lt;&gt; CONST  = 1\n) extends RTDesign:\n  /** Half-count of the toggle for 50% duty cycle */\n  val HALF_PERIOD = (CLK_FREQ_KHz * 1000) / (LED_FREQ_Hz * 2)\n\n  /** LED output */\n  val led = Bit                     &lt;&gt; OUT.REG init 1\n  val cnt = UInt.until(HALF_PERIOD) &lt;&gt; VAR.REG init 0\n  if (cnt == HALF_PERIOD - 1)\n    cnt.din := 0\n    led.din := !led\n  else cnt.din := cnt + 1\nend Blinker\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/lfsr/","title":"LFSR","text":"<pre><code>import dfhdl.*\n\nenum Ctrl extends Encode:\n  case Idle, Seed, Run\n\n/** Galois Linear-Feedback Shift Register\n  */\nclass LFSR(val taps: Bits[Int] &lt;&gt; CONST) extends RTDesign:\n  val ctrl = Ctrl &lt;&gt; IN\n  val seed = Bits(taps.width) &lt;&gt; IN\n  val calc = Bits(taps.width) &lt;&gt; OUT init all(1)\n\n  import Ctrl.*\n  ctrl match\n    case Idle =&gt; // do nothing\n    case Seed =&gt;\n      if (seed == all(0)) calc := all(1)\n      else calc := seed\n    case Run =&gt;\n      val tap = if (calc.reg(1)(0)) taps else b\"${taps.width}'0\"\n      calc := (calc.reg &gt;&gt; 1) ^ tap\nend LFSR</code></pre>"},{"location":"in-browser/n-bit-full-adder/","title":"N-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nclass FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; a ^ b ^ c_in\n  c_out &lt;&gt; a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a\n\n@top class FullAdderN(val n: Int = 4) extends EDDesign:\n  val a, b  = Bits(n) &lt;&gt; IN\n  val c_in  = Bit     &lt;&gt; IN\n  val sum   = Bits(n) &lt;&gt; OUT\n  val c_out = Bit     &lt;&gt; OUT\n\n  val adder = List.fill(n)(FullAdder1())\n  for (i &lt;- 0 until n)\n    adder(i).a   &lt;&gt; a(i)\n    adder(i).b   &lt;&gt; b(i)\n    adder(i).sum &lt;&gt; sum(i)\n    if (i &lt; n - 1)\n      adder(i).c_out &lt;&gt; adder(i + 1).c_in\n  adder.head.c_in  &lt;&gt; c_in\n  adder.last.c_out &lt;&gt; c_out\nend FullAdderN\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/reg-file/","title":"Register File","text":"<pre><code>import dfhdl.*\n\n@top class RegFile(\n    val DATA_WIDTH: Int &lt;&gt; CONST = 32,\n    val REG_NUM: Int &lt;&gt; CONST    = 32\n) extends RTDesign:\n  val regs = Bits(DATA_WIDTH) X REG_NUM &lt;&gt; VAR.REG\n\n  val rs1, rs2 = new RelatedDomain:\n    val addr = Bits.until(REG_NUM) &lt;&gt; IN\n    val data = Bits(DATA_WIDTH)    &lt;&gt; OUT.REG\n    data.din := regs(addr)\n\n  val rd = new RelatedDomain:\n    val addr = Bits.until(REG_NUM) &lt;&gt; IN\n    val data = Bits(DATA_WIDTH)    &lt;&gt; IN\n    val wren = Bit                 &lt;&gt; IN\n    if (wren) regs(addr).din := data\n    regs(0).din              := all(0) // in RISC-V x0 is always 0\nend RegFile\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/true-dpr/","title":"True Dual-Port RAM","text":"<pre><code>import dfhdl.*\n\n@top class TrueDPR(\n    val DATA_WIDTH: Int &lt;&gt; CONST = 8,\n    val ADDR_WIDTH: Int &lt;&gt; CONST = 8\n) extends EDDesign:\n  val ram = Bits(DATA_WIDTH) X (2 ** ADDR_WIDTH) &lt;&gt; VAR.SHARED\n\n  val a, b = new RTDomain:\n    val data = Bits(DATA_WIDTH) &lt;&gt; IN\n    val addr = Bits(ADDR_WIDTH) &lt;&gt; IN\n    val q    = Bits(DATA_WIDTH) &lt;&gt; OUT.REG\n    val we   = Bit              &lt;&gt; IN\n\n    if (we)\n      ram(addr) := data\n    q.din       := ram(addr)\nend TrueDPR\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/uart-tx/","title":"UART Transmitter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class UART_Tx(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST  = 50000,\n    val BAUD_RATE_BPS: Int &lt;&gt; CONST = 115200\n) extends RTDesign:\n  val data_en    = Bit             &lt;&gt; IN\n  val DATA_BITS  = 8\n  val data       = Bits(DATA_BITS) &lt;&gt; IN\n  val tx         = Bit             &lt;&gt; OUT.REG\n  val tx_en      = Bit             &lt;&gt; OUT.REG\n  val tx_done    = Bit             &lt;&gt; OUT.REG\n  val BIT_CLOCKS = CLK_FREQ_KHz * 1000 / BAUD_RATE_BPS\n\n  enum Status extends Encode.OneHot:\n    case Idle, StartBit, DataBits, StopBit, Finalize\n  import Status.*\n  val status     = Status                 &lt;&gt; VAR.REG init Idle\n  val bitClkCnt  = UInt.until(BIT_CLOCKS) &lt;&gt; VAR.REG init 0\n  val dataBitCnt = UInt.until(DATA_BITS)  &lt;&gt; VAR.REG init 0\n  val shiftData  = Bits(DATA_BITS)        &lt;&gt; VAR.REG\n\n  // To save on writing the \"bit clock count wait\" 3 times,\n  // we use DFHDL's meta-programming capability.\n  @internals.metaContextIgnore\n  def waitBitAndThen(onThreshold: =&gt; Unit): Unit =\n    if (bitClkCnt == BIT_CLOCKS - 1)\n      bitClkCnt.din := 0\n      onThreshold\n    else bitClkCnt.din := bitClkCnt + 1\n\n  status match\n    case Idle =&gt;\n      tx_en.din      := 0\n      tx.din         := 1\n      tx_done.din    := 0\n      bitClkCnt.din  := 0\n      dataBitCnt.din := 0\n      if (data_en)\n        shiftData.din := data\n        status.din    := StartBit\n\n    case StartBit =&gt;\n      tx_en.din := 1\n      tx.din    := 0\n      waitBitAndThen { status.din := DataBits }\n\n    case DataBits =&gt;\n      tx.din := shiftData.lsbit\n      waitBitAndThen {\n        shiftData.din := shiftData &gt;&gt; 1\n        if (dataBitCnt == DATA_BITS - 1)\n          dataBitCnt.din := 0\n          status.din     := StopBit\n        else dataBitCnt.din := dataBitCnt + 1\n      }\n\n    case StopBit =&gt;\n      tx.din := 1\n      waitBitAndThen {\n        tx_done.din := 1\n        status.din  := Finalize\n      }\n\n    case Finalize =&gt;\n      tx_en.din   := 0\n      tx_done.din := 1\n      status.din  := Idle\n  end match\nend UART_Tx\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"intro/technology/","title":"The DFiant Technology","text":"<p>DFiant navigates the complexities of hardware design with a nuanced approach that addresses the limitations of traditional methods. The register-transfer level (RTL) abstraction, while precise, often shifts the design focus from the \"what\" of functionality to the \"how\" of implementation. This subtle yet significant distinction restricts design flexibility, making it challenging to optimize for external constraints like performance or power without compromising on tool automation capabilities. The detailed nature of RTL leads to complex, verbose coding, and extended simulation time. Although such granularity of control is sometimes necessary, it often exceeds the requirements of many applications.</p> <p>Conversely, High-Level Synthesis (HLS) tools offer an abstraction that simplifies hardware design, particularly for those without a background in hardware engineering. By utilizing familiar programming languages and incorporating auto-pipelining and optimization, HLS makes hardware acceleration more accessible. However, the inherent sequential semantics of these languages can obstruct the development of parallel hardware architectures, making it especially challenging to describe processors or synchronous interfaces.</p> <p>A newer category, High-Level RTLs (HL-RTLs), such as Chisel and Amaranth, aims to bridge these gaps. Embedded within popular programming languages as domain-specific languages (DSLs), these HL-RTLs introduce innovative constructs for hardware generation. However, despite these significant advancements, they remain anchored to the RTL model, which can restrict implementation flexibility. Furthermore, their level of abstraction does not fully support the verification capabilities found in VHDL and Verilog, which benefit from event-driven semantics.</p> <p>DFiant attempts to introduce an optimal middle ground, which covers key HDL technologies across dimensions of both control and productivity (sort of \"have the cake and it it too\").</p>"},{"location":"intro/technology/#the-dataflow-hardware-description-abstraction","title":"The Dataflow Hardware Description Abstraction","text":"<p>At the heart of DFiant's innovation is the dataflow hardware description abstraction, a paradigm shift from the traditional RTL model. Instead of relying on wires and registers, dataflow abstraction employs streams of data tokens. This fundamental difference explains why RTL is inherently tied to device specifications and timing constraints, whereas dataflow abstraction remains neutral to such parameters.</p> <p> </p> <p>In RTL design, designers are tasked with specifying the exact operations that occur in each clock cycle, closely aligning the design with the physical timing of the hardware. Dataflow abstraction, on the other hand, focuses on the sequence of operations based on data dependencies, without mandating when each operation should start or finish within the clock cycles. This distinction allows operations in the dataflow model to be free from the rigid timing of clock cycles, granting compilers in the toolchain greater flexibility to schedule operations and effectively pipeline the design.</p> <p>Moreover, RTL design often requires the strategic placement of registers for various functions, anchoring the design to specific timing requirements. We categorize register use in RTL into three primary functions: backend synchronization, interface synchronization, and intrinsic design functionality, such as state management. The figure above illustrates the diverse applications of registers within RTL designs. Unlike RTL, where registers are uniformly represented, dataflow abstraction introduces unique language constructs or constraints for each register type. This differentiation enables the DFHDL compiler to distinguish between registers integral to the function and those necessary for implementation, providing subsequent design stages valuable insights for optimization. In contrast, RTL often relies on comments within the code to convey this information, if it is documented at all.</p>"},{"location":"intro/technology/#three-design-domain-abstractions-within-a-single-hdl","title":"Three Design Domain Abstractions within a Single HDL","text":"<p>DFHDL stands out by offering a comprehensive integration of three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in Figure 4. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p> </p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through a carefully constructed compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p>A standout feature of DFHDL is its ability to regenerate the code in DFHDL syntax at any point in the compilation process, including intermediate stages. This transparency offers developers valuable insights into each step of the optimization or compilation, a stark contrast to many HLS tools that produce hard-to-interpret code, leaving developers to decipher the underlying processes in case of issues.</p>"},{"location":"intro/technology/#more-details","title":"More Details","text":"<p>For more details on motivation, you can read this position paper.</p>"},{"location":"transitioning/from-verilog/","title":"Transitioning from Verilog to DFHDL","text":""},{"location":"transitioning/from-verilog/#using-chatgpt","title":"Using ChatGPT","text":"<p>Help me ChatGPT, you're my only hope</p>"},{"location":"transitioning/from-verilog/#summary","title":"Summary","text":"<p>Module Definition</p> Verilog<pre><code>module _module_name_ #(\n  //param declarations\n) (\n  //port declarations\n);\n  //internal declarations\nendmodule\n</code></pre> DFHDL<pre><code>class _design_name_(\n  //param declarations\n) extends EDDesign:\n  //port &amp; internal declarations\n\n\nend _design_name_ //optional\n</code></pre> Verilog<pre><code>module AndGate (\n  input a, b;\n  output o\n);\n  assign o = a &amp; b\nendmodule\n</code></pre> DFHDL<pre><code>class AndGate extends EDDesign:\n  val a, b = Bit &lt;&gt; IN\n  val o    = Bit &lt;&gt; OUT\n\n  o &lt;&gt; a &amp;&amp; b\nend AndGate\n</code></pre> <p>Parameter Declarations</p> Verilog<pre><code>parameter [7:0] p = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val p: Bits[8] &lt;&gt; CONST = b\"8'1011\"\n</code></pre> Verilog<pre><code>module Concat #(\n  parameter  int len1;\n  parameter  int len2;\n  localparam int outlen = len1 + len2\n) (\n  input  [len1-1:0]   i1;\n  input  [len2-1:0]   i2;\n  output [outlen-1:0] o\n);\n  assign o = {i1, i2};\nendmodule\n</code></pre> DFHDL<pre><code>class Concat(\n    val len1: Int &lt;&gt; CONST\n    val len2: Int &lt;&gt; CONST\n) extends EDDesign:\n  val outlen = len1 + len2\n  val i1 = Bits(len1)   &lt;&gt; IN\n  val i2 = Bits(len2)   &lt;&gt; IN\n  val o  = Bits(outlen) &lt;&gt; OUT\n\n  o &lt;&gt; (i1, i2)\nend Concat\n</code></pre> <p>logic/reg/wire</p> Verilog<pre><code>logic [7:0] v = 8\u2019b1011;\nwire  [7:0] v = 8\u2019b1011;\nreg   [7:0] v = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val v = Bits(8) &lt;&gt; VAR init b\"8'1011\"\n</code></pre>"},{"location":"user-guide/compilation/","title":"Compilation","text":""},{"location":"user-guide/compilation/#elaboration","title":"Elaboration","text":""},{"location":"user-guide/connectivity/","title":"Index","text":""},{"location":"user-guide/connectivity/#dataflow-ports-connectivity","title":"Dataflow Ports &amp; Connectivity","text":""},{"location":"user-guide/connectivity/#legend","title":"Legend","text":"Shape Meaning or  A dataflow design A dataflow port. Arrow enters a dataflow design shape = INPUT portArrow exists a dataflow design shape = OUTPUT port A dataflow variable (mutable) A constant (immutable literal). In this case, the value is 5. A dataflow join calculation junction (immutable). In this case, the calculation is the addition <code>+</code> arithmetic operation. A dataflow state element, via <code>.prev(rank)</code> (immutable).In this case, the rank is 3. A single-line arrow indicates a dataflow dependencyassignment from a producer (arrow tail) to a consumer (arrow head) A double-line diamond arrow indicates a dataflow dependencyconnection from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency A double-line arrow indicates a dataflow dependencyreference from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency"},{"location":"user-guide/connectivity/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Dataflow Ports &amp; Connectivity<ul> <li>Legend</li> <li>Table of Contents</li> <li>Key Differences Between &lt;&gt; and :=</li> <li>Connection &lt;&gt; Rules<ul> <li>Dataflow Port Connections</li> <li>Dataflow Value Connections</li> <li>Dataflow Input Port Assignment := Rule</li> <li>Immutable Value Connections</li> <li>Different Type Connections</li> <li>Multiple Connections</li> <li>Mixing Assignments and Connections</li> <li>Connection Statement Order</li> <li>Connection and Initial Conditions</li> <li>Open (Unconnected) Ports</li> <li>Initial Condition Cyclic Loop Errors</li> </ul> </li> <li>Valid Connection and Assignment Examples</li> <li>Via Connections</li> <li>Future Work</li> </ul> </li> </ul>"},{"location":"user-guide/connectivity/#key-differences-between-and","title":"Key Differences Between <code>&lt;&gt;</code> and <code>:=</code>","text":"Criteria <code>&lt;&gt;</code> Connection <code>:=</code> Assignment Code FunctionalDiagram We use a double line arrow to indicate a dataflow dependency with an initial condition dependency. We use a single line arrow to indicate a dataflow dependency without affecting initial conditions of the consumer. Directionality &amp;Commutativity The operator is commutative, meaning <code>a &lt;&gt; b</code> is equivalent to b <code>b &lt;&gt; a</code>.  One argument is the producer, while the other consumer. The dataflow direction is sensitive to the context in which the operator is applied. The operator is non-commutative, meaning <code>a := b</code> determines that <code>b</code> is the producer, transferring data to the consumer <code>a</code>. Initialization Initialization is transferred to the consumer. The consumer initialization is not affected. Mutation A consumer can only be connected once. Consumer assignments are unlimited. Statement Order Connections statements can be placed in any order. Assignment statements"},{"location":"user-guide/connectivity/#connection-rules","title":"Connection <code>&lt;&gt;</code> Rules","text":""},{"location":"user-guide/connectivity/#dataflow-port-connections","title":"Dataflow Port Connections","text":"<p>Connections annotation is generally used to connect parent designs to their child designs (components) and connect between sibling designs (children of the same parent). Opposed to VHDL/Verilog, there is no need to go through 'signals' to connect sibling design ports, e.g.:</p> <pre><code>trait IODesign extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i\n}\ntrait Container2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io1 = new IODesign {}\n  val io2 = new IODesign {}\n  i     &lt;&gt; io1.i //Connecting between owner input and child input\n  io1.o &lt;&gt; io2.i //Connecting between siblings (output &lt;&gt; input)\n  io2.o &lt;&gt; o     //Connecting between child output and owner output\n}\n</code></pre> <p></p>"},{"location":"user-guide/connectivity/#dataflow-value-connections","title":"Dataflow Value Connections","text":"<p>At least one of the connected sides must be a dataflow port (cannot connect two dataflow values together), e.g.:</p> <pre><code>trait Conn1 {\n  val port = DFUInt(8) &lt;&gt; OUT\n  val temp1 = DFUInt(8)\n  val temp2 = DFUInt(8)\n  port &lt;&gt; temp1 //OK!\n  temp1 &lt;&gt; temp2 //Bad connection! At least one connection side must be a port\n}\n</code></pre>"},{"location":"user-guide/connectivity/#dataflow-input-port-assignment-rule","title":"Dataflow Input Port Assignment <code>:=</code> Rule","text":"<p>An input port cannot be assigned to. A connection must be used to transfer data to an input port, e.g.:</p> <pre><code>trait IO extends DFDesign {\n  val in  = DFUInt(8) &lt;&gt; IN\n  val out = DFUInt(8) &lt;&gt; OUT\n  out := in //OK! Can assign internally to an output port\n}\ntrait Assign1 extends DFDesign {\n  val io = new IO{}\n  io.in := 1 //Bad assignment! Must use a connection annotation\n  io.in &lt;&gt; 1 //OK!\n  io.out := 1 //Bad assignment! Output ports can only be assigned internally\n}\n</code></pre>"},{"location":"user-guide/connectivity/#immutable-value-connections","title":"Immutable Value Connections","text":"<p>When connecting a port to an immutable value, the port must be a consumer, meaning the connection is done internally to an output port or externally to an input port, e.g.:</p> <pre><code>trait IO extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  //For brevity, we consider every connection/assignment in this example separately.\n  //We ignore multiple connection issues that should arise.\n  o &lt;&gt; 1 //OK!\n  i &lt;&gt; 1 //Bad connection! 1 is immutable (constant)\n  i &lt;&gt; o.prev //Bad connection! o.prev is immutable\n  i.prev &lt;&gt; o //OK!\n}\ntrait IOUser extends DFDesign {\n  val io = new IO {}\n  io.i &lt;&gt; 1 //OK!\n  io.o &lt;&gt; 1 //Bad connection! 1 is immutable\n}\n</code></pre>"},{"location":"user-guide/connectivity/#different-type-connections","title":"Different Type Connections","text":"<p>Connecting between different types is possible, but depends on the specific type: if it enables automatic conversion for the connection to succeed. Different port widths are considered different types and casting is required. An alias/casted/converted dataflow value is considered immutable for the connection (see above). Here are some examples:</p> <pre><code>trait DifferentTypesConn extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val ob9 = DFBits(9) &lt;&gt; OUT\n\n  val u7 = DFUInt(7)\n  val u9 = DFUInt(9)\n  val b8 = DFBits(8)\n\n  //For brevity, we consider every connection/assignment in this example separately.\n  //We ignore multiple connection issues that should arise.\n  u7 &lt;&gt; o //OK! u7 is automatically extended to connect to \n  u7 &lt;&gt; i //Bad connection! u7 is considered immutable when extended to 8 bits\n  o &lt;&gt; b8 //Bad connection! There is not automatic casting between bits and uint\n  o &lt;&gt; b8.uint //OK!\n  o.bits &lt;&gt; b8 //Bad connection! An alias of output port cannot be connected to\n               //This may change in the future.\n  o.bits := b8 //OK!\n  u9 &lt;&gt; i //OK! In this example u9 is the consumer\n  ob9 &lt;&gt; b8 //Bad connection! Bit vectors are NOT automatically extended.\n  ob9 := b8 //Bad assignment! Bit vectors are NOT automatically extended.\n}\n</code></pre>"},{"location":"user-guide/connectivity/#multiple-connections","title":"Multiple Connections","text":"<p>Two or more dataflow producers cannot be connected to the same consumer (a single producer can be connected to more than one consumer), e.g.:</p> <pre><code>trait Gen extends DFDesign {\n  val out1 = DFUInt(8) &lt;&gt; OUT init 1\n  val out2 = DFUInt(8) &lt;&gt; OUT init 2\n}\ntrait Conn2 extends DFDesign {\n  val in1 = DFUInt(8) &lt;&gt; IN\n  val in2 = DFUInt(8) &lt;&gt; IN\n  val out = DFUInt(8) &lt;&gt; OUT\n  val temp1 = DFUInt(8)\n  temp1 &lt;&gt; in1 //OK!\n  out   &lt;&gt; in1 //Also OK! (Same producer can connect to more than one cosumer)\n  temp1 &lt;&gt; in2 //Bad connection! Second producer connection to temp1\n\n  val gen = new Gen {}\n  val temp2 = DFUInt(8)\n  val temp3 = DFUInt(8)\n  gen.out1 &lt;&gt; temp2 //OK!\n  gen.out1 &lt;&gt; temp3 //Also OK! (Same producer can connect to more than one cosumer)\n  gen.out2 &lt;&gt; temp2 //Bad connection! Second producer connection to temp2\n} \n</code></pre>"},{"location":"user-guide/connectivity/#mixing-assignments-and-connections","title":"Mixing Assignments and Connections","text":"<p>The same consumer cannot be both assigned to and connected to as the consumer, e.g.:</p> <pre><code>trait Conn3 extends DFDesign {\n  val out1 = DFUInt(8) &lt;&gt; OUT\n  val out2 = DFUInt(8) &lt;&gt; OUT\n  val out3 = DFUInt(8) &lt;&gt; OUT\n  out1 &lt;&gt; 1 //OK!\n  out1 := 1 //Bad assignment! Cannot assign to a connected dataflow variable\n\n  out2 := 2 //OK!\n  out2 &lt;&gt; 2 //Bad connection! Cannot connect to an assigned dataflow variable\n\n  out3 := 1 //OK!\n  out3 := 2 //Also OK! (Multiple assignments are accepted)\n}\n</code></pre>"},{"location":"user-guide/connectivity/#connection-statement-order","title":"Connection Statement Order","text":"<p>The connection <code>&lt;&gt;</code> statement ordering does not matter.</p>"},{"location":"user-guide/connectivity/#connection-and-initial-conditions","title":"Connection and Initial Conditions","text":"<p>A connection <code>&lt;&gt;</code> transfers initial conditions to the consumer, but if the consumer is already initialized then the consumer keeps its existing initial conditions. Here is an example:</p> <pre><code>trait IOInit extends DFDesign {\n  val i = DFUInt(8)        //init = (11, 12) Overriden from TopInit connection\n  val o = DFUInt(8) init 5 //init = (5)      Not overridden due to assignment\n  val ip = i.prev          //init = (12)     Prev moves down the init queue\n  o := ip \n}\ntrait TopInit extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN.init(1, 2)  //init = (1, 2)   The top-level initial conditions\n  val o = DFUInt(8) &lt;&gt; OUT init 1     //init = (1)      Keeps its initializaion\n  val iPlus10 = in + 10               //init = (11, 12) Arithmetics affect init\n  val io = new IOInit {}\n  io.i &lt;&gt; inPlus10                                          \n  o &lt;&gt; io.o                                         \n}\n</code></pre> <p></p> <p>We learn from the above that port initial conditions are often overridden due to connections. So why should we apply initial conditions to a port? Answer: If we want to define what happens when a port is open (unconnected). Read the next two sections for more information.</p>"},{"location":"user-guide/connectivity/#open-unconnected-ports","title":"Open (Unconnected) Ports","text":"<p>Ports have two connection sides: a consumer side and a producer side. Typically ports have both sides connected, except for top-level ports. When either port side is unconnected, we refer to it as open, and expect the following behavior:</p> <ul> <li> <p>When the port consumer side is open, the port produces tokens according to its initial condition. Uninitialized open-consumer ports generate bubble tokens.</p> </li> <li> <p>When the port producer side is open (unless it is a top-level output port), the port is considered as not used, and is pruned during compilation. All dataflow streams that are only used by this port will be pruned as well.</p> </li> </ul> <p>Note: the current compiler implementation does not warn of open ports.  </p> <p>Example:</p> <pre><code>trait IOInit2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN init 5\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT init 2\n  o1 &lt;&gt; i1 \n}\ntrait TopIO2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN  \n  val o = DFUInt(8) &lt;&gt; OUT //Will generate infinite tokens of 2, due to io.o2 init\n  val io = new IO5 {}\n  o &lt;&gt; io.o2\n  i &lt;&gt; io.i1\n  io.i2 &lt;&gt; 5\n}\n</code></pre> <p></p>"},{"location":"user-guide/connectivity/#initial-condition-cyclic-loop-errors","title":"Initial Condition Cyclic Loop Errors","text":"<p>Connections enable dataflow feedbacks and even dataflow dependency loops. There is no problem in dependency loops, other than pipelining limitations (see chapter TBD for more information). However, if we only apply connections and references that transfer initial conditions, we end up with a cyclic dependency for initial condition which is illegal. Therefore to enable dependency loops, at least one link in the loop must be an assignment, which has an implicit state and does not affect initial conditions. Consider the following examples:</p> <pre><code>trait IO1 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i //Connection transfers initial conditions from i to o\n}\ntrait BadConnLoop1 extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO1 {}\n  io.i &lt;&gt; io.o //Bad connection! An initial conditions cyclic loop\n  o  &lt;&gt; io.o\n}\ntrait IO2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i.prev //prev transfers initial conditions\n}\ntrait BadConnLoop2 extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO2 {}\n  io.i &lt;&gt; io.o //Bad connection! An initial conditions cyclic loop\n  o  &lt;&gt; io.o\n}\ntrait IO3 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o := i //Assignment does not affect initial conditions and therefore breaks the loop\n}\ntrait OKConnLoop extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO3 {}\n  io.i &lt;&gt; io.o //OK!\n  o  &lt;&gt; io.o\n}\n</code></pre> <p></p> <p>Note: when following the drawing convention within this document, we want to avoid a double-lined loop in order to avoid a cyclic initial conditions dependency.</p>"},{"location":"user-guide/connectivity/#valid-connection-and-assignment-examples","title":"Valid Connection and Assignment Examples","text":"<pre><code>trait IODesign extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i\n}\n</code></pre> <pre><code>trait IODesign1 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val tmp = DFUInt(8)\n  tmp &lt;&gt; i\n  o &lt;&gt; tmp\n}\n</code></pre> <pre><code>trait IODesign2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT\n  o1 &lt;&gt; i1\n  o2 &lt;&gt; i2\n}\n</code></pre> <pre><code>trait Container extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign {}\n  i    &lt;&gt; io.i //Connecting between owner input and child input\n  io.o &lt;&gt; o    //Connecting between child output and owner output\n}\n</code></pre> <pre><code>trait Container2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io1 = new IODesign {}\n  val io2 = new IODesign {}\n  i     &lt;&gt; io1.i //Connecting between owner input and child input\n  io1.o &lt;&gt; io2.i //Connecting between siblings (output &lt;&gt; input)\n  io2.o &lt;&gt; o     //Connecting between child output and owner output\n}\n</code></pre> <pre><code>trait Container3 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign2 {}\n  i &lt;&gt; io.i1 //Connecting between owner input and child input\n  i &lt;&gt; io.i2 //Connecting between owner input and child input\n  o &lt;&gt; (io.o1 + io.o2)\n}\n</code></pre> <pre><code>trait Container4 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign2 {}\n  i     &lt;&gt; io.i1 //Connecting between owner input and child input\n  io.i2 &lt;&gt; 5     //Connecting between constant value and child input\n  o     &lt;&gt; io.o2\n}\n</code></pre> <pre><code>trait Blank2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT    \n}\ntrait Container5 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new Blank2 {\n    o1 &lt;&gt; i1 //Assignment\n    o2 &lt;&gt; i2 //Internal connection   \n  }\n  i     &lt;&gt; io.i1 //Connecting between owner input and child input\n  io.i2 &lt;&gt; io.o1 //External connection between child input/output creates a feeback\n  o     &lt;&gt; io.o2\n}\n</code></pre> <p>Note: although there is a feedback in this design, there is no circular initial conditions dependency.</p>"},{"location":"user-guide/connectivity/#via-connections","title":"Via Connections","text":""},{"location":"user-guide/connectivity/#future-work","title":"Future Work","text":"<ul> <li>In the future <code>&lt;&gt;</code> will be used to connect multi-port interfaces.</li> <li>We will add support to treat an alias of a port as a port when connection <code>&lt;&gt;</code> rules are enforced.</li> <li>Connecting between any ancestor which is not a parent and child. Currently not supported fully.</li> </ul>"},{"location":"user-guide/design-domains/","title":"Design Domains","text":"<p>DFHDL offers three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in the following figure. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through an intelligent compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p> </p>"},{"location":"user-guide/errors/","title":"Errors &amp; Warnings","text":"<p>DFiant-related compiler errors &amp; warnings and ways to resolve them</p>"},{"location":"user-guide/errors/#missing-context","title":"Missing Context","text":"<p>TBD</p>"},{"location":"user-guide/errors/#dont-use-var-with-dataflow-valuesvariables","title":"Don't use <code>var</code> with dataflow values/variables","text":"<p>TBD</p>"},{"location":"user-guide/interfaces/","title":"Interfaces [WIP]","text":""},{"location":"user-guide/meta/","title":"Meta Hardware Description","text":""},{"location":"user-guide/methods/","title":"Functions / Methods","text":""},{"location":"user-guide/naming/","title":"Naming","text":""},{"location":"user-guide/processes/","title":"Processes","text":""},{"location":"user-guide/simulation/","title":"Simulation","text":""},{"location":"user-guide/state/","title":"Index","text":""},{"location":"user-guide/state/#state-initialization","title":"State &amp; Initialization","text":"<p>Semantically, every DFiant dataflow variable references a token stream (TS). </p> <ul> <li> <p>Unless stated otherwise, all dataflow variables are always consuming and always producing.</p> </li> <li> <p>Previous token initialization:</p> </li> <li> <p>The token history stream can be initialized.</p> </li> <li> <p>Initialization does not mutate the dataflow variable.</p> </li> <li> <p>Initialization has no effect on the TS. Only when using <code>prev</code> the initialization is placed on the TS reference.</p> </li> <li> <p><code>init</code> returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. </p> </li> <li> <p>Bubble tokens (?) :</p> </li> <li> <p>Produced when a <code>prev</code> is called on a non-initialized dataflow variable. E.g.,</p> Code Init Token Stream <code>in : DFUInt[32]</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>in.prev</code> <code>?</code> <code>?, 2, 3, 1, 5, 9</code> <code>in.prev(2)</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>in.prev.prev</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>val in1 = in.init(1); in1</code> <code>1</code> <code>2, 3, 1, 5, 9</code> <code>in1.prev</code> <code>1</code> <code>1, 2, 3, 1, 5, 9</code> <code>in1.prev(2)</code> <code>1</code> <code>1, 1, 2, 3, 1, 5, 9</code> <code>in1.prev.init(8)</code> <code>8</code> <code>1, 2, 3, 1, 5, 9</code> <code>val innew = DFUInt(32) := in1; innew</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>val ins7 = in.init(7, ?); ins7</code> <code>(7, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins7.prev</code> <code>?</code> <code>7, 2, 3, 1, 5, 9</code> <code>val ins78 = in.init(7, 8, ?); ins78</code> <code>(7, 8, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins78.prev</code> <code>(8, ?)</code> <code>7, 2, 3, 1, 5, 9</code> <code>ins78.prev(2)</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> <code>in.init(7).prev.init(8, ?).prev</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> </li> <li> <p>Bubbles are like any regular-value tokens in terms of consumption and production rules.</p> </li> <li> <p>Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue.</p> </li> <li> <p>Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., </p> <pre><code>def foo(a : DFUInt(8)) = a + a.prev\n//'in' is token stream of:    2, 3, 1, 5, 9\n//'foo(in)' returns:          ?, 5, 4, 6, 14\n</code></pre> </li> <li> <p><code>prev</code> maintains Distributivity through basic operations e.g.: </p> <p><code>(a + b).prev</code> \u2257 <code>a.prev + b.prev</code> (timeless TS equality).</p> Code Init Token Stream <code>inL : DFUInt(32)</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>inR : DFUInt(32)</code> <code>?</code> <code>4, 0, 2</code> <code>inL + inR</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2</code> <code>=</code><code>6, 3, 3</code> <code>inL + inR.prev</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>?, 4, 0, 2</code> <code>=</code><code>?, 7, 1, 7</code> <code>inL.init(1) + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1, ?) + inR.init(3).prev</code> <code>(1, ?)</code> <code>+</code><code>3</code> <code>=</code><code>(4, ?)</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1) + inR.init(3, ?).prev</code> <code>1</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1).prev + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>1, 2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>4, 6, 3, 3</code> <code>(inL.init(1) + inR.init(3)).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>(2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2)</code> <code>.prev =</code><code>4, 6, 3, 3</code> </li> <li> <p>Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags.</p> </li> <li> <p>Casting:</p> </li> <li> <p>Parts of a bits vector can be bubbles while others normal values.</p> </li> <li> <p>However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.</p> </li> </ul>"},{"location":"user-guide/state/#time-invariance","title":"Time Invariance","text":""},{"location":"user-guide/synthesis/","title":"Synthesis","text":""},{"location":"user-guide/type-system/","title":"Index","text":""},{"location":"user-guide/type-system/#type-system","title":"Type System","text":"<p>DFHDL is a Scala library and thus inherently supports type-safe and modern language constructs. This chapter covers the rules and API of this type system. </p> Check out the benefits of the DFHDL type system <ul> <li> <p> Strongly-typed</p> <p>Most type checks are performed statically, enforcing strict rules that help avoid ambiguity.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN \n//2-bit unsigned input\nval u2 = UInt(2) &lt;&gt; IN \nval y1 = u8 - u2 //ok\n// Error prevents ambiguous behavior \n// when a wider num is subtracted from \n// a narrow num.\nval y2 = u2 - u8 //error\n</code></pre> </p> </li> <li> <p> Bit-accurate</p> <p>Each DFHDL value has a defined bit-width, which is used to enforce rules that prevent data loss.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN  \n//8-bit signed output\nval s8 = SInt(8) &lt;&gt; OUT \n// Error prevents data loss when u8 is \n// converted to a 9-bit signed to be \n// assigned to s8, which is only 8-bits \n// wide.\ns8 := u8 //error\n</code></pre> </p> </li> <li> <p> Composable</p> <p>Types can be composed through structs or tuples to form new, combined types.</p> <pre><code>//new Pixel type as a structure\n//of two unsigned 8-bit numbers\ncase class Pixel(\n  x: UInt[8] &lt;&gt; VAL,\n  y: UInt[8] &lt;&gt; VAL\n) extends Struct\n\nval pixel = Pixel &lt;&gt; VAR\n//select and assign fields\npixel.x := pixel.y\n</code></pre> </li> <li> <p> Expandable</p> <p>New types can be defined, and methods can be added for entirely new or existing types.</p> <pre><code>//new AESByte type of unsigned 8-bit num\ncase class AESByte() \n  extends Opaque(UInt(8))\n//define addition between two AESByte\n//values as a xor operation\nextension (lhs: AESByte &lt;&gt; VAL)\n  def +(rhs: AESByte &lt;&gt; VAL): AESByte &lt;&gt; DFRET =\n    (lhs.actual ^ rhs.actual).as(AESByte)\nval x, y = AESByte &lt;&gt; VAR\nval z = x + y //actually XOR\n</code></pre> </li> </ul> <p>DFHDL Values</p> <p>Each DFHDL value is simply a Scala object that has two critical fields:</p> <ul> <li> <p> (Shape) Type, aka DFType</p> <p>Determines the bit-width and bit-structure of the value. Currently the supported types are: </p> <ul> <li>DFHDL Bit/Boolean: <code>Bit</code>/<code>Boolean</code> </li> <li>DFHDL Bit Vector: <code>Bits</code></li> <li>DFHDL Integer: <code>UInt</code>/<code>SInt</code>/<code>Int</code></li> <li> <p>DFHDL Fix-Point (future work)</p> </li> <li> <p>DFHDL Flt-Point (future work)</p> </li> <li> <p>DFHDL String (future work)</p> </li> <li>DFHDL Enumeration: <code>... extends Encoding</code></li> <li>DFHDL Vector: <code>_CellType_ X _Dim_</code></li> <li>DFHDL Structure: <code>... extends Struct</code></li> <li>DFHDL Tuple: <code>(T1, T2, ..., Tn)</code></li> <li>DFHDL Opaque: <code>... extends Opaque</code></li> <li>DFHDL Unit (Void): <code>Unit</code></li> </ul> </li> <li> <p> (Access) Modifier</p> <p>Determines what kind of access the user has on the value. User explicit modifiers:</p> <ul> <li>Variable: <code>VAR[.REG][.SHARED]</code></li> <li>Port: <code>IN</code>/<code>OUT[.REG]</code>/<code>INOUT</code></li> <li>Constant: <code>CONST</code></li> <li>Struct Field: <code>VAL</code></li> <li>Method Param: <code>VAL</code></li> <li>Method Return: <code>DFRET</code>/<code>RTRET</code>/<code>EDRET</code></li> </ul> <p>Although this mechanism can be quite complex under the hood, the explicit modifiers available to the user are straightforward.</p> </li> </ul> Internal Type-System Hierarchy (For Advanced Users) <p>DFHDL brings type-driven development concepts to hardware design, by creating an extensible type class hierarchy. Any DFHDL value is a Scala object instance of the class <code>DFVal[T &lt;: DFTypeAny, M &lt;: ModifierAny]</code>, where <code>T</code> is the type (shape) of value and <code>M</code> is a modifier that sets additional characteristics of the DFHDL value, like if it's assignable, connectable, initializable, etc. </p> <p> </p> <p>For example, the Scala value <code>x</code> which references a port declared like <code>val x = Boolean &lt;&gt; IN</code> has the type <code>DFVal[DFBool, Modifier.Dcl]</code>.</p>"},{"location":"user-guide/type-system/#Dcl","title":"Variable and Port Declarations","text":"<p>Ports are DFHDL values that define the inputs and outputs of a design. Variables are DFHDL values that represent internal design wiring, logic, or state.</p>"},{"location":"user-guide/type-system/#dcl-syntax","title":"Syntax","text":"Port/Variable declaration syntax<pre><code>val\u00a0_name_\u00a0=\u00a0_dftype_\u00a0&lt;&gt;\u00a0_modifier_\u00a0[init\u00a0_const_]\n</code></pre> <ul> <li><code>_name_</code> is the Scala value name reference for the DFHDL port/variable you constructed. The DFHDL compiler preserves this name and uses it in error messages and the final generated artifacts (e.g., Verilog module or VHDL entity port names). More information is available under the naming section.</li> <li><code>_dftype_</code> is set according to the shape type (DFType) of the DFHDL value. Each of the supported DFTypes have their own constructors. See relevant sections for the DFHDL DFType you wish to construct.</li> <li><code>&lt;&gt;</code> is the operator applied between a <code>_dftype_</code> and a <code>_modifier_</code> to construct the Scala value that represents a DFHDL variable or port accordingly. Note: the same <code>&lt;&gt;</code> operator is used as a language construct for declaring connections. Thanks to Scala method overloading, <code>&lt;&gt;</code> can be shared for both use-cases with no issues (due to the Scala argument type difference). </li> <li><code>_modifier_</code> is set with one of the following: <ul> <li><code>VAR</code> - to construct a variable</li> <li><code>IN</code> - to construct an input port</li> <li><code>OUT</code> - to construct an output port</li> <li><code>INOUT</code> - to construct a bidirectional input-output port</li> <li><code>VAR.REG</code> / <code>OUT.REG</code> - to construct a registered variable or output port (available only in RT domains) </li> <li><code>VAR.SHARED</code> - to construct a shared variable that can be assigned in more than one domain (this feature is to be used scarcely, to model unique designs like True Dual-Port RAM)</li> </ul> </li> <li><code>init</code> is an optional construct to initialize the DFHDL variable/port declaration history with the applied <code>_const_</code> value.</li> <li><code>_const_</code> is the state history initialization value or sequence of initialization values as a Scala Tuple. This value must be a constant that is supported by the DFType <code>_dftype_</code>.</li> </ul> Port/Variable declaration examples<pre><code>class Foo extends DFDesign:\n  //8-bit unsigned integer input port named 'i', \n  //initialized with the value 27.\n  val i\u00a0=\u00a0UInt(8)\u00a0    &lt;&gt;\u00a0IN\u00a0\u00a0init\u00a027\n\n  //single bit output port named 'o' \n  //with a sequence history (0, 1, 0) init\n  val o =\u00a0Bit\u00a0        &lt;&gt;\u00a0OUT\u00a0init\u00a0(0, 1, 0)\n\n  //5 element vector of 8-bit vector cells \n  //variable named 'v' with no init\n  val v\u00a0=\u00a0Bits(8) X 5 &lt;&gt;\u00a0VAR\n</code></pre>"},{"location":"user-guide/type-system/#dcl-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#scope","title":"Scope","text":"<ul> <li> <p>Variables can be declared in any DFHDL scope, except global scope, meaning within DFHDL designs, domains, interfaces, methods, processes, and conditional blocks. <pre><code>//error: Port/Variable declarations cannot be global\nval x = Bit &lt;&gt; VAR \nclass Foo extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n</code></pre></p> </li> <li> <p>Ports can only be declared at the scopes of DFHDL designs, domains, and interfaces. Other scopes are not allowed. <pre><code>class Foo extends DFDesign:\n  val i = Boolean &lt;&gt; IN\n  if (i)\n    //error: Ports can only be directly owned by a design, a domain or an interface.\n    val o = Bit &lt;&gt; OUT \n    o := 0\n</code></pre></p> </li> </ul>"},{"location":"user-guide/type-system/#naming","title":"Naming","text":"<p>Ports and variables must always be named, and cannot be anonymous. </p> <pre><code>class Foo extends DFDesign:\n  //error: constructed an anonymous \n  //output port\n  Bit &lt;&gt; OUT \n</code></pre> <p>As you'll read later on, constants and other values can be anonymous.</p>"},{"location":"user-guide/type-system/#connectable","title":"Connectable","text":"<p>Ports and variables are connectable, meaning they can be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.  For input ports this occurs outside their design scope, while connecting to an external value.  For output ports and variables this occurs only within their design scope, while connecting to an internal value. <pre><code>class ID extends DFDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  y &lt;&gt; x //connecting x to y\n</code></pre></p>"},{"location":"user-guide/type-system/#assignable-mutable","title":"Assignable (Mutable)","text":"<p>Output ports, input-output ports, and variables are assignable (mutable), when they can be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation, which occurs only within their design scope. Input ports can never be assigned (are immutable). Registered ports and variables are assignable only when referencing their registers' input via <code>.din</code> selection (referencing a register without <code>.din</code> is always considered to be its output, which is immutable). </p> <p>Assignment semantics are a key difference between the different design domains DFHDL has to offer. Here are some basic examples: <pre><code>class Foo1 extends DFDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  //dataflow assignment of x to y\n  y := x\n\nclass Foo2 extends RTDesign:\n  val x  = Bit &lt;&gt; IN\n  val y1 = Bit &lt;&gt; OUT\n  val y2 = Bit &lt;&gt; OUT.REG\n  //wire assignment of x to y1\n  y1     := x \n  //registered assignment of x to y2\n  y2.din := x \n\nclass Foo3 extends EDDesign:\n  val clk = Bit &lt;&gt; IN\n  val x   = Bit &lt;&gt; IN\n  val y1  = Bit &lt;&gt; OUT\n  val y2  = Bit &lt;&gt; OUT\n  process(all):\n    //blocking assignment of x to y1\n    y1 := x \n  process(clk):\n    if (clk.rising)\n      //non-blocking assignment of x to y2\n      y2 :== x \n\nclass Errors1 extends RTDesign:\n  val x  = Bit &lt;&gt; IN\n  val y1 = Bit &lt;&gt; OUT.REG\n  val y2 = Bit &lt;&gt; OUT\n  //error: Cannot assign to an immutable value.\n  x  := 1\n  //error: Cannot assign to a register output; it is immutable.\n  //To assign to the register's input, apply `.din` on the LHS argument of the assignment.\n  y1 := x\n  //error: Non-blocking assignments `:==` are allowed only inside an event-driven (ED) domain.\n  //Change the assignment to a regular assignment `:=` or the logic domain to ED.\n  y2 :== x\n\nclass Errors2 extends EDDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  //error: Blocking assignments `:=` are only allowed inside a process under an event-driven (ED) domain.\n  //Change the assignment to a connection `&lt;&gt;` or place it in a process.\n  y := x\n  //error: Non-blocking assignments `:==` are only allowed inside a process under an event-driven (ED) domain.\n  //Change the assignment to a connection `&lt;&gt;` or place it in a process.\n  y :== x\n</code></pre> Be sure to read more on assignment rules and semantics in the assignment section.</p>"},{"location":"user-guide/type-system/#not-constant","title":"Not Constant","text":"<p>Ports and variables are never considered to be constant (even when connected/assigned only once and to a constant value) for elaboration. Later compilation stages can apply further constant propagation steps that reduce logic utilization. <pre><code>class Errors extends DFDesign:\n  val x  = Bit &lt;&gt; VAR\n  x := 1\n  val c: Bit &lt;&gt; CONST = 1\n  // error: Not a constant\n  val e: Bit &lt;&gt; CONST = x\n</code></pre></p>"},{"location":"user-guide/type-system/#inout-port-limitation","title":"<code>INOUT</code> Port Limitation","text":"<p><code>INOUT</code> (bidirectional) ports are generally used to define IO pins of top-level device connectivity (e.g., protocols like I<sup>2</sup>C benefit from such ability). They are not meant for inter-device wiring reduction, and thus should be used scarcely within their intended purpose. Throughout the years they were also used to workaround HDL limitations like reading from output ports in VHDL'93, or lack of interfaces. Since DFHDL has none of these limitations, we encourage you to use <code>INOUT</code> for their intended purpose only, as synthesis tools for FPGAs and even ASICs will not cooperate. Although, theoretically, in DF domain we can enable bidirectional communication that can later be compiled into two separate ports, there is no real value behind this. <pre><code>class I2CCore extends EDDesign:\n  val scl = Bit &lt;&gt; INOUT\n  val sda = Bit &lt;&gt; INOUT\n</code></pre></p>"},{"location":"user-guide/type-system/#grouping","title":"Grouping","text":"<p>Ports can be grouped together in dedicated interfaces.</p>"},{"location":"user-guide/type-system/#Dcl-transitioning","title":"Transitioning","text":"Differences from Verilog <ul> <li>DFHDL supports more abstraction domains, and not just ED abstraction like Verilog does.</li> <li>The non-blocking assignment operator in DFHDL is <code>:==</code> instead of <code>&lt;=</code> in Verilog.</li> </ul> Differences from VHDL <p>TODO</p> Differences from Scala parameters/fields <p>TODO: Data validity, Number of outputs</p>"},{"location":"user-guide/type-system/#DFConst","title":"Constant/Literal Values","text":"<p>In DFHDL there are three methods to construct constant DFHDL values:</p> <ol> <li>Literal value generators: These language constructs directly generate constant DFHDL values. Currently, these are:<ul> <li>Binary <code>Bits</code> string interpolator</li> <li>Hexadecimal <code>Bits</code> string interpolator</li> <li>Decimal string interpolator</li> <li>Signed Decimal string interpolator</li> </ul> </li> <li>Constant candidates: Various Scala values can become DFHDL values, as. Constant declaration syntax<pre><code>val\u00a0_name_: _dftype_ &lt;&gt; CONST\u00a0=\u00a0_value_\n</code></pre></li> <li>Constant value propagation: Cleaners</li> </ol>"},{"location":"user-guide/type-system/#const-syntax","title":"Syntax","text":""},{"location":"user-guide/type-system/#const-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#unconnectable","title":"Unconnectable","text":"<p>Constant values are not connectable, and can never be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.</p>"},{"location":"user-guide/type-system/#unassignable-immutable","title":"Unassignable (Immutable)","text":"<p>Constant values are immutable and cannot be assigned, meaning they can never be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation.</p>"},{"location":"user-guide/type-system/#dfhdl-value-statement-order-referencing","title":"DFHDL Value Statement Order &amp; Referencing","text":"<p>Any DFHDL value must be declared before it can be referenced in code. Other than this (pretty intuitive) limitation, no other limitations exist and ports, variables, constants, and other values may be freely distributed within their approved scope space. During the compilation process, you can notice that the compiler reorders the port declarations so that they always come second to constant declarations, and variables right after.</p>"},{"location":"user-guide/type-system/#connection","title":"DFHDL Value Connections","text":"<p>After (or during) a design instantiation, its ports need to be connected to other ports or values of the same DFType by applying the <code>&lt;&gt;</code> operator. Variables can also be connected and used as intermediate wiring between ports. Output ports can be directly referenced (read) without being connected to an intermediate variable. For more rules about design and port connectivity, see the relevant section. Successful port/variable connection example<pre><code>class ID extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  //internal connection between ports\n  y &lt;&gt; x \n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre></p> Failed port/variable connection example<pre><code>class Foo extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y1 = Bit     &lt;&gt; OUT\n  val y2 = UInt(8) &lt;&gt; OUT\n  y1 &lt;&gt; x //DFType mismatch error\n  y2 &lt;&gt; x\n  //connection error (cannot connect \n  //to the same port more than once)\n  y2 &lt;&gt; x \n</code></pre>"},{"location":"user-guide/type-system/#assignment","title":"DFHDL Value Assignment (Mutation)","text":"<p>Both output ports and variables are mutable and can be assigned with values of the same DFType and only within the scope of the design they belong to. Input ports cannot be directly assigned, and require an intermediate variable connected to them to modify their value. Generally assignments to DFHDL values are applied through the <code>:=</code> operator. In processes under ED domains there are two kind of assignments: blocking assignments via <code>:=</code>, and non-blocking assignments via <code>:==</code>. Other domains support only blocking assignments via <code>:=</code>. Read more on domain semantics in the next section. See the connectivity section for more rules about mixing connections and assignments.</p> Successful port/variable connection example<pre><code>class Shift extends DFDesign:\n  val x = Bits(8) &lt;&gt; IN\n  val y = Bits(8) &lt;&gt; OUT\n  //assigning `x` left-shifted by 1 \n  //to `y`\n  y := x &lt;&lt; 1\n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre>"},{"location":"user-guide/type-system/#mutability","title":"DFHDL Value Mutation","text":"<p>DFiant supports dataflow variables mutability via the <code>:=</code> operator. Do not confuse with Scala-level mutability which is enabled by using <code>var</code> instead of <code>val</code>. Each dataflow class has two variations: an immutable class, which inherits from <code>DFAny.Val</code> and a mutable class, which inherits from <code>DFAny.Var</code> and accepts <code>:=</code>. The difference between the types enforces an immutable right-hand-side (RHS), where required, and a mutable variable creation. </p> <p>Consider, for instance, the DFiant implementation of <code>g</code> in Table \\ref<code>tbl:StateExDefImpl</code>: <code>a</code> is immutable because it is a RHS addition between the dataflow variable <code>i</code> and a literal value <code>5</code>. Contrarily, <code>c</code> is mutable, since it is a dataflow variable constructor (<code>.init</code> constructs a new initialized variable, while preserving the mutability trait). </p> <p>Fig. 1 demonstrates a dual class definition for every type  (immutable and mutable). The naming convention helps to reason about the mutability. For example, <code>DFBits</code> and <code>DFBits.Var</code> are immutable and mutable classes, respectively. Constructing a new variable via <code>DFBits</code> (e.g, <code>val a = DFBits[5]</code>) returns the mutable <code>DFBits.Var[5]</code>. Usually, we either receive or return an immutable type, hence we do not require annotating a type with its mutable variation. In cases where we want to return a mutable type, we annotate it as an output port (see Section~\\ref<code>sec:io_ports</code>).</p> <p>/// admonition | Don't use <code>var</code> with DFHDL values/variables     type: warning     Because the semantics may get confusing, we enforced a compiler error if a dataflow variable is constructed and fed into a Scala <code>var</code> reference. For example <code>var a = DFUInt(8)</code> will generate a Scala compiler error.  ///</p>"},{"location":"user-guide/type-system/#bit-accurate-operations-type-inference-and-data-structures","title":"Bit-Accurate Operations, Type Inference, and Data Structures","text":"<p>All DFiant's dataflow types are bit-accurate and structurally static, with their bit-width set upon construction (e.g., <code>DFBits[5]</code> is a 5-bit vector). Operations between dataflow variables produce a bit-accurate result with the proper type inference. For example, an addition between an unsigned 5-bit variable (<code>DFUInt[5]</code>) and a signed 10-bit variable (<code>DFSInt[10]</code>) produces an adder that can be implicitly converted to a 10-bit signed variable, if carry is not required, or an 11-bit signed variable by explicitly invoking <code>.wc</code> from the addition.</p> <p>DFiant also allows operations between dataflow types and their corresponding Scala numeric types, by treating the Scala numeric types as constants (e.g., addition between <code>DFSInt</code> and <code>Integer</code> variables). A constant in the dataflow graph is a node that can produce infinite tokens of the same value.   </p>"},{"location":"user-guide/type-system/#bit-aliasing-and-casting","title":"Bit Aliasing and Casting","text":"<p>Aliasing in DFiant enables referencing a part of a dataflow variable, by invoking <code>.bits(hiIdx, loIdx)</code>, which creates a bits vector alias that references the original variable at the given index parameters. Every change of a dataflow variable affects its alias and vice versa (similar to VHDL's signal aliasing). Since this function also casts the variable as <code>DFBits</code>, this feature is used as a raw-data cast between different dataflow types. Aliasing of an alias is also possible, while maintaining relative bits indexing. Aliasing preserves the mutability trait: an alias of an immutable value is immutable, while an alias of a mutable variable is mutable. </p> <p>Fig.~\\ref<code>fig:Aliasing</code> demonstrates aliasing code and its effect on the contents of a dataflow variable (<code>bits128</code>). Each line code does as follows:</p> <ol> <li>Constructs a new 128-bit vector, <code>bits128</code>, and clears it.</li> <li>Creates a new alias, <code>alias64</code>, which references the most significant 64 bits of <code>bits128</code>. Since <code>bits128</code> is a <code>DFBits</code> variable, there is no need to invoke <code>.bits()</code>, and we can apply the required indexes directly.</li> <li>Creates a new alias, <code>alias32</code>, which references the least significant 32 bits of <code>alias64</code>, which reference bits 64 to 95 of <code>bits128</code>.</li> <li>Constructs a new double precision floating point dataflow variable, <code>dbl</code>, and initialize its value as <code>1.0</code> (hexadecimal value of <code>0x3FF00...0</code>).</li> <li>Modifies the least significant byte of <code>dbl</code>.</li> <li>Sets the most significant bit of <code>bits128</code>.</li> <li>Assigns <code>dbl</code> to the least significant 64 bits of <code>bits128</code> through casting. All the bits of <code>dbl</code> are selected because <code>.bits()</code> is invoked without index parameters.</li> <li>Modifies a byte of <code>bits128</code>.</li> </ol>"},{"location":"user-guide/type-system/#bubble","title":"Bubble Values","text":"<ul> <li>RT and ED - Don't Care / Unknown</li> <li>DF - Stall</li> </ul>"},{"location":"user-guide/type-system/#dfhdl-value-candidates","title":"DFHDL Value Candidates","text":"<p>TODO: requires explanation The candidate produces a constant DFHDL value if the candidate argument is a constant.</p> <p>Operation supported values for an argument of DFType <code>T</code></p> `T`Candidate`T`ValueAnyValue`T`OperationCandidate . is! .. is? .. is? .. is! .. is? . Bits assignment and concatenation operation candidates example<pre><code>val b8 = Bits(8) &lt;&gt; VAR //8-bits variable\nval b9 = Bits(9) &lt;&gt; VAR //9-bits variable\n\n//Assignment operations to b8 accept either\n//Bits candidates that are 8-bit wide or\n//a same-element-vector (SEV) of \n//0/1/true/false, via `all(elem)`.\nb8 := h\"FF\"  //ok: 8-bits constant\nb8 := all(0) //ok: SEV of 0\nb8 := 5      //fails `Bits` candidate\nb8 := b9     //fails `:=` candidate\n\n//Bits `++` concatenation operation with b8\n//only accepts Bits candidate, while SEV\n//is not a Bits candidate.\nval x = b8 ++ h\"FF\"  //ok\nval y = b8 ++ all(0) //error\n</code></pre>"},{"location":"user-guide/type-system/#DFBitOrBool","title":"<code>Bit</code>/<code>Boolean</code> DFHDL Values","text":"<p><code>Bit</code> DFHDL values represent binary <code>1</code> or <code>0</code> values, whereas <code>Boolean</code> DFHDL values represent <code>true</code> or <code>false</code> values, respectively. The <code>Bit</code> and <code>Boolean</code> DFHDL values are generally interchangeable, and automatically converted between one and the other. </p> <p>Should I use <code>Bit</code> or <code>Boolean</code> DFTypes?</p> <p>Although they are interchangeable, it's generally recommended to use <code>Boolean</code> DFHDL values with conditional <code>if</code> statements, guards, or expressions, and <code>Bit</code> DFHDL values for everything else. There could be constant parameters that are better defined as a <code>true</code> or <code>false</code> <code>Boolean</code> values rather than <code>0</code> or <code>1</code> <code>Bit</code> values.</p> Why have both <code>Bit</code> and <code>Boolean</code> DFTypes? <p>The main reason to differentiate between <code>Bit</code> and <code>Boolean</code> is that VHDL has both <code>std_logic</code> and <code>boolean</code> types, respectively. Verilog has only a single <code>logic</code> or <code>wire</code> to represent both. Indeed VHDL'2008 has relaxed some of the type constraints, but not enough. And nevertheless, DFHDL aims to support various HDL dialects, and thus enables simple implicit or explicit conversion between these two DFType values.</p>"},{"location":"user-guide/type-system/#dftype-constructors","title":"DFType Constructors","text":"<p>Use the <code>Bit</code> or <code>Boolean</code> objects/types to construct <code>Bit</code> or <code>Boolean</code> DFHDL values, respectively.</p> <pre><code>val bit   = Bit     &lt;&gt; VAR\nval bool  = Boolean &lt;&gt; VAR\nval c_bit:  Bit     &lt;&gt; CONST = 1\nval c_bool: Boolean &lt;&gt; CONST = false\n</code></pre>"},{"location":"user-guide/type-system/#candidates","title":"Candidates","text":"<ul> <li>DFHDL <code>Bit</code> values.</li> <li>DFHDL <code>Boolean</code> values. </li> <li>Scala <code>1</code> or <code>0</code> literal values. A regular Scala <code>Int</code> is not accepted. This candidate always produces a constant DFHDL value.</li> <li>Scala <code>Boolean</code> values. This candidate always produces a constant DFHDL value.</li> </ul> <pre><code>val bit  = Bit     &lt;&gt; VAR\nval bool = Boolean &lt;&gt; VAR\n//`bool` is implicitly converted to a \n//Bit DFHDL value.\nbit := bool \n//`1` is implicitly converted to a DFHDL\n//Bit constant value.\nbit := 1\n//`false` is implicitly converted to a \n//DFHDL Boolean constant, and then\n//converted to a Bit constant value.\nbit := false\nval one: Int = 1\n//error (only 1/0 literals are ok)\nbit := one \n//`bit` is implicitly converted to a\n//DFHDL Boolean\nbool := bit \n//`true` is implicitly converted to a \n//DFHDL Boolean constant value.\nbool := true\n//`0` is implicitly converted to a \n//DFHDL Bit constant, and then\n//converted to a Boolean constant value.\nbool := 0\nval TrueVal: Boolean = 1\n//`TrueVal` is implicitly converted to\n//a DFHDL Boolean value.\nbool := TrueVal \n</code></pre>"},{"location":"user-guide/type-system/#operations","title":"Operations","text":""},{"location":"user-guide/type-system/#explicit-casting-operations","title":"Explicit Casting Operations","text":"<p>These operations propagate constant modifiers, meaning that if the casted argument is a constant, the returned value is also a constant.</p> Operation Description LHS Constraints Returns <code>lhs.bool</code> Cast to a DFHDL <code>Boolean</code> value <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.bit</code> Cast to a DFHDL <code>Bit</code> value <code>Boolean</code> DFHDL value <code>Bit</code> DFHDL value <pre><code>val bt1 = Bit &lt;&gt; VAR\nval bl1 = bt1.bool\nval bl2 = Boolean &lt;&gt; VAR\nval bt2 = bl2.bit\nval bt3: Bit     &lt;&gt; CONST = 0\nval bl3: Boolean &lt;&gt; CONST = bt3.bool\nval bl4: Boolean &lt;&gt; CONST = true\nval bt4: Bit     &lt;&gt; CONST = bt4.bit\n// error: bt1 is not a constant\nval err: Bit     &lt;&gt; CONST = bt1\n</code></pre>"},{"location":"user-guide/type-system/#bit-history-operations","title":"Bit History Operations","text":"<p>Currently these operations are only supported under ED domains. However, in upcoming DFHDL updates, support will be added across all domain abstractions.</p> Operation Description LHS Constraints Returns <code>lhs.rising</code> True when a value changes from <code>0</code> to <code>1</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.falling</code> True when a value changes from <code>1</code> to <code>0</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <pre><code>class Foo extends EDDesign:\n  val clk  = Bit &lt;&gt; IN\n\n  /* VHDL-style */\n  process(clk):\n    if (clk.rising) \n      //some sequential logic\n\n  /* Verilog-style */\n  process(clk.rising):\n    //some sequential logic\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the Verilog <code>posedge x</code> and <code>negedge x</code>, respectively.  In future releases these operations will have an expanded functionality under the other design domains.</p> Transitioning from VHDL <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the VHDL <code>rising_edge(x)</code> and <code>falling_edge(x)</code>, respectively. In future releases these operations will have an expanded functionality under the other design domains.</p> <p>For more information see either the design domains or processes sections.</p>"},{"location":"user-guide/type-system/#logical-operations","title":"Logical Operations","text":"<p>Logical operations' return type always match the LHS argument's type. These operations propagate constant modifiers, meaning that if all arguments are constant, the returned value is also a constant.</p> Operation Description LHS/RHS Constraints Returns <code>lhs &amp;&amp; rhs</code> Logical AND The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs || rhs</code> Logical OR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs ^ rhs</code> Logical XOR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>!lhs</code> Logical NOT The argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. LHS-Type DFHDL value <pre><code>val bt = Bit     &lt;&gt; VAR\nval bl = Boolean &lt;&gt; VAR\nval t1 = bt &amp;&amp; bl    //result type: Bit\nval t2 = bt ^ 1      //result type: Bit\nval t3 = bl || false //result type: Boolean\nval t4 = bt &amp;&amp; true  //result type: Bit\nval t5 = bl || bt    //result type: Boolean\nval t6 = bl ^ 0 || !bt\n//`t7` after the candidate implicit\n//conversions, looks like so:\n//(bl &amp;&amp; bt.bool) ^ (!(bt || bl.bit)).bool\nval t7 = (bl &amp;&amp; bt) ^ !(bt || bl)\n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e1 = 0 ^ bt      \n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e2 = false ^ bt\n//not supported since both arguments\n//are just candidates\nval e3 = 0 ^ true\n//This just yields a Scala Boolean, \n//as a basic operation between Scala\n//Boolean values.\nval sc: Boolean = true &amp;&amp; true\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation Verilog Operation <code>lhs &amp;&amp; rhs</code> <code>lhs &amp; rhs</code> <code>lhs || rhs</code> <code>lhs | rhs</code> <code>lhs ^ rhs</code> <code>lhs ^ rhs</code> <code>!lhs</code> <code>!lhs</code> Transitioning from VHDL <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation VHDL Operation <code>lhs &amp;&amp; rhs</code> <code>lhs and rhs</code> <code>lhs || rhs</code> <code>lhs or rhs</code> <code>lhs ^ rhs</code> <code>lhs xor rhs</code> <code>!lhs</code> <code>not lhs</code>"},{"location":"user-guide/type-system/#constant-meta-operations","title":"Constant Meta Operations","text":"<p>These operations are activated during the elaboration stage of the DFHDL compilation, and are only available for constant <code>Bit</code>/<code>Boolean</code> DFHDL values.  Their use case is for meta-programming purposes, to control the generated code without the knowledge of the DFHDL compiler (could be considered as pre-processing steps).</p> Operation Description LHS Constraints Returns <code>lhs.toScalaBitNum</code> Extracts the known elaboration Scala <code>BitNum</code>(<code>1 | 0</code>) value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>BitNum</code> value <code>lhs.toScalaBoolean</code> Extracts the known elaboration Scala <code>Boolean</code> value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>Boolean</code> value <p>The following runnable example demonstrates how such meta operation affect the elaborated design.  The <code>Boolean</code> argument <code>arg</code> of a design <code>Foo</code> is used twice within the design:  first, in an <code>if</code> condition directly; and second, in an <code>if</code> condition after a Scala value extraction.  When referenced directly, the <code>if</code> is elaborated as-is, but when the <code>if</code> is applied on the extracted Scala value,  the <code>if</code> is completely removed and either the block inside the <code>if</code> is elaborated when the argument is true or completely removed if false.</p> <code>Foo</code><code>Foo(true)</code><code>Foo(false)</code> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n    if (arg.toScalaBoolean) o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n    o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n</code></pre> Runnable example <pre><code>import dfhdl.*\n\n@top(false) class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n  if (arg.toScalaBoolean) o := 0\n\n@main def main = \n  println(\"Foo(true) Elaboration:\")\n  Foo(true).printCodeString\n  println(\"Foo(false) Elaboration:\")\n  Foo(false).printCodeString</code></pre>"},{"location":"user-guide/type-system/#DFBits","title":"<code>Bits</code> DFHDL Values","text":"<p><code>Bits</code> DFHDL values represent vectors of DFHDL <code>Bit</code> values as elements.  The vector bits width (length) is a positive constant number (nilable [zero-width] vectors will be supported in the future).</p> <p>Differences between DFHDL <code>Bits</code> and DFHDL Vector of <code>Bit</code></p> <p>In addition to <code>Bits</code>, DFHDL also supports generic vectors of any DFHDL values.  One could therefore construct a generic vector with <code>Bit</code> as the element DFType.  This vector has a different type than <code>Bits</code>, since <code>Bits</code> is a special case, both internally  in their implementations and externally in their API. Where applicable, both <code>Bits</code> and generic vector of <code>Bits</code> have overlapping equivalent APIs. </p>"},{"location":"user-guide/type-system/#dftype-constructors_1","title":"DFType Constructors","text":"Constructor Description Arg Constraints Returns <code>Bits(width)</code> Construct a <code>Bits</code> DFType with the given <code>width</code> as number of bits. <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[width.type]</code> DFType <code>Bits.until(sup)</code> Construct a <code>Bits</code> DFType with the given <code>sup</code> supremum number the vector is expected to reach. The number of bits is set as <code>clog2(sup)</code>. <code>sup</code> is a Scala <code>Int</code> or constant DFHDL <code>Int</code> value larger than 1. <code>Bits[CLog2[width.type]]</code> DFType <code>Bits.to(max)</code> Construct a <code>Bits</code> DFType with the given <code>max</code> maximum number the vector is expected to reach. The number of bits is set as <code>clog2(max+1)</code>. <code>max</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[CLog2[width.type+1]]</code> DFType <code>Bits[W]</code> Construct a <code>Bits</code> DFType with the given <code>W</code> width as Scala type argument (for advanced users). <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> Singleton type. <code>Bits[W]</code> DFType <pre><code>val b8 = Bits(8)       &lt;&gt; VAR\nval b3 = Bits.until(8) &lt;&gt; VAR\nval b4 = Bits.to(8)    &lt;&gt; VAR\nval b9 = Bits[9]       &lt;&gt; VAR\nval w: Int &lt;&gt; CONST = 7\nval b7 = Bits(w)       &lt;&gt; VAR\nval b6: Bits[6] &lt;&gt; CONST = all(0)\n</code></pre> Transitioning from Verilog <ul> <li>Specifying a width instead of an index range: In Verilog bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>[width-1:0]</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common Verilog bit vector declaration. For example, instead of declaring <code>reg [$clog2(DEPTH)-1:0] addr</code> in Verilog, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul> Transitioning from VHDL <ul> <li>Specifying a width instead of an index range: In VHDL bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>(width-1 downto 0)</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common VHDL bit vector declaration. For example, instead of declaring <code>signal addr: std_logic_vector(clog2(DEPTH)-1 downto 0)</code> in VHDL, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul>"},{"location":"user-guide/type-system/#literal-constant-value-generation","title":"Literal (Constant) Value Generation","text":"<p>Literal (constant) DFHDL <code>Bits</code> value generation is carried out through binary and hexadecimal string interpolation, a core Scala feature that was customized for DFHDL's exact use-case. There are also bit-accurate decimal and signed decimal interpolations available that produce <code>UInt</code> and <code>SInt</code> DFHDL values. If needed, those values can be cast to <code>Bits</code>. No octal interpolation is currently available or planned.</p>"},{"location":"user-guide/type-system/#b-interp","title":"Binary Bits String-Interpolator","text":"Binary Bits string-interpolation syntax<pre><code>b\"width'bin\"\n</code></pre> <ul> <li>bin is a sequence of <code>0</code>, <code>1</code>, and <code>?</code> characters, each representing a single bit.  <code>?</code> indicates a bit bubble.    The leftest (first) character is the most-significant bit (MSB), and the rightest (last) character is    the least-significant bit (LSB). </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>bin</code> are ignored.</li> <li><code>bin</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>width, followed by a <code>'</code> (apostrophe), is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added at the left of the sequence or the sequence is truncated based on the <code>width</code>.    Truncation only occurs if the MSBits being removed are zeros; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Binary Bits string-interpolation examples<pre><code>b\"1\"        // Value = 1\nb\"1000\"     // Value = 1000\nb\"8'1000\"   // Value = 00001000\nb\"3'0100\"   // Value = 100\nb\"3'1100\"   // Compilation error\nb\"1?11\"     // Value = 1?11 (? indicates a bit bubble)\nb\"11_00\"    // Value = 1100\nval value = \"100\"\nval width = 10\nb\"$width'1${value}1\" //Value = 0000011001\nval p: Int &lt;&gt; CONST = 10\nb\"$p'0\" // Value = 0....0 (p-bits wide)\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#h-interp","title":"Hexadecimal Bits String-Interpolator","text":"Hexadecimal Bits string-interpolation syntax<pre><code>h\"width'hex\"\n</code></pre> <ul> <li>hex is a sequence of hexadecimal characters (<code>0</code>-<code>9</code>, <code>A</code>-<code>F</code>, <code>a</code>-<code>f</code>, and <code>?</code>)   where <code>?</code> indicates a 4-bit bubble. Each character represents a 4-bit nibble,    encoded such that the leftest bit is the most-significant bit.    The leftest (first) character is the most-significant nibble, and the rightest (last) character is    the least-significant nibble. </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>hex</code> are ignored.</li> <li><code>hex</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>Binary sequences can be embedded within <code>{bin}</code> tags, allowing integration of binary   bit sequences of any length, not necessarily divisible by 4, between hex nibbles.</li> <li>width, followed by a <code>'</code>, is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added or the sequence is truncated based on the <code>width</code>. Truncation only occurs if   the most significant bits being removed are zeros or bubbles; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Hexadecimal Bits string-interpolation examples<pre><code>h\"1\"        // Value = 0001\nh\"27\"       // Value = 00100111\nh\"6'27\"     // Value = 100111\nh\"5'27\"     // Compilation error\nh\"2?\"       // Value = 0010????\nh\"F{00}F\"   // Value = 1111001111\nh\"3_3\"      // Value = 00110011\nval value = \"FF\"\nval width = 10\nh\"$width'${value}\" //Value = 0011111111\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#candidates_1","title":"Candidates","text":"<ul> <li>DFHDL <code>Bits</code> values</li> <li>DFHDL <code>Bit</code> or <code>Boolean</code> values. This candidate produces a single bit <code>Bits[1]</code> vector. </li> <li>DFHDL <code>UInt</code> values</li> <li>Scala <code>Tuple</code> combination of any DFHDL values and <code>1</code>/<code>0</code> literal values. This candidate performs bit concatenation of all values, according their order in the tuple, encoded from the most-significant value position down to the least-significant value position.</li> <li>Application-only candidate - Same-Element Vector (<code>all(elem)</code>).  </li> </ul> <pre><code>val b8   = Bits(8) &lt;&gt; VAR\nval b1   = Bits(1) &lt;&gt; VAR\n//`bit` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bit  = Bit     &lt;&gt; VAR\nb1 := bit\n//`bool` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bool = Boolean &lt;&gt; VAR\nbool := bit\n//`u8` is implicitly converted to a \n//Bits[8] DFHDL value.\nval u8   = UInt(8) &lt;&gt; VAR\nb8 := u8\nval s4   = SInt(4) &lt;&gt; VAR\n//the tuple is implicitly converted\n//to a Bits[8] DFHDL value.\nb8 := (1, s4, b1, b\"10\")\n</code></pre>"},{"location":"user-guide/type-system/#concatenated-assignment","title":"Concatenated Assignment","text":"<p>DFHDL supports a special-case assignment of concatenated DFHDL Bits variables, using a Scala <code>Tuple</code> syntax on LHS of the assignment operator. Both LHS and RHS bits width must be the same. This assignment is just syntactic sugar for multiple separate assignments and carried out during the design elaboration. The assignment ordering is from the first value at most-significant position down to the last value at least-significant position.</p> <code>Foo Declaration</code><code>Foo Elaboration</code> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")\n</code></pre> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  b2 := b\"10\"\n  b5 := (b\"1\", i4).toBits\n  b3 := b\"111\"\n</code></pre> Runnable example <pre><code>import dfhdl.*\n\n//print the code after elaboration\ngiven options.ElaborationOptions.PrintDFHDLCode = true\n//set mode to elaborate only\ngiven options.AppOptions.DefaultMode = options.AppOptions.DefaultMode.elaborate\n\n@top class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")</code></pre>"},{"location":"user-guide/type-system/#DFDecimal","title":"<code>UInt</code>/<code>SInt</code>/<code>Int</code> DFHDL Values","text":""},{"location":"user-guide/type-system/#constant-generation","title":"Constant Generation","text":""},{"location":"user-guide/type-system/#d-interp","title":"Decimal String-Interpolator","text":""},{"location":"user-guide/type-system/#sd-interp","title":"Signed Decimal String-Interpolator","text":""},{"location":"user-guide/type-system/#DFEnum","title":"Enumeration DFHDL Values","text":""},{"location":"user-guide/type-system/#DFVector","title":"Vector DFHDL Values","text":""},{"location":"user-guide/type-system/#DFStruct","title":"Struct DFHDL Values","text":""},{"location":"user-guide/type-system/#DFTuple","title":"Tuple DFHDL Values","text":""},{"location":"user-guide/type-system/#DFOpaque","title":"Opaque DFHDL Values","text":""},{"location":"user-guide/type-system/#DFUnit","title":"Unit (Void) DFHDL Values","text":""}]}