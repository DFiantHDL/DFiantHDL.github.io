{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"getting-started/initial-setup/","text":"Initial Setup \ud83d\udd17","title":"Initial Setup"},{"location":"getting-started/initial-setup/#initial-setup","text":"","title":"Initial Setup"},{"location":"intro/first-look/","text":"DFiant: First Look \ud83d\udd17 Your first encounter with the DFiant syntax, semantics and language features In this section we provide simple examples to demonstrate various DFiant syntax, semantics and languages features. If you wish to understand how to run these examples yourself, please refer to the Getting Started chapter of this documentation. Main Feature Overview \ud83d\udd17 Target and timing agnostic dataflow hardware description Strong bit-accurate type-safety Simplified port connections Automatic latency path balancing Automatic/manual pipelining Meta hardware description via rich Scala language constructs Basic Example: An Identity Function \ud83d\udd17 Let's begin with a basic example. The dataflow design ID has a signed 16-bit input port x and a signed 16-bit output port y . We implemented an identity function between the input and output, meaning that for an input series \\(x_k\\) the output series shall be \\(y_k=x_k\\) . Fig. 1a depicts a functional drawing of the design and Fig. 1b contains three tabs: the ID.scala DFiant compilation program code which implements ID and compiles it to VHDL (2008) and the generated VHDL files. Fig. 1a: Functional drawing of the dataflow design 'ID' with an input port 'x' and an output port 'y' ID.scala 1 2 3 4 5 6 7 import DFiant._ @df class ID extends DFDesign { //This our `ID` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer y := x //trivial direct input-to-output assignment } ID.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.ID_pkg. all ; entity ID is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end ID ; architecture ID_arch of ID is begin async_proc : process ( all ) begin y <= x ; end process ; end ID_arch ; ID_pkg.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; package ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector ; function to_sl ( b : boolean ) return std_logic ; function to_sl ( arg : std_logic_vector ) return std_logic ; function to_slv ( arg : std_logic ) return std_logic_vector ; function to_slv ( arg : unsigned ) return std_logic_vector ; function to_slv ( arg : signed ) return std_logic_vector ; function to_slv ( arg : boolean ) return std_logic_vector ; end package ID_pkg ; package body ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector is variable v_s : std_logic_vector ( s 'high downto s 'low ); begin for i in s 'high downto s 'low loop v_s ( i ) := s ( s 'high - i ); end loop ; return v_s ; end bit_reverse ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector is begin return to_slv ( resize ( unsigned ( arg ), size )); end resize ; function to_sl ( b : boolean ) return std_logic is begin if ( b ) then return '1' ; else return '0' ; end if ; end to_sl ; function to_sl ( arg : std_logic_vector ) return std_logic is begin return arg ( arg 'low ); end to_sl ; function to_slv ( arg : std_logic ) return std_logic_vector is begin if ( arg = '1' ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; function to_slv ( arg : unsigned ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : signed ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : boolean ) return std_logic_vector is begin if ( arg ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; end package body ID_pkg ; ID.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none `timescale 1 ns / 1 ps `include \"ID_defs.v\" module ID ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); always @( * ) begin y = x ; end endmodule ID_defs.v 1 2 3 `ifndef ID_DEFS_H `define ID_DEFS_H `endif Fig. 1b: A DFiant implementation of the identity function as a toplevel design and the generated VHDL/Verilog files The Scala code in Fig. 1b describes a program that runs the DFiant compiler on an identity function dataflow design, ID . Since DFiant is a Scala library some if its compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. Writing a DFiant compilation program \u2013 easy as 1-2-3! import DFiant._ to import all the required namespace fields trait _design_name_ extends DFDesign {} to define your dataflow design. Populate your design with the required dataflow functionality. object _program_name_ extends DFApp . VHDLCompiler [ _ design_name_ ] to create your compilation program entry point. ID.scala line-by-line breakdown Line 1 : This import statement summons all the DFiant classes, types and objects into the current scope. This is a must in every DFiant codebase. Lines 3-7 : This ID Scala trait is extended from the DFDesign (abstract) class and therefore declares it as a dataflow design. The reason why this is a trait and not a class is discussed later in this documentation. Currently, the rule of thumb to describe dataflow designs is to use traits that extend DFDesign . Lines 4-5 : Here we construct the input port x and output port y .Both were set as a 16-bit signed integer dataflow variable via the DFSInt[W] constructor, where W is a width type argument that can accept any positive integer literal. It is also possible to use a width term argument via DFSInt(width) . DFiant also support various types such as DFBits , DFUInt , and DFBool . All these dataflow variable construction options and more are discussed later in this documentation. The syntax val _name_ = _dataflow_variable_constructor_ <> _direction_ is used to construct a port and give it a named Scala reference. The Scala reference name will affect the name of this port when compiled to the required backend representation. Line 6 : The assignment operator := set the dataflow output port to receive input port values as they are. Line 9 : This object is an extension of a Scala App trait that creates a main entry point for the DFiant compilation program. By inheriting DFApp.VHDLCompiler[_top_] we also generate the top design and execute the compilation and commitment to VHDL files. Generated VHDL files observations The id.vhdl file is readable and maintains the names set in the DFiant design. The generated files follow various writing conventions such as capitalized port names and proper code alignment. The id_pkg.vhdl is a package file that is shared between all VHDL files generated by DFiant and contains common conversion functions that may be required. Additionally it may contain other definitions like enumeration types. Hierarchy and Connection Example \ud83d\udd17 IDTop.scala 1 2 3 4 5 6 7 8 9 10 11 import DFiant._ @df class IDTop extends DFDesign { //This our `IDTop` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer val id1 = new ID //First instance of the `ID` design val id2 = new ID //Second instance of the `ID` design id1 . x <> x //Connecting parent input port to child input port id1 . y <> id2 . x //Connecting sibling instance ports id2 . y <> y //Connecting parent output port to child output port } IDTop.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.IDTop_pkg. all ; entity IDTop is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end IDTop ; architecture IDTop_arch of IDTop is signal id1_x : signed ( 15 downto 0 ); signal id1_y : signed ( 15 downto 0 ); signal id2_x : signed ( 15 downto 0 ); signal id2_y : signed ( 15 downto 0 ); begin id1 : entity work . ID ( ID_arch ) port map ( x => id1_x , y => id1_y ); id2 : entity work . ID ( ID_arch ) port map ( x => id2_x , y => id2_y ); async_proc : process ( all ) begin id1_x <= x ; id2_x <= id1_y ; y <= id2_y ; end process ; end IDTop_arch ; IDTop.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 `default_nettype none `timescale 1 ns / 1 ps `include \"IDTop_defs.v\" module IDTop ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); wire signed [ 15 : 0 ] id1_y ; wire signed [ 15 : 0 ] id2_y ; reg signed [ 15 : 0 ] id1_x ; reg signed [ 15 : 0 ] id2_x ; ID id1 ( . x ( id1_x ), . y ( id1_y ) ); ID id2 ( . x ( id2_x ), . y ( id2_y ) ); always @( * ) begin id1_x = x ; id2_x = id1_y ; y = id2_y ; end endmodule Finite Step (State) Machine (FSM) Example \ud83d\udd17 SeqDet.scala 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import DFiant._ @df class SeqDet extends DFDesign { val seqIn = DFBit () <> IN val detOut = DFBit () <> OUT @df def detStep ( out : Int , trueNS : => FSM , falseNS : => FSM ) : FSM = FSM { detOut := out ifdf ( seqIn ){ trueNS . goto () }. elsedf { falseNS . goto () } } val S0 : FSM = detStep ( 0 , S1 , S0 ) val S1 : FSM = detStep ( 0 , S1 , S10 ) val S10 : FSM = detStep ( 0 , S1 , S100 ) val S100 : FSM = detStep ( 0 , S1001 , S0 ) val S1001 : FSM = detStep ( 1 , S1 , S10 ) } SeqDet.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SeqDet_pkg. all ; entity SeqDet is port ( clk : in std_logic ; rst : in std_logic ; seqIn : in std_logic ; detOut : out std_logic ); end SeqDet ; architecture SeqDet_arch of SeqDet is type E_fsm_states is ( E_fsm_states_S0 , E_fsm_states_S1 , E_fsm_states_S10 , E_fsm_states_S100 , E_fsm_states_S1001 ); signal fsm_state_prev1 : E_fsm_states := E_fsm_states_S0 ; signal fsm_state_sig : E_fsm_states ; begin async_proc : process ( all ) variable fsm_state : E_fsm_states := E_fsm_states_S0 ; begin fsm_state := fsm_state_prev1 ; case fsm_state is when E_fsm_states_S0 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; when E_fsm_states_S10 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S100 ; end if ; when E_fsm_states_S100 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1001 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1001 => detOut <= '1' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; end case ; fsm_state_sig <= fsm_state ; end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then fsm_state_prev1 <= E_fsm_states_S0 ; elsif rising_edge ( clk ) then fsm_state_prev1 <= fsm_state_sig ; end if ; end process ; end SeqDet_arch ; SeqDet.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 `default_nettype none `timescale 1 ns / 1 ps `include \"SeqDet_defs.v\" module SeqDet ( input wire clk , input wire rst , input wire seqIn , output reg detOut ); reg [ 2 : 0 ] fsm_state = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_prev1 = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_sig ; `define E_fsm_states_S0 0 `define E_fsm_states_S1 1 `define E_fsm_states_S10 2 `define E_fsm_states_S100 3 `define E_fsm_states_S1001 4 always @( * ) begin fsm_state = fsm_state_prev1 ; case ( fsm_state ) `E_fsm_states_S0 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end `E_fsm_states_S10 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S100 ; end `E_fsm_states_S100 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1001 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1001 : begin detOut = 1 'b1 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end default : begin fsm_state = 3 ' b ??? ; detOut = 1 ' b ? ; end endcase fsm_state_sig = fsm_state ; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) fsm_state_prev1 <= `E_fsm_states_S0 ; else fsm_state_prev1 <= fsm_state_sig ; end endmodule Simple Moving Average \ud83d\udd17 In this simple moving average (SMA) example, the signed 16-bit input, \\(x\\) No feedback implementation \ud83d\udd17 \\[ y_k=\\left(x_k+x_{k-1}+x_{k-2}+x_{k-3}\\right)/4 \\] SMA.scala 1 2 3 4 5 6 7 8 import DFiant._ @df class SMA extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val sum = ( x +^ x . prev ) +^ ( x . prev ( 2 ) +^ x . prev ( 3 )) y := ( sum >> 2 ). resize ( 16 ) } SMA.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_pkg. all ; entity SMA is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA ; architecture SMA_arch of SMA is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); begin async_proc : process ( all ) variable sum : signed ( 17 downto 0 ) := 18 d \"0\" ; begin sum := resize ( resize ( x , 17 ) + x_prev1 , 18 ) + ( resize ( x_prev2 , 17 ) + x_prev3 ); x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; y <= resize ( sum sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end if ; end process ; end SMA_arch ; SMA.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_defs.v\" module SMA ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 16 : 0 ] sum_part = 17 ' sd0 ; reg signed [ 17 : 0 ] sum = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; always @( * ) begin sum_part = ({ x [ 15 ], x [ 15 : 0 ]}) + x_prev1 ; sum = ({ sum_part [ 16 ], sum_part [ 16 : 0 ]}) + (({ x_prev2 [ 15 ], x_prev2 [ 15 : 0 ]}) + x_prev3 ); y_part = sum >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end end endmodule Feedback implementation \ud83d\udd17 \\[\\begin{eqnarray} a_0 &=& 0 \\\\ a_k &=& a_{k-1} - x_{k-4}+x_k \\\\ y_k &=& a_k/4 \\end{eqnarray}\\] SMA_FB.scala 1 2 3 4 5 6 7 8 9 import DFiant._ @df class SMA_FB extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val acc = DFSInt ( 18 ) init 0 acc := acc - x . prev ( 4 ) + x y := ( acc >> 2 ). resize ( 16 ) } SMA_FB.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_FB_pkg. all ; entity SMA_FB is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA_FB ; architecture SMA_FB_arch of SMA_FB is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev4 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal acc_prev1 : signed ( 17 downto 0 ) := 18 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); signal x_prev3_sig : signed ( 15 downto 0 ); signal acc_sig : signed ( 17 downto 0 ); begin async_proc : process ( all ) variable acc : signed ( 17 downto 0 ) := 18 d \"0\" ; begin acc := acc_prev1 ; acc := ( acc - x_prev4 ) + x ; x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; x_prev3_sig <= x_prev3 ; acc_sig <= acc ; y <= resize ( acc sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; x_prev4 <= 16 d \"0\" ; acc_prev1 <= 18 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end if ; end process ; end SMA_FB_arch ; SMA_FB.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_FB_defs.v\" module SMA_FB ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev4 = 16 ' sd0 ; reg signed [ 17 : 0 ] acc = 18 ' sd0 ; reg signed [ 17 : 0 ] acc_prev1 = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; reg signed [ 15 : 0 ] x_prev3_sig ; reg signed [ 17 : 0 ] acc_sig ; always @( * ) begin acc = acc_prev1 ; acc = ( acc - x_prev4 ) + x ; y_part = acc >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; x_prev3_sig = x_prev3 ; acc_sig = acc ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; x_prev4 <= 16 ' sd0 ; acc_prev1 <= 18 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end end endmodule Looks cool! I wish to know more \ud83d\udd17","title":"DFiant: First Look"},{"location":"intro/first-look/#dfiant-first-look","text":"Your first encounter with the DFiant syntax, semantics and language features In this section we provide simple examples to demonstrate various DFiant syntax, semantics and languages features. If you wish to understand how to run these examples yourself, please refer to the Getting Started chapter of this documentation.","title":"DFiant: First Look"},{"location":"intro/first-look/#main-feature-overview","text":"Target and timing agnostic dataflow hardware description Strong bit-accurate type-safety Simplified port connections Automatic latency path balancing Automatic/manual pipelining Meta hardware description via rich Scala language constructs","title":"Main Feature Overview"},{"location":"intro/first-look/#basic-example-an-identity-function","text":"Let's begin with a basic example. The dataflow design ID has a signed 16-bit input port x and a signed 16-bit output port y . We implemented an identity function between the input and output, meaning that for an input series \\(x_k\\) the output series shall be \\(y_k=x_k\\) . Fig. 1a depicts a functional drawing of the design and Fig. 1b contains three tabs: the ID.scala DFiant compilation program code which implements ID and compiles it to VHDL (2008) and the generated VHDL files. Fig. 1a: Functional drawing of the dataflow design 'ID' with an input port 'x' and an output port 'y' ID.scala 1 2 3 4 5 6 7 import DFiant._ @df class ID extends DFDesign { //This our `ID` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer y := x //trivial direct input-to-output assignment } ID.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.ID_pkg. all ; entity ID is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end ID ; architecture ID_arch of ID is begin async_proc : process ( all ) begin y <= x ; end process ; end ID_arch ; ID_pkg.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; package ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector ; function to_sl ( b : boolean ) return std_logic ; function to_sl ( arg : std_logic_vector ) return std_logic ; function to_slv ( arg : std_logic ) return std_logic_vector ; function to_slv ( arg : unsigned ) return std_logic_vector ; function to_slv ( arg : signed ) return std_logic_vector ; function to_slv ( arg : boolean ) return std_logic_vector ; end package ID_pkg ; package body ID_pkg is function bit_reverse ( s : std_logic_vector ) return std_logic_vector is variable v_s : std_logic_vector ( s 'high downto s 'low ); begin for i in s 'high downto s 'low loop v_s ( i ) := s ( s 'high - i ); end loop ; return v_s ; end bit_reverse ; function resize ( arg : std_logic_vector ; size : integer ) return std_logic_vector is begin return to_slv ( resize ( unsigned ( arg ), size )); end resize ; function to_sl ( b : boolean ) return std_logic is begin if ( b ) then return '1' ; else return '0' ; end if ; end to_sl ; function to_sl ( arg : std_logic_vector ) return std_logic is begin return arg ( arg 'low ); end to_sl ; function to_slv ( arg : std_logic ) return std_logic_vector is begin if ( arg = '1' ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; function to_slv ( arg : unsigned ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : signed ) return std_logic_vector is variable slv : std_logic_vector ( arg 'length - 1 downto 0 ); begin slv := std_logic_vector ( arg ); return slv ; end to_slv ; function to_slv ( arg : boolean ) return std_logic_vector is begin if ( arg ) then return \"1\" ; else return \"0\" ; end if ; end to_slv ; end package body ID_pkg ; ID.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none `timescale 1 ns / 1 ps `include \"ID_defs.v\" module ID ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); always @( * ) begin y = x ; end endmodule ID_defs.v 1 2 3 `ifndef ID_DEFS_H `define ID_DEFS_H `endif Fig. 1b: A DFiant implementation of the identity function as a toplevel design and the generated VHDL/Verilog files The Scala code in Fig. 1b describes a program that runs the DFiant compiler on an identity function dataflow design, ID . Since DFiant is a Scala library some if its compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. Writing a DFiant compilation program \u2013 easy as 1-2-3! import DFiant._ to import all the required namespace fields trait _design_name_ extends DFDesign {} to define your dataflow design. Populate your design with the required dataflow functionality. object _program_name_ extends DFApp . VHDLCompiler [ _ design_name_ ] to create your compilation program entry point. ID.scala line-by-line breakdown Line 1 : This import statement summons all the DFiant classes, types and objects into the current scope. This is a must in every DFiant codebase. Lines 3-7 : This ID Scala trait is extended from the DFDesign (abstract) class and therefore declares it as a dataflow design. The reason why this is a trait and not a class is discussed later in this documentation. Currently, the rule of thumb to describe dataflow designs is to use traits that extend DFDesign . Lines 4-5 : Here we construct the input port x and output port y .Both were set as a 16-bit signed integer dataflow variable via the DFSInt[W] constructor, where W is a width type argument that can accept any positive integer literal. It is also possible to use a width term argument via DFSInt(width) . DFiant also support various types such as DFBits , DFUInt , and DFBool . All these dataflow variable construction options and more are discussed later in this documentation. The syntax val _name_ = _dataflow_variable_constructor_ <> _direction_ is used to construct a port and give it a named Scala reference. The Scala reference name will affect the name of this port when compiled to the required backend representation. Line 6 : The assignment operator := set the dataflow output port to receive input port values as they are. Line 9 : This object is an extension of a Scala App trait that creates a main entry point for the DFiant compilation program. By inheriting DFApp.VHDLCompiler[_top_] we also generate the top design and execute the compilation and commitment to VHDL files. Generated VHDL files observations The id.vhdl file is readable and maintains the names set in the DFiant design. The generated files follow various writing conventions such as capitalized port names and proper code alignment. The id_pkg.vhdl is a package file that is shared between all VHDL files generated by DFiant and contains common conversion functions that may be required. Additionally it may contain other definitions like enumeration types.","title":"Basic Example: An Identity Function"},{"location":"intro/first-look/#hierarchy-and-connection-example","text":"IDTop.scala 1 2 3 4 5 6 7 8 9 10 11 import DFiant._ @df class IDTop extends DFDesign { //This our `IDTop` dataflow design val x = DFSInt ( 16 ) <> IN //The input port is a signed 16-bit integer val y = DFSInt ( 16 ) <> OUT //The output port is a signed 16-bit integer val id1 = new ID //First instance of the `ID` design val id2 = new ID //Second instance of the `ID` design id1 . x <> x //Connecting parent input port to child input port id1 . y <> id2 . x //Connecting sibling instance ports id2 . y <> y //Connecting parent output port to child output port } IDTop.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.IDTop_pkg. all ; entity IDTop is port ( x : in signed ( 15 downto 0 ); y : out signed ( 15 downto 0 ) ); end IDTop ; architecture IDTop_arch of IDTop is signal id1_x : signed ( 15 downto 0 ); signal id1_y : signed ( 15 downto 0 ); signal id2_x : signed ( 15 downto 0 ); signal id2_y : signed ( 15 downto 0 ); begin id1 : entity work . ID ( ID_arch ) port map ( x => id1_x , y => id1_y ); id2 : entity work . ID ( ID_arch ) port map ( x => id2_x , y => id2_y ); async_proc : process ( all ) begin id1_x <= x ; id2_x <= id1_y ; y <= id2_y ; end process ; end IDTop_arch ; IDTop.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 `default_nettype none `timescale 1 ns / 1 ps `include \"IDTop_defs.v\" module IDTop ( input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); wire signed [ 15 : 0 ] id1_y ; wire signed [ 15 : 0 ] id2_y ; reg signed [ 15 : 0 ] id1_x ; reg signed [ 15 : 0 ] id2_x ; ID id1 ( . x ( id1_x ), . y ( id1_y ) ); ID id2 ( . x ( id2_x ), . y ( id2_y ) ); always @( * ) begin id1_x = x ; id2_x = id1_y ; y = id2_y ; end endmodule","title":"Hierarchy and Connection Example"},{"location":"intro/first-look/#finite-step-state-machine-fsm-example","text":"SeqDet.scala 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import DFiant._ @df class SeqDet extends DFDesign { val seqIn = DFBit () <> IN val detOut = DFBit () <> OUT @df def detStep ( out : Int , trueNS : => FSM , falseNS : => FSM ) : FSM = FSM { detOut := out ifdf ( seqIn ){ trueNS . goto () }. elsedf { falseNS . goto () } } val S0 : FSM = detStep ( 0 , S1 , S0 ) val S1 : FSM = detStep ( 0 , S1 , S10 ) val S10 : FSM = detStep ( 0 , S1 , S100 ) val S100 : FSM = detStep ( 0 , S1001 , S0 ) val S1001 : FSM = detStep ( 1 , S1 , S10 ) } SeqDet.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SeqDet_pkg. all ; entity SeqDet is port ( clk : in std_logic ; rst : in std_logic ; seqIn : in std_logic ; detOut : out std_logic ); end SeqDet ; architecture SeqDet_arch of SeqDet is type E_fsm_states is ( E_fsm_states_S0 , E_fsm_states_S1 , E_fsm_states_S10 , E_fsm_states_S100 , E_fsm_states_S1001 ); signal fsm_state_prev1 : E_fsm_states := E_fsm_states_S0 ; signal fsm_state_sig : E_fsm_states ; begin async_proc : process ( all ) variable fsm_state : E_fsm_states := E_fsm_states_S0 ; begin fsm_state := fsm_state_prev1 ; case fsm_state is when E_fsm_states_S0 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; when E_fsm_states_S10 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S100 ; end if ; when E_fsm_states_S100 => detOut <= '0' ; if seqIn = '1' then fsm_state := E_fsm_states_S1001 ; else fsm_state := E_fsm_states_S0 ; end if ; when E_fsm_states_S1001 => detOut <= '1' ; if seqIn = '1' then fsm_state := E_fsm_states_S1 ; else fsm_state := E_fsm_states_S10 ; end if ; end case ; fsm_state_sig <= fsm_state ; end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then fsm_state_prev1 <= E_fsm_states_S0 ; elsif rising_edge ( clk ) then fsm_state_prev1 <= fsm_state_sig ; end if ; end process ; end SeqDet_arch ; SeqDet.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 `default_nettype none `timescale 1 ns / 1 ps `include \"SeqDet_defs.v\" module SeqDet ( input wire clk , input wire rst , input wire seqIn , output reg detOut ); reg [ 2 : 0 ] fsm_state = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_prev1 = `E_fsm_states_S0 ; reg [ 2 : 0 ] fsm_state_sig ; `define E_fsm_states_S0 0 `define E_fsm_states_S1 1 `define E_fsm_states_S10 2 `define E_fsm_states_S100 3 `define E_fsm_states_S1001 4 always @( * ) begin fsm_state = fsm_state_prev1 ; case ( fsm_state ) `E_fsm_states_S0 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end `E_fsm_states_S10 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S100 ; end `E_fsm_states_S100 : begin detOut = 1 'b0 ; if ( seqIn ) fsm_state = `E_fsm_states_S1001 ; else fsm_state = `E_fsm_states_S0 ; end `E_fsm_states_S1001 : begin detOut = 1 'b1 ; if ( seqIn ) fsm_state = `E_fsm_states_S1 ; else fsm_state = `E_fsm_states_S10 ; end default : begin fsm_state = 3 ' b ??? ; detOut = 1 ' b ? ; end endcase fsm_state_sig = fsm_state ; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) fsm_state_prev1 <= `E_fsm_states_S0 ; else fsm_state_prev1 <= fsm_state_sig ; end endmodule","title":"Finite Step (State) Machine (FSM) Example"},{"location":"intro/first-look/#simple-moving-average","text":"In this simple moving average (SMA) example, the signed 16-bit input, \\(x\\)","title":"Simple Moving Average"},{"location":"intro/first-look/#no-feedback-implementation","text":"\\[ y_k=\\left(x_k+x_{k-1}+x_{k-2}+x_{k-3}\\right)/4 \\] SMA.scala 1 2 3 4 5 6 7 8 import DFiant._ @df class SMA extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val sum = ( x +^ x . prev ) +^ ( x . prev ( 2 ) +^ x . prev ( 3 )) y := ( sum >> 2 ). resize ( 16 ) } SMA.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_pkg. all ; entity SMA is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA ; architecture SMA_arch of SMA is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); begin async_proc : process ( all ) variable sum : signed ( 17 downto 0 ) := 18 d \"0\" ; begin sum := resize ( resize ( x , 17 ) + x_prev1 , 18 ) + ( resize ( x_prev2 , 17 ) + x_prev3 ); x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; y <= resize ( sum sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end if ; end process ; end SMA_arch ; SMA.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_defs.v\" module SMA ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 16 : 0 ] sum_part = 17 ' sd0 ; reg signed [ 17 : 0 ] sum = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; always @( * ) begin sum_part = ({ x [ 15 ], x [ 15 : 0 ]}) + x_prev1 ; sum = ({ sum_part [ 16 ], sum_part [ 16 : 0 ]}) + (({ x_prev2 [ 15 ], x_prev2 [ 15 : 0 ]}) + x_prev3 ); y_part = sum >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; end end endmodule","title":"No feedback implementation"},{"location":"intro/first-look/#feedback-implementation","text":"\\[\\begin{eqnarray} a_0 &=& 0 \\\\ a_k &=& a_{k-1} - x_{k-4}+x_k \\\\ y_k &=& a_k/4 \\end{eqnarray}\\] SMA_FB.scala 1 2 3 4 5 6 7 8 9 import DFiant._ @df class SMA_FB extends DFDesign { val x = DFSInt ( 16 ) <> IN init 0 val y = DFSInt ( 16 ) <> OUT val acc = DFSInt ( 18 ) init 0 acc := acc - x . prev ( 4 ) + x y := ( acc >> 2 ). resize ( 16 ) } SMA_FB.vhdl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; use work.SMA_FB_pkg. all ; entity SMA_FB is port ( clk : in std_logic ; rst : in std_logic ; x : in signed ( 15 downto 0 ) := 16 d \"0\" ; y : out signed ( 15 downto 0 ) ); end SMA_FB ; architecture SMA_FB_arch of SMA_FB is signal x_prev1 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev2 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev3 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal x_prev4 : signed ( 15 downto 0 ) := 16 d \"0\" ; signal acc_prev1 : signed ( 17 downto 0 ) := 18 d \"0\" ; signal x_prev1_sig : signed ( 15 downto 0 ); signal x_prev2_sig : signed ( 15 downto 0 ); signal x_prev3_sig : signed ( 15 downto 0 ); signal acc_sig : signed ( 17 downto 0 ); begin async_proc : process ( all ) variable acc : signed ( 17 downto 0 ) := 18 d \"0\" ; begin acc := acc_prev1 ; acc := ( acc - x_prev4 ) + x ; x_prev1_sig <= x_prev1 ; x_prev2_sig <= x_prev2 ; x_prev3_sig <= x_prev3 ; acc_sig <= acc ; y <= resize ( acc sra 2 , 16 ); end process ; sync_proc : process ( rst , clk ) begin if rst = '0' then x_prev1 <= 16 d \"0\" ; x_prev2 <= 16 d \"0\" ; x_prev3 <= 16 d \"0\" ; x_prev4 <= 16 d \"0\" ; acc_prev1 <= 18 d \"0\" ; elsif rising_edge ( clk ) then x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end if ; end process ; end SMA_FB_arch ; SMA_FB.v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 `default_nettype none `timescale 1 ns / 1 ps `include \"SMA_FB_defs.v\" module SMA_FB ( input wire clk , input wire rst , input wire signed [ 15 : 0 ] x , output reg signed [ 15 : 0 ] y ); reg signed [ 15 : 0 ] x_prev1 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev2 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev3 = 16 ' sd0 ; reg signed [ 15 : 0 ] x_prev4 = 16 ' sd0 ; reg signed [ 17 : 0 ] acc = 18 ' sd0 ; reg signed [ 17 : 0 ] acc_prev1 = 18 ' sd0 ; reg signed [ 17 : 0 ] y_part = 18 ' sd0 ; reg signed [ 15 : 0 ] x_prev1_sig ; reg signed [ 15 : 0 ] x_prev2_sig ; reg signed [ 15 : 0 ] x_prev3_sig ; reg signed [ 17 : 0 ] acc_sig ; always @( * ) begin acc = acc_prev1 ; acc = ( acc - x_prev4 ) + x ; y_part = acc >>> 2 ; x_prev1_sig = x_prev1 ; x_prev2_sig = x_prev2 ; x_prev3_sig = x_prev3 ; acc_sig = acc ; y = { y_part [ 17 ], y_part [ 14 : 0 ]}; end always @( negedge rst or posedge clk ) begin if ( rst == 1 'b0 ) begin x_prev1 <= 16 ' sd0 ; x_prev2 <= 16 ' sd0 ; x_prev3 <= 16 ' sd0 ; x_prev4 <= 16 ' sd0 ; acc_prev1 <= 18 ' sd0 ; end else begin x_prev1 <= x ; x_prev2 <= x_prev1_sig ; x_prev3 <= x_prev2_sig ; x_prev4 <= x_prev3_sig ; acc_prev1 <= acc_sig ; end end endmodule","title":"Feedback implementation"},{"location":"intro/first-look/#looks-cool-i-wish-to-know-more","text":"","title":"Looks cool! I wish to know more"},{"location":"user-guide/compilation/","text":"Compilation \ud83d\udd17","title":"Compilation"},{"location":"user-guide/compilation/#compilation","text":"","title":"Compilation"},{"location":"user-guide/meta/","text":"Meta Hardware Description \ud83d\udd17","title":"Meta Hardware Description"},{"location":"user-guide/meta/#meta-hardware-description","text":"","title":"Meta Hardware Description"},{"location":"user-guide/simulation/","text":"Simulation \ud83d\udd17","title":"Simulation"},{"location":"user-guide/simulation/#simulation","text":"","title":"Simulation"},{"location":"user-guide/state/","text":"State & Initialization \ud83d\udd17 Semantically, every DFiant dataflow variable references a token stream (TS). Unless stated otherwise, all dataflow variables are always consuming and always producing. Previous token initialization: The token history stream can be initialized. Initialization does not mutate the dataflow variable. Initialization has no effect on the TS. Only when using prev the initialization is placed on the TS reference. init returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. Bubble tokens (?) : Produced when a prev is called on a non-initialized dataflow variable. E.g., Code Init Token Stream in : DFUInt[32] ? 2, 3, 1, 5, 9 in.prev ? ?, 2, 3, 1, 5, 9 in.prev(2) ? ?, ?, 2, 3, 1, 5, 9 in.prev.prev ? ?, ?, 2, 3, 1, 5, 9 val in1 = in.init(1); in1 1 2, 3, 1, 5, 9 in1.prev 1 1, 2, 3, 1, 5, 9 in1.prev(2) 1 1, 1, 2, 3, 1, 5, 9 in1.prev.init(8) 8 1, 2, 3, 1, 5, 9 val innew = DFUInt(32) := in1; innew ? 2, 3, 1, 5, 9 val ins7 = in.init(7, ?); ins7 (7, ?) 2, 3, 1, 5, 9 ins7.prev ? 7, 2, 3, 1, 5, 9 val ins78 = in.init(7, 8, ?); ins78 (7, 8, ?) 2, 3, 1, 5, 9 ins78.prev (8, ?) 7, 2, 3, 1, 5, 9 ins78.prev(2) ? 8, 7, 2, 3, 1, 5, 9 in.init(7).prev.init(8, ?).prev ? 8, 7, 2, 3, 1, 5, 9 Bubbles are like any regular-value tokens in terms of consumption and production rules. Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue. Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., 1 2 3 def foo ( a : DFUInt ( 8 )) = a + a . prev //'in' is token stream of: 2, 3, 1, 5, 9 //'foo(in)' returns: ?, 5, 4, 6, 14 prev maintains Distributivity through basic operations e.g.: (a + b).prev \u2257 a.prev + b.prev (timeless TS equality). Code Init Token Stream inL : DFUInt(32) ? 2, 3, 1, 5, 9 inR : DFUInt(32) ? 4, 0, 2 inL + inR ? + ? = ? 2, 3, 1, 5, 9 + 4, 0, 2 = 6, 3, 3 inL + inR.prev ? + ? = ? 2, 3, 1, 5, 9 + ?, 4, 0, 2 = ?, 7, 1, 7 inL.init(1) + inR.init(3).prev 1 + 3 = 4 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1, ?) + inR.init(3).prev (1, ?) + 3 = (4, ?) 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1) + inR.init(3, ?).prev 1 + ? = ? 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1).prev + inR.init(3).prev 1 + 3 = 4 1, 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 4, 6, 3, 3 (inL.init(1) + inR.init(3)).prev 1 + 3 = 4 (2, 3, 1, 5, 9 + 4, 0, 2) .prev = 4, 6, 3, 3 Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags. Casting: Parts of a bits vector can be bubbles while others normal values. However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.","title":"State (Memory)"},{"location":"user-guide/state/#state-initialization","text":"Semantically, every DFiant dataflow variable references a token stream (TS). Unless stated otherwise, all dataflow variables are always consuming and always producing. Previous token initialization: The token history stream can be initialized. Initialization does not mutate the dataflow variable. Initialization has no effect on the TS. Only when using prev the initialization is placed on the TS reference. init returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. Bubble tokens (?) : Produced when a prev is called on a non-initialized dataflow variable. E.g., Code Init Token Stream in : DFUInt[32] ? 2, 3, 1, 5, 9 in.prev ? ?, 2, 3, 1, 5, 9 in.prev(2) ? ?, ?, 2, 3, 1, 5, 9 in.prev.prev ? ?, ?, 2, 3, 1, 5, 9 val in1 = in.init(1); in1 1 2, 3, 1, 5, 9 in1.prev 1 1, 2, 3, 1, 5, 9 in1.prev(2) 1 1, 1, 2, 3, 1, 5, 9 in1.prev.init(8) 8 1, 2, 3, 1, 5, 9 val innew = DFUInt(32) := in1; innew ? 2, 3, 1, 5, 9 val ins7 = in.init(7, ?); ins7 (7, ?) 2, 3, 1, 5, 9 ins7.prev ? 7, 2, 3, 1, 5, 9 val ins78 = in.init(7, 8, ?); ins78 (7, 8, ?) 2, 3, 1, 5, 9 ins78.prev (8, ?) 7, 2, 3, 1, 5, 9 ins78.prev(2) ? 8, 7, 2, 3, 1, 5, 9 in.init(7).prev.init(8, ?).prev ? 8, 7, 2, 3, 1, 5, 9 Bubbles are like any regular-value tokens in terms of consumption and production rules. Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue. Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., 1 2 3 def foo ( a : DFUInt ( 8 )) = a + a . prev //'in' is token stream of: 2, 3, 1, 5, 9 //'foo(in)' returns: ?, 5, 4, 6, 14 prev maintains Distributivity through basic operations e.g.: (a + b).prev \u2257 a.prev + b.prev (timeless TS equality). Code Init Token Stream inL : DFUInt(32) ? 2, 3, 1, 5, 9 inR : DFUInt(32) ? 4, 0, 2 inL + inR ? + ? = ? 2, 3, 1, 5, 9 + 4, 0, 2 = 6, 3, 3 inL + inR.prev ? + ? = ? 2, 3, 1, 5, 9 + ?, 4, 0, 2 = ?, 7, 1, 7 inL.init(1) + inR.init(3).prev 1 + 3 = 4 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1, ?) + inR.init(3).prev (1, ?) + 3 = (4, ?) 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1) + inR.init(3, ?).prev 1 + ? = ? 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 5, 7, 1, 7 inL.init(1).prev + inR.init(3).prev 1 + 3 = 4 1, 2, 3, 1, 5, 9 + 3, 4, 0, 2 = 4, 6, 3, 3 (inL.init(1) + inR.init(3)).prev 1 + 3 = 4 (2, 3, 1, 5, 9 + 4, 0, 2) .prev = 4, 6, 3, 3 Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags. Casting: Parts of a bits vector can be bubbles while others normal values. However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.","title":"State &amp; Initialization"},{"location":"user-guide/synthesis/","text":"Synthesis \ud83d\udd17","title":"Synthesis"},{"location":"user-guide/synthesis/#synthesis","text":"","title":"Synthesis"}]}