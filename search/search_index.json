{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DFiant HDL (DFHDL) Docs","text":"<p>The Official DFiant Hardware Description Language (DFHDL) Documentation</p> <p> </p> <p>Welcome to the DFiant hardware description language (DFHDL) documentation! </p> <p>DFHDL is a dataflow HDL and is embedded as a library in the Scala programming language. DFiant enables timing-agnostic and device-agnostic hardware description by using dataflow firing rules as logical constructs, coupled with modern software language features (e.g., inheritance, polymorphism, pattern matching) and classic HDL features (e.g., bit-accuracy, input/output ports). Additionally, DFHDL integrates two additional levels of hardware description abstractions: register-transfer (RT), which is equivalent to languages like Chisel and Amaranth; and event-driven (ED), which is equivalent to Verilog and VHDL. </p> <p> Get started</p> <p> Read more about the technology</p> <p> Run examples in your browser</p>"},{"location":"#documentation-status","title":"Documentation Status","text":"<p>We are actively working on a comprehensive user guide. We hope to be releasing it in the coming days.</p> <p>In the meanwhile, checkout our getting-started guide, to setup your system and try out a basic example. Additionally, we placed several examples under the Run In Browser section of the documentation, where you can try them right now.</p>"},{"location":"#required-knowledge","title":"Required Knowledge","text":"<p>You are not required to know Scala, yet you are expected to understand basic object oriented concepts. This documentation attempts to bridge over any syntactic gaps you may arrive at. Nonetheless, as you attempt to create more complex and generic designs, more Scala knowledge will be required of you.</p> <p>You are not required to be an FPGA/ASIC expert, yet you are expected to understand fundamental hardware description concepts found in languages such as Verilog and VHDL.  </p> <p>You are required to keep an open mind. Some of these concepts may seem strange at first, but they were set after careful thought and planning. However, we are not infallible so feel free to file an issue with questions and/or suggestions of different approaches we can take.</p>"},{"location":"about/LICENSE/","title":"License","text":"<p>Copyright (c) 2021 DFiant Inc.</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> GNU Lesser General Public License version 3 <pre><code>                    GNU LESSER GENERAL PUBLIC LICENSE\n                        Version 3, 29 June 2007\n\n  Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n  Everyone is permitted to copy and distribute verbatim copies\n  of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n    a) under this License, provided that you make a good faith effort to\n    ensure that, in the event an Application does not supply the\n    function or data, the facility still operates, and performs\n    whatever part of its purpose remains meaningful, or\n\n    b) under the GNU GPL, with none of the additional permissions of\n    this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n    a) Give prominent notice with each copy of the object code that the\n    Library is used in it and that the Library and its use are\n    covered by this License.\n\n    b) Accompany the object code with a copy of the GNU GPL and this license\n    document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n    a) Give prominent notice with each copy of the Combined Work that\n    the Library is used in it and that the Library and its use are\n    covered by this License.\n\n    b) Accompany the Combined Work with a copy of the GNU GPL and this license\n    document.\n\n    c) For a Combined Work that displays copyright notices during\n    execution, include the copyright notice for the Library among\n    these notices, as well as a reference directing the user to the\n    copies of the GNU GPL and this license document.\n\n    d) Do one of the following:\n\n        0) Convey the Minimal Corresponding Source under the terms of this\n        License, and the Corresponding Application Code in a form\n        suitable for, and under terms that permit, the user to\n        recombine or relink the Application with a modified version of\n        the Linked Version to produce a modified Combined Work, in the\n        manner specified by section 6 of the GNU GPL for conveying\n        Corresponding Source.\n\n        1) Use a suitable shared library mechanism for linking with the\n        Library.  A suitable mechanism is one that (a) uses at run time\n        a copy of the Library already present on the user's computer\n        system, and (b) will operate properly with a modified version\n        of the Library that is interface-compatible with the Linked\n        Version.\n\n    e) Provide Installation Information, but only if you would otherwise\n    be required to provide such information under section 6 of the\n    GNU GPL, and only to the extent that such information is\n    necessary to install and execute a modified version of the\n    Combined Work produced by recombining or relinking the\n    Application with a modified version of the Linked Version. (If\n    you use option 4d0, the Installation Information must accompany\n    the Minimal Corresponding Source and Corresponding Application\n    Code. If you use option 4d1, you must provide the Installation\n    Information in the manner specified by section 6 of the GNU GPL\n    for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n    a) Accompany the combined library with a copy of the same work based\n    on the Library, uncombined with any other library facilities,\n    conveyed under the terms of this License.\n\n    b) Give prominent notice with the combined library that part of it\n    is a work based on the Library, and explaining where to find the\n    accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n</code></pre>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>We would like to thank the opensource community, namely the Scala community, and great many others for their work and support!</p> Previous version EU support <p>Previous version of this work (simply called \"DFiant\" at the time) has been supported by EU H2020 ICT project LEGaTO, contract #780681.</p> <p></p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>We will most likely adopt the code of conduct of Django. </p> <p>This page will be updated soon.</p> <p>Our Stance on Opensource</p> <p>We are standing on the shoulders of giants, so lets at least wipe down our feet first.   Be kind, be respectful, and take no-one and nothing for granted.</p>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#v010","title":"v0.1.0","text":"<p>This is the first official version release of DFiant.</p>"},{"location":"getting-started/hello-world/","title":"Hello Hardware World","text":""},{"location":"getting-started/hello-world/#the-basic-dfhdl-program","title":"The Basic DFHDL Program","text":"<p>Since DFHDL is a Scala library, we are creating a Scala program that takes DFHDL designs and compiles (transpiles) them into lower representations (e.g., VHDL or Verilog). As such, some of DFHDL's compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. The Scala code below describes a program that runs the DFHDL compiler on an 8-bit overlapping counter design, <code>Counter8</code>. </p> <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> <p>Writing a DFHDL compilation program \u2013 as easy as 01-10-11!</p> <ol> <li><code>import dfhdl.*</code> once per source file, to import all the required namespace objects, types, and functionality.</li> <li><code>class _design_name_ extends RTDesign:</code> to define your register-transfer (RT) domain design. Populate your design with the required interface and functionality. DFHDL supports two additional design domains: dataflow (DF), and event-driven (ED).</li> <li>Add <code>@top</code> annotation to your top-level design (e.g., <code>@top class top_design_name_ ...</code>) to automatically create a compilation program entry point for the design, instantiate it, elaborate it, compile it to Verilog or VHDL (see compiler options), and finally commit the files to disk.</li> </ol>"},{"location":"getting-started/hello-world/#run-it-in-your-browser","title":"Run It In Your Browser","text":"Run it here <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> <p>For more examples that are available to run in your browser, see the relevant section.</p>"},{"location":"getting-started/hello-world/#run-it-on-your-system","title":"Run It On Your System","text":"<p>To run this example on your system, make sure to first follow the initial setup instructions.</p> <p>You have several options to run Scala programs on your system:</p> <ul> <li>For this simple <code>Counter8</code> example, you can just use the simplest scala-single-file approach. </li> <li>For common DFHDL projects, we recommend using the scala project approach. </li> <li>For complex, full-production DFHDL projects, you may need to use an sbt project, but this is usually not required.</li> </ul>"},{"location":"getting-started/hello-world/#scala-single-file","title":"Scala Single File","text":"View the scala single file example Counter8.scala<pre><code>//&gt; using scala 3.7.1\n//&gt; using dep io.github.dfianthdl::dfhdl::0.11.0\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.11.0\n//&gt; using option -deprecation -language:implicitConversions\n\nimport dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> Download and run in your terminal<pre><code>curl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-single-file/Counter8.scala\nscala run ./Counter8.scala\n</code></pre> <p>For more information, please run <code>scala run --help</code> or consult the online documentation.</p>"},{"location":"getting-started/hello-world/#scala-project","title":"Scala Project","text":"View the scala project files example projectFolder/project.scala<pre><code>//&gt; using scala 3.7.1\n//&gt; using dep io.github.dfianthdl::dfhdl::0.11.0\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.11.0\n//&gt; using option -deprecation -language:implicitConversions\n</code></pre> projectFolder/Counter8.scala<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\n@top class Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintBackendCode = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre> Download and run in your terminal<pre><code>curl -o project.scala https://dfianthdl.github.io/getting-started/hello-world/scala-project/project.scala\ncurl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-project/Counter8.scala\nscala run .\n</code></pre> <p>For more information, please run <code>scala run --help</code> or consult the online documentation.</p>"},{"location":"getting-started/hello-world/#sbt-project","title":"sbt Project","text":"<p>The best way to get started with a DFHDL sbt project is to clone our template from GitHub:</p> Clone and run in your terminal<pre><code>git clone https://github.com/DFiantHDL/dfhdl-template\ncd dfhdl-template\nsbt run\n</code></pre> <p>For more information, please consult the sbt documentation.</p>"},{"location":"getting-started/hello-world/#recommended-scala-formatting-for-dfhdl","title":"Recommended Scala Formatting for DFHDL","text":"<p>We recommend actively using Scalafmt, a code formatter for Scala that integrates well with your toolchain. The following setting is recommended for DFHDL designs:</p> View the Scalafmt recommended configuration file projectFolder/.scalafmt.conf<pre><code>version = 3.9.8\nrunner.dialect = scala3\n\nmaxColumn = 100\nalign.tokens = [{code = \"&lt;&gt;\"}, {code = \"=\"}, {code = \"=&gt;\"}, {code = \":=\"}, {code = \":==\"}]\nrewrite.scala3.removeOptionalBraces = oldSyntaxToo\nrewrite.scala3.insertEndMarkerMinLines = 15\n\nbinPack.literalArgumentLists = true\nbinPack.literalsMinArgCount = 5\nbinPack.literalsInclude = [\".*\"]\nbinPack.literalsIncludeSimpleExpr = true\nbinPack.literalsSingleLine = false\n\nnewlines.selectChains = keep\n</code></pre> Download it via your terminal<pre><code>curl -o .scalafmt.conf https://dfianthdl.github.io/getting-started/hello-world/scala-project/.scalafmt.conf\n</code></pre> <p>For more information, please consult the Scalafmt documentation.</p>"},{"location":"getting-started/initial-setup/","title":"Initial Setup","text":"<p>DFHDL is a domain specific language (DSL) library written in the Scala programming language (Scala 3.7.1), and as such it lets you utilize the entire Scala ecosystem, including IDEs, various tools, and other libraries. </p> <p>Is your system already fit for Scala development? Jump to the DFHDL hello-world section</p>"},{"location":"getting-started/initial-setup/#installing-scala-and-other-dependencies","title":"Installing Scala and Other Dependencies","text":"<p>We recommend directly installing Scala 3.7.1 (no need to install either Coursier, Scala CLI, or sbt):</p> <ul> <li> <p> Windows Instructions</p> Using Chocolatey <p>Run the following in Windows command or powershell:</p> <pre><code>choco install scala --version=3.7.1 \n</code></pre> </li> <li> <p> Linux Instructions</p> Using SDKMAN! <p>Run the following in your shell:</p> <pre><code>sdk install scala 3.7.1 \n</code></pre> </li> <li> <p> macOS Instructions</p> Using Homebrew <p>Run the following in your shell:</p> <pre><code>brew update\nbrew install scala\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>If for some reason the instructions above don't work for you, you can try to install Scala via Coursier using the information below.</p> </li> </ul> Installing Scala via Coursier <p>We recommend directly installing Scala, as instructed above. However, if you are experiencing issues, you can try installing Scala via Coursier, as follows:</p> <ul> <li> <p> Windows Instructions</p> ManualCMDPowershell <ol> <li> <p>Download the installer zip file.</p> </li> <li> <p>Open the zip.</p> </li> <li> <p>Double click the <code>cs-x86_64-pc-win32.exe</code> executable to extract and run Coursier setup.</p> </li> </ol> <p>Run the following in Windows command:</p> <pre><code>curl -fLo cs-x86_64-pc-win32.zip https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\ntar -xf cs-x86_64-pc-win32.zip\nmove cs-x86_64-pc-win32.exe cs.exe\n.\\cs setup\n</code></pre> <p>Run the following in Windows Powershell:</p> <pre><code>Invoke-WebRequest -Uri \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\" -OutFile \"cs-x86_64-pc-win32.zip\"\nExpand-Archive -Path \"cs-x86_64-pc-win32.zip\"\nRename-Item -Path \"cs-x86_64-pc-win32.exe\" -NewName \"cs.exe\"\nRemove-Item -Path \"cs-x86_64-pc-win32.zip\"\n.\\cs setup\n</code></pre> </li> <li> <p> Linux Instructions</p> x86-64 (aka AMD64)ARM64Other linux <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p> Goto Coursier's website</p> </li> <li> <p> macOS Instructions</p> via Brewaarch64 (M1,M2,...)x86-64 <p>Run the following in your shell:</p> <pre><code>brew install coursier/formulas/coursier\ncs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/coursier/launchers/raw/master/cs-x86_64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>For other OS or instructions please consult the Coursier website.</p> <p> Goto Coursier's website</p> </li> </ul>"},{"location":"getting-started/initial-setup/#ide-setup","title":"IDE Setup","text":"<p>Many IDEs support Scala development. The most popular are VS Code and IntelliJ IDEA. We recommend VS Code with the Metals plugin.</p> <p>Here is a summary of relevant IDEs:</p> <ul> <li> <p> VS Code (Recommended)</p> <p> Download VS Code</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> IntelliJ IDEA</p> <p> Download IntelliJ via ToolBox</p> <p> Scala Development Guide</p> </li> <li> <p> Vim</p> <p> Download Vim</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Sublime Text</p> <p> Download Sublime Text</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Emacs</p> <p> Download Emacs</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Other IDE/Instructions</p> <p> For other OS or instructions please consult the Metals website.</p> </li> </ul>"},{"location":"in-browser/1-bit-full-adder/","title":"1-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; a ^ b ^ c_in\n  c_out &lt;&gt; a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/alu/","title":"ALU","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nenum ALUSel extends Encoded:\n  case ADD, SUB, SLL, SRL, SRA, AND, OR, XOR, SLT, SLTU, COPY1\n\n@top class ALU extends DFDesign:\n  val op1    = Bits(32) &lt;&gt; IN\n  val op2    = Bits(32) &lt;&gt; IN\n  val aluSel = ALUSel   &lt;&gt; IN\n  val aluOut = Bits(32) &lt;&gt; OUT\n\n  private val shamt = op2(4, 0)\n\n  import ALUSel.*\n  aluOut := aluSel match\n    case ADD   =&gt; op1 + op2\n    case SUB   =&gt; op1 - op2\n    case AND   =&gt; op1 &amp; op2\n    case OR    =&gt; op1 | op2\n    case XOR   =&gt; op1 ^ op2\n    case SLT   =&gt; (op1.sint &lt; op2.sint).extend\n    case SLTU  =&gt; (op1 &lt; op2).extend\n    case SLL   =&gt; op1 &lt;&lt; shamt\n    case SRL   =&gt; op1 &gt;&gt; shamt\n    case SRA   =&gt; (op1.sint &gt;&gt; shamt).bits\n    case COPY1 =&gt; op1\n    case _     =&gt; ?\nend ALU\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/counter/","title":"Counter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class Counter(val width: Int &lt;&gt; CONST = 8) extends RTDesign:\n  val en  = Bit         &lt;&gt; IN\n  val cnt = UInt(width) &lt;&gt; OUT.REG init 0\n  if (en)\n    cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/led-blinker/","title":"LED Blinker","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** This is a led blinker */\n@top class Blinker(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST = 50000,\n    val LED_FREQ_Hz: Int &lt;&gt; CONST  = 1\n) extends RTDesign:\n  /** Half-count of the toggle for 50% duty cycle */\n  val HALF_PERIOD = (CLK_FREQ_KHz * 1000) / (LED_FREQ_Hz * 2)\n\n  /** LED output */\n  val led = Bit                     &lt;&gt; OUT.REG init 1\n  val cnt = UInt.until(HALF_PERIOD) &lt;&gt; VAR.REG init 0\n  if (cnt == HALF_PERIOD - 1)\n    cnt.din := 0\n    led.din := !led\n  else cnt.din := cnt + 1\nend Blinker\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/lfsr/","title":"LFSR","text":"<pre><code>import dfhdl.*\n\nenum Ctrl extends Encode:\n  case Idle, Seed, Run\n\n/** Galois Linear-Feedback Shift Register\n  */\nclass LFSR(val taps: Bits[Int] &lt;&gt; CONST) extends RTDesign:\n  val ctrl = Ctrl &lt;&gt; IN\n  val seed = Bits(taps.width) &lt;&gt; IN\n  val calc = Bits(taps.width) &lt;&gt; OUT init all(1)\n\n  import Ctrl.*\n  ctrl match\n    case Idle =&gt; // do nothing\n    case Seed =&gt;\n      if (seed == all(0)) calc := all(1)\n      else calc := seed\n    case Run =&gt;\n      val tap = if (calc.reg(1)(0)) taps else b\"${taps.width}'0\"\n      calc := (calc.reg &gt;&gt; 1) ^ tap\nend LFSR</code></pre>"},{"location":"in-browser/n-bit-full-adder/","title":"N-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nclass FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; a ^ b ^ c_in\n  c_out &lt;&gt; a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a\n\n@top class FullAdderN(val n: Int = 4) extends EDDesign:\n  val a, b  = Bits(n) &lt;&gt; IN\n  val c_in  = Bit     &lt;&gt; IN\n  val sum   = Bits(n) &lt;&gt; OUT\n  val c_out = Bit     &lt;&gt; OUT\n\n  val adder = List.fill(n)(FullAdder1())\n  // to use a pure Scala range loop, import this flag\n  import hw.flag.scalaRanges\n  for (i &lt;- 0 until n)\n    adder(i).a   &lt;&gt; a(i)\n    adder(i).b   &lt;&gt; b(i)\n    adder(i).sum &lt;&gt; sum(i)\n    if (i &lt; n - 1)\n      adder(i).c_out &lt;&gt; adder(i + 1).c_in\n  adder.head.c_in  &lt;&gt; c_in\n  adder.last.c_out &lt;&gt; c_out\nend FullAdderN\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/reg-file/","title":"Register File","text":"<pre><code>import dfhdl.*\n\n@top class RegFile(\n    val DATA_WIDTH: Int &lt;&gt; CONST = 32,\n    val REG_NUM: Int &lt;&gt; CONST    = 32\n) extends RTDesign:\n  val regs = Bits(DATA_WIDTH) X REG_NUM &lt;&gt; VAR.REG\n\n  val rs1, rs2 = new RelatedDomain:\n    val addr = Bits.until(REG_NUM) &lt;&gt; IN\n    val data = Bits(DATA_WIDTH)    &lt;&gt; OUT.REG\n    data.din := regs(addr)\n\n  val rd = new RelatedDomain:\n    val addr = Bits.until(REG_NUM) &lt;&gt; IN\n    val data = Bits(DATA_WIDTH)    &lt;&gt; IN\n    val wren = Bit                 &lt;&gt; IN\n    if (wren) regs(addr).din := data\n    regs(0).din              := all(0) // in RISC-V x0 is always 0\nend RegFile\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/true-dpr/","title":"True Dual-Port RAM","text":"<pre><code>import dfhdl.*\n\n@top class TrueDPR(\n    val DATA_WIDTH: Int &lt;&gt; CONST = 8,\n    val ADDR_WIDTH: Int &lt;&gt; CONST = 8\n) extends EDDesign:\n  val ram = Bits(DATA_WIDTH) X (2 ** ADDR_WIDTH) &lt;&gt; VAR.SHARED\n\n  val a, b = new RTDomain:\n    val data = Bits(DATA_WIDTH) &lt;&gt; IN\n    val addr = Bits(ADDR_WIDTH) &lt;&gt; IN\n    val q    = Bits(DATA_WIDTH) &lt;&gt; OUT.REG\n    val we   = Bit              &lt;&gt; IN\n\n    if (we)\n      ram(addr) := data\n    q.din       := ram(addr)\nend TrueDPR\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"in-browser/uart-tx/","title":"UART Transmitter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n@top class UART_Tx(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST  = 50000,\n    val BAUD_RATE_BPS: Int &lt;&gt; CONST = 115200\n) extends RTDesign:\n  val data_en    = Bit             &lt;&gt; IN\n  val DATA_BITS  = 8\n  val data       = Bits(DATA_BITS) &lt;&gt; IN\n  val tx         = Bit             &lt;&gt; OUT.REG\n  val tx_en      = Bit             &lt;&gt; OUT.REG\n  val tx_done    = Bit             &lt;&gt; OUT.REG\n  val BIT_CLOCKS = CLK_FREQ_KHz * 1000 / BAUD_RATE_BPS\n\n  enum Status extends Encoded.OneHot:\n    case Idle, StartBit, DataBits, StopBit, Finalize\n  import Status.*\n  val status     = Status                 &lt;&gt; VAR.REG init Idle\n  val bitClkCnt  = UInt.until(BIT_CLOCKS) &lt;&gt; VAR.REG init 0\n  val dataBitCnt = UInt.until(DATA_BITS)  &lt;&gt; VAR.REG init 0\n  val shiftData  = Bits(DATA_BITS)        &lt;&gt; VAR.REG\n\n  // To save on writing the \"bit clock count wait\" 3 times,\n  // we use DFHDL's meta-programming capability.\n  @internals.metaContextIgnore\n  def waitBitAndThen(onThreshold: =&gt; Unit): Unit =\n    if (bitClkCnt == BIT_CLOCKS - 1)\n      bitClkCnt.din := 0\n      onThreshold\n    else bitClkCnt.din := bitClkCnt + 1\n\n  status match\n    case Idle =&gt;\n      tx_en.din      := 0\n      tx.din         := 1\n      tx_done.din    := 0\n      bitClkCnt.din  := 0\n      dataBitCnt.din := 0\n      if (data_en)\n        shiftData.din := data\n        status.din    := StartBit\n\n    case StartBit =&gt;\n      tx_en.din := 1\n      tx.din    := 0\n      waitBitAndThen { status.din := DataBits }\n\n    case DataBits =&gt;\n      tx.din := shiftData.lsbit\n      waitBitAndThen {\n        shiftData.din := shiftData &gt;&gt; 1\n        if (dataBitCnt == DATA_BITS - 1)\n          dataBitCnt.din := 0\n          status.din     := StopBit\n        else dataBitCnt.din := dataBitCnt + 1\n      }\n\n    case StopBit =&gt;\n      tx.din := 1\n      waitBitAndThen {\n        tx_done.din := 1\n        status.din  := Finalize\n      }\n\n    case Finalize =&gt;\n      tx_en.din   := 0\n      tx_done.din := 1\n      status.din  := Idle\n  end match\nend UART_Tx\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Elaboration Options:                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Uncomment to set different clock and reset configurations:\n// given options.ElaborationOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.ElaborationOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Select backend compiler:\ngiven options.CompilerOptions.Backend = backends.verilog\n// Uncomment to enable printing design code after elaboration (before compilation):\n// given options.ElaborationOptions.PrintDFHDLCode = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDFHDLCode = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n</code></pre>"},{"location":"intro/technology/","title":"The DFiant Technology","text":"<p>DFiant navigates the complexities of hardware design with a nuanced approach that addresses the limitations of traditional methods. The register-transfer level (RTL) abstraction, while precise, often shifts the design focus from the \"what\" of functionality to the \"how\" of implementation. This subtle yet significant distinction restricts design flexibility, making it challenging to optimize for external constraints like performance or power without compromising on tool automation capabilities. The detailed nature of RTL leads to complex, verbose coding, and extended simulation time. Although such granularity of control is sometimes necessary, it often exceeds the requirements of many applications.</p> <p>Conversely, High-Level Synthesis (HLS) tools offer an abstraction that simplifies hardware design, particularly for those without a background in hardware engineering. By utilizing familiar programming languages and incorporating auto-pipelining and optimization, HLS makes hardware acceleration more accessible. However, the inherent sequential semantics of these languages can obstruct the development of parallel hardware architectures, making it especially challenging to describe processors or synchronous interfaces.</p> <p>A newer category, High-Level RTLs (HL-RTLs), such as Chisel and Amaranth, aims to bridge these gaps. Embedded within popular programming languages as domain-specific languages (DSLs), these HL-RTLs introduce innovative constructs for hardware generation. However, despite these significant advancements, they remain anchored to the RTL model, which can restrict implementation flexibility. Furthermore, their level of abstraction does not fully support the verification capabilities found in VHDL and Verilog, which benefit from event-driven semantics.</p> <p>DFiant attempts to introduce an optimal middle ground, which covers key HDL technologies across dimensions of both control and productivity (sort of \"have the cake and it it too\").</p>"},{"location":"intro/technology/#the-dataflow-hardware-description-abstraction","title":"The Dataflow Hardware Description Abstraction","text":"<p>At the heart of DFiant's innovation is the dataflow hardware description abstraction, a paradigm shift from the traditional RTL model. Instead of relying on wires and registers, dataflow abstraction employs streams of data tokens. This fundamental difference explains why RTL is inherently tied to device specifications and timing constraints, whereas dataflow abstraction remains neutral to such parameters.</p> <p> </p> <p>In RTL design, designers are tasked with specifying the exact operations that occur in each clock cycle, closely aligning the design with the physical timing of the hardware. Dataflow abstraction, on the other hand, focuses on the sequence of operations based on data dependencies, without mandating when each operation should start or finish within the clock cycles. This distinction allows operations in the dataflow model to be free from the rigid timing of clock cycles, granting compilers in the toolchain greater flexibility to schedule operations and effectively pipeline the design.</p> <p>Moreover, RTL design often requires the strategic placement of registers for various functions, anchoring the design to specific timing requirements. We categorize register use in RTL into three primary functions: backend synchronization, interface synchronization, and intrinsic design functionality, such as state management. The figure above illustrates the diverse applications of registers within RTL designs. Unlike RTL, where registers are uniformly represented, dataflow abstraction introduces unique language constructs or constraints for each register type. This differentiation enables the DFHDL compiler to distinguish between registers integral to the function and those necessary for implementation, providing subsequent design stages valuable insights for optimization. In contrast, RTL often relies on comments within the code to convey this information, if it is documented at all.</p>"},{"location":"intro/technology/#three-design-domain-abstractions-within-a-single-hdl","title":"Three Design Domain Abstractions within a Single HDL","text":"<p>DFHDL stands out by offering a comprehensive integration of three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in Figure 4. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p> </p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through a carefully constructed compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p>A standout feature of DFHDL is its ability to regenerate the code in DFHDL syntax at any point in the compilation process, including intermediate stages. This transparency offers developers valuable insights into each step of the optimization or compilation, a stark contrast to many HLS tools that produce hard-to-interpret code, leaving developers to decipher the underlying processes in case of issues.</p>"},{"location":"intro/technology/#more-details","title":"More Details","text":"<p>For more details on motivation, you can read this position paper.</p>"},{"location":"transitioning/from-verilog/","title":"Transitioning from Verilog to DFHDL","text":""},{"location":"transitioning/from-verilog/#using-chatgpt","title":"Using ChatGPT","text":"<p>Help me ChatGPT, you're my only hope</p>"},{"location":"transitioning/from-verilog/#summary","title":"Summary","text":"<p>Module Definition</p> Verilog<pre><code>module _module_name_ #(\n  //param declarations\n) (\n  //port declarations\n);\n  //internal declarations\nendmodule\n</code></pre> DFHDL<pre><code>class _design_name_(\n  //param declarations\n) extends EDDesign:\n  //port &amp; internal declarations\n\n\nend _design_name_ //optional\n</code></pre> Verilog<pre><code>module AndGate (\n  input a, b;\n  output o\n);\n  assign o = a &amp; b\nendmodule\n</code></pre> DFHDL<pre><code>class AndGate extends EDDesign:\n  val a, b = Bit &lt;&gt; IN\n  val o    = Bit &lt;&gt; OUT\n\n  o &lt;&gt; a &amp;&amp; b\nend AndGate\n</code></pre> <p>Parameter Declarations</p> Verilog<pre><code>parameter [7:0] p = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val p: Bits[8] &lt;&gt; CONST = b\"8'1011\"\n</code></pre> Verilog<pre><code>module Concat #(\n  parameter  int len1;\n  parameter  int len2;\n  localparam int outlen = len1 + len2\n) (\n  input  [len1-1:0]   i1;\n  input  [len2-1:0]   i2;\n  output [outlen-1:0] o\n);\n  assign o = {i1, i2};\nendmodule\n</code></pre> DFHDL<pre><code>class Concat(\n    val len1: Int &lt;&gt; CONST\n    val len2: Int &lt;&gt; CONST\n) extends EDDesign:\n  val outlen = len1 + len2\n  val i1 = Bits(len1)   &lt;&gt; IN\n  val i2 = Bits(len2)   &lt;&gt; IN\n  val o  = Bits(outlen) &lt;&gt; OUT\n\n  o &lt;&gt; (i1, i2)\nend Concat\n</code></pre> <p>logic/reg/wire</p> Verilog<pre><code>logic [7:0] v = 8\u2019b1011;\nwire  [7:0] v = 8\u2019b1011;\nreg   [7:0] v = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val v = Bits(8) &lt;&gt; VAR init b\"8'1011\"\n</code></pre>"},{"location":"user-guide/compilation/","title":"Compilation","text":""},{"location":"user-guide/compilation/#elaboration","title":"Elaboration","text":""},{"location":"user-guide/conditionals/","title":"Conditionals","text":"<p>DFHDL supports two main types of conditional constructs: <code>if</code> expressions and <code>match</code> expressions. Both can be used for control flow and value selection in hardware designs.</p>"},{"location":"user-guide/conditionals/#if-expressions","title":"If Expressions","text":""},{"location":"user-guide/conditionals/#basic-syntax","title":"Basic Syntax","text":"<pre><code>if (condition) consequent\nelse alternative\n</code></pre> <ul> <li><code>condition</code> must be a DFHDL <code>Boolean</code> or <code>Bit</code> value</li> <li><code>consequent</code> and <code>alternative</code> are the code blocks executed based on the condition</li> <li>The <code>else</code> clause is optional</li> </ul>"},{"location":"user-guide/conditionals/#examples","title":"Examples","text":"<pre><code>// Basic if-else\nif (enable) \n  output := input\nelse \n  output := 0\n\n// Chained if-else\nif (state == State.Idle) \n  output := 0\nelse if (state == State.Active) \n  output := input\nelse \n  output := lastValue\n\n// If without else\nif (reset) \n  counter := 0\n</code></pre>"},{"location":"user-guide/conditionals/#rules","title":"Rules","text":"<ol> <li>Type Consistency: Both branches must produce compatible types if used as an expression</li> <li>Scope: Variables declared inside if blocks are only visible within that block</li> <li>Hardware Generation: Each branch generates hardware - both paths exist in parallel</li> <li>Constant Conditions: If conditions are constant, unused branches may be optimized out during elaboration</li> </ol>"},{"location":"user-guide/conditionals/#match-expressions","title":"Match Expressions","text":"<p>Match expressions provide pattern matching capabilities similar to Scala's match expressions but optimized for hardware description.</p>"},{"location":"user-guide/conditionals/#basic-syntax_1","title":"Basic Syntax","text":"<pre><code>value match\n  case pattern1 =&gt; expression1\n  case pattern2 =&gt; expression2\n  case _ =&gt; defaultExpression\n</code></pre>"},{"location":"user-guide/conditionals/#pattern-types","title":"Pattern Types","text":"<ol> <li> <p>Literal Patterns: <pre><code>x match\n  case 0 =&gt; y := 0\n  case 1 =&gt; y := 1\n  case _ =&gt; y := x\n</code></pre></p> </li> <li> <p>Multiple Values: <pre><code>x match\n  case 1 | 2 | 4 =&gt; y := 0\n  case 3 | 5 | 6 =&gt; y := 1\n  case _ =&gt; y := 2\n</code></pre></p> </li> <li> <p>Struct Patterns: <pre><code>pixel match\n  case Pixel(0, y) =&gt; output := y\n  case Pixel(x, 0) =&gt; output := x\n  case Pixel(x, y) =&gt; output := x + y\n</code></pre></p> </li> <li> <p>Guard Patterns: <pre><code>x match\n  case n if n &gt; 10 =&gt; y := 1\n  case n if n &lt; 0  =&gt; y := 0\n  case _           =&gt; y := x\n</code></pre></p> </li> <li> <p>Bit Patterns with Wildcards: <pre><code>bits match\n  case b\"1??0\" =&gt; y := 1\n  case b\"0??1\" =&gt; y := 0\n  case _       =&gt; y := x\n</code></pre></p> </li> <li> <p>Bit Extractor Patterns: <pre><code>// Match and extract a 32-bit section between DEAD and BEEF\ny match\n  case h\"DEAD${secret: B[32]}BEEF\" =&gt; \n    // Use extracted secret bits\n\n// Extract multiple sections\ny match\n  case h\"DE${part1: B[16]}AD${part2: B[16]}BEEF\" =&gt;\n    // Use part1 and part2 bits\n\n// Store extracted bits in variables\nval h\"DEAD${extracted: B[32]}BEEF\" = input: @unchecked\n\n// Extract multiple sections into variables\nval h\"DE${first: B[16]}ADBE${second: B[16]}EF\" = input: @unchecked\n\n// Using guards with extracted bit fields\ny match\n  case h\"DEAD${secret: B[32]}BEEF\" if secret &gt; h\"20000000\" =&gt;\n    // Match when the secret section is greater than 0x20000000\n  case h\"DE${part1: B[16]}AD${part2: B[16]}BEEF\" if part1 == h\"FFFF\" =&gt;\n    // Match when part1 is all ones\n</code></pre></p> </li> </ol> <p>Bit extractor patterns allow you to: - Match specific bit patterns while extracting variable sections - Use hex or binary notation for the fixed parts - Specify the width of extracted sections using <code>B[width]</code> syntax - Store extracted bits in variables for later use - Extract multiple sections in a single pattern match - Use guards to add conditions on extracted bit fields</p>"},{"location":"user-guide/conditionals/#match-to-if-conversion","title":"Match to If Conversion","text":"<p>During compilation, match expressions are typically converted to if-else chains for hardware implementation. For example:</p> <pre><code>// Original match\nx match\n  case 22           =&gt; y := 0\n  case 11 | 33 | 44 =&gt; y := 1\n  case _ if x == 55 =&gt; y := 2\n  case _            =&gt; y := 3\n\n// Converts to\nif (x == sd\"16'22\") \n  y := sd\"16'0\"\nelse if ((x == sd\"16'11\") || (x == sd\"16'33\") || (x == sd\"16'44\")) \n  y := sd\"16'1\"\nelse if (x == sd\"16'55\") \n  y := sd\"16'2\"\nelse \n  y := sd\"16'3\"\n</code></pre>"},{"location":"user-guide/conditionals/#complex-selectors","title":"Complex Selectors","text":"<p>When using expressions as match selectors, a temporary variable is created:</p> <pre><code>// Original\n(x + 1) match\n  case 22 =&gt; y := 0\n  case _  =&gt; y := 1\n\n// Converts to\nval match_sel = x + sd\"16'1\"\nif (match_sel == sd\"16'22\") \n  y := sd\"16'0\"\nelse \n  y := sd\"16'1\"\n</code></pre>"},{"location":"user-guide/conditionals/#rules_1","title":"Rules","text":"<ol> <li>Exhaustiveness: Match expressions must cover all possible cases</li> <li>Pattern Order: Patterns are evaluated in order, first match wins</li> <li>Type Safety: All case branches must produce compatible types if used as an expression</li> <li>Hardware Implementation: </li> <li>Converts to if-else chains for most cases</li> <li>Optimizes bit pattern matching into efficient comparisons</li> <li>Extracts struct fields into temporary variables when needed</li> </ol>"},{"location":"user-guide/conditionals/#best-practices","title":"Best Practices","text":"<ol> <li>Use Match for Multi-Way Branching: When dealing with multiple cases, match is often clearer than nested if-else</li> <li>State Machines: Match expressions are ideal for state machine implementations</li> <li>Pattern Priority: Put more specific patterns before general ones</li> <li>Wildcards: Use <code>_</code> for catch-all cases</li> <li>Guards: Use sparingly as they may generate more complex hardware</li> </ol>"},{"location":"user-guide/conditionals/#hardware-implications","title":"Hardware Implications","text":"<p>Both <code>if</code> and <code>match</code> expressions generate multiplexer circuits in hardware. The choice between them should consider:</p> <ol> <li>Readability: Match expressions are often clearer for multiple cases</li> <li>Hardware Efficiency: Simple if-else may generate simpler hardware</li> <li>Timing: Complex conditions may impact critical paths</li> <li>Resource Usage: Each branch generates hardware, even if mutually exclusive</li> </ol>"},{"location":"user-guide/conditionals/#examples_1","title":"Examples","text":""},{"location":"user-guide/conditionals/#state-machine","title":"State Machine","text":"<pre><code>class StateMachine extends RTDesign:\n  val state = State &lt;&gt; VAR.REG init State.Idle\n\n  state match\n    case State.Idle =&gt;\n      if (start) state := State.Active\n    case State.Active =&gt;\n      if (done) state := State.Idle\n</code></pre>"},{"location":"user-guide/conditionals/#decoder","title":"Decoder","text":"<pre><code>class Decoder extends DFDesign:\n  val input = UInt(4) &lt;&gt; IN\n  val output = Bits(16) &lt;&gt; OUT\n\n  output := input match\n    case 0  =&gt; b\"0001\"\n    case 1  =&gt; b\"0010\"\n    case 2  =&gt; b\"0100\"\n    case _ =&gt; b\"0000\"\n</code></pre>"},{"location":"user-guide/conditionals/#complex-pattern-matching","title":"Complex Pattern Matching","text":"<pre><code>class PixelProcessor extends DFDesign:\n  val pixel = Pixel &lt;&gt; IN\n  val result = UInt(8) &lt;&gt; OUT\n\n  result := pixel match\n    case Pixel(x, y) if x == y =&gt; x\n    case Pixel(x, 0) =&gt; x * 2\n    case Pixel(0, y) =&gt; y * 2\n    case Pixel(x, y) =&gt; (x + y) / 2\n</code></pre>"},{"location":"user-guide/conditionals/#usage-modes","title":"Usage Modes","text":"<p>DFHDL conditionals can be used in two ways: as statements and as expressions.</p>"},{"location":"user-guide/conditionals/#statement-usage","title":"Statement Usage","text":"<p>When used as statements, <code>if</code> and <code>match</code> are used for their side effects (like assignments) rather than producing a value:</p> <pre><code>// If statement\nif (i) x := 1\nelse if (!i) x := 2\n\n// Match statement\nx match\n  case 77 | 11 =&gt; x := 1\n  case _ =&gt;\n    x := 3\n    x := 4\n</code></pre>"},{"location":"user-guide/conditionals/#expression-usage","title":"Expression Usage","text":"<p>When used as expressions, <code>if</code> and <code>match</code> produce values that can be assigned or used in computations:</p> <pre><code>// If expression\nval res: UInt[8] &lt;&gt; VAL =\n  if (i) 1\n  else if (!i) x.bits.uint\n  else 2\n\n// Match expression\nval res: UInt[8] &lt;&gt; VAL =\n  x match\n    case 0 | 1 | 2 | 3 =&gt; 77\n    case _ =&gt; 22\n</code></pre> <p>Key differences: 1. Type Requirements:    - Statements: No return type consistency required between branches    - Expressions: All branches must return compatible types</p> <ol> <li>Assignment Context:</li> <li>Statements: Can contain multiple assignments per branch</li> <li> <p>Expressions: Must evaluate to a single value</p> </li> <li> <p>Variable Declaration:    <pre><code>// Direct assignment from expression\nval res2 = UInt(8) &lt;&gt; VAR\nres2 := (if (i) 1 else if (!i) x.bits.uint else 2)\n\n// Using statement form for multiple assignments\nif (i) \n  x := 1\n  y := 2\nelse \n  x := 3\n  y := 4\n</code></pre></p> </li> </ol>"},{"location":"user-guide/conditionals/#expression-vs-statement-form","title":"Expression vs. Statement Form","text":"<p>DFHDL conditionals can be written in two equivalent forms that generate different hardware structures:</p>"},{"location":"user-guide/conditionals/#expression-form","title":"Expression Form","text":"<p>In expression form, the conditional is part of the right-hand side of an assignment:</p> <pre><code>// If as expression\noutput := (if (cond) a else b)\n\n// Match as expression\noutput := (sel match\n  case A =&gt; a\n  case B =&gt; b)\n</code></pre>"},{"location":"user-guide/conditionals/#statement-form","title":"Statement Form","text":"<p>In statement form, the assignments are inside the conditional branches:</p> <pre><code>// If as statement\nif (cond) \n  output := a\nelse \n  output := b\n\n// Match as statement\nsel match\n  case A =&gt; output := a\n  case B =&gt; output := b\n</code></pre>"},{"location":"user-guide/conditionals/#key-differences","title":"Key Differences","text":"<ol> <li>Hardware Structure:</li> <li>Expression form: Generates a single multiplexer with the condition as select</li> <li> <p>Statement form: Generates multiple assignments with enable signals derived from conditions</p> </li> <li> <p>Code Organization:</p> </li> <li>Expression form: Better when the only difference between branches is the value being assigned</li> <li> <p>Statement form: Better when branches perform multiple operations or have different side effects</p> </li> <li> <p>Timing Implications:</p> </li> <li>Expression form: All values are computed in parallel, then selected</li> <li> <p>Statement form: Each branch's logic is gated by its condition</p> </li> <li> <p>Common Use Cases:    <pre><code>// Expression form - simple value selection\nval result = UInt(8) &lt;&gt; OUT\nresult := (if (valid) computed_value else 0)\n\n// Statement form - multiple operations\nif (valid)\n  result := computed_value\n  status := VALID\n  counter := counter + 1\nelse\n  result := 0\n  status := INVALID\n</code></pre></p> </li> </ol> <p>Choose the form that best matches your design's requirements: - Use expression form for simple value selection - Use statement form for complex control flow or multiple operations per branch</p>"},{"location":"user-guide/connectivity/","title":"Index","text":""},{"location":"user-guide/connectivity/#connectivity_1","title":"Connectivity","text":""},{"location":"user-guide/connectivity/#key-differences-between-and","title":"Key Differences Between <code>&lt;&gt;</code> and <code>:=</code>/<code>:==</code>","text":"Criteria <code>&lt;&gt;</code> Connection <code>:=</code>/<code>:==</code> Assignment Directionality &amp;Commutativity The operator is commutative, meaning <code>a &lt;&gt; b</code> is equivalent to b <code>b &lt;&gt; a</code>.  One argument is the producer, while the other consumer. The dataflow direction is sensitive to the context in which the operator is applied. The operator is non-commutative, meaning <code>a := b</code> determines that <code>b</code> is the producer, transferring data to the consumer <code>a</code>. Mutation A consumer can only be connected once. Consumer assignments are unlimited. Statement Order Connections statements can be placed in any order. Assignment statements"},{"location":"user-guide/connectivity/#connection-rules","title":"Connection <code>&lt;&gt;</code> Rules","text":""},{"location":"user-guide/connectivity/#port-direct-connections","title":"Port Direct Connections","text":"<p>The onnection operator <code>&lt;&gt;</code> is generally used to connect parent designs to their child designs (components) and connect between sibling designs (children of the same parent). Opposed to VHDL/Verilog, there is no need to go through 'signals' to connect sibling design ports, e.g.:</p> <pre><code>class Plus1 extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  y &lt;&gt; x + 1\n\nclass Plus2 extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  val p1A = Plus1()\n  val p1B = Plus1()\n  p1A.x &lt;&gt; x\n  p1A.y &lt;&gt; p1B.x\n  y &lt;&gt; p1B.y\n</code></pre> Plus2p1APlus1xyp1BPlus1xyxyPlus1+1xy"},{"location":"user-guide/connectivity/#port-via-connections","title":"Port Via Connections","text":"<pre><code>class Plus1 extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  y &lt;&gt; x + 1\n\nclass Plus2 extends EDDesign:\n  val x     = UInt(8) &lt;&gt; IN\n  val y     = UInt(8) &lt;&gt; OUT\n  val p1A_x = UInt(8) &lt;&gt; VAR\n  val p1A_y = UInt(8) &lt;&gt; VAR\n  val p1A = new Plus1():\n    this.x &lt;&gt; p1A_x\n    this.y &lt;&gt; p1A_y\n  val p1B_x = UInt(8) &lt;&gt; VAR\n  val p1B_y = UInt(8) &lt;&gt; VAR\n  val p1B = new Plus1():\n    this.x &lt;&gt; p1B_x\n    this.y &lt;&gt; p1B_y\n  p1A_x    &lt;&gt; x\n  p1B_x    &lt;&gt; p1A_y\n  y        &lt;&gt; p1B_y\nend Plus2\n</code></pre> Runnable example <pre><code>import dfhdl.* \n\nclass Plus1 extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  y &lt;&gt; x + 1\n\n@top class Plus2 extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  val p1A = Plus1()\n  val p1B = Plus1()\n  p1A.x &lt;&gt; x\n  p1A.y &lt;&gt; p1B.x\n  y &lt;&gt; p1B.y\n\ngiven options.CompilerOptions.PrintBackendCode = false\ngiven options.CompilerOptions.PrintDFHDLCode = true</code></pre>"},{"location":"user-guide/connectivity/#dataflow-value-connections","title":"Dataflow Value Connections","text":"<p>At least one of the connected sides must be a dataflow port (cannot connect two dataflow values together), e.g.:</p> <pre><code>trait Conn1 {\n  val port = DFUInt(8) &lt;&gt; OUT\n  val temp1 = DFUInt(8)\n  val temp2 = DFUInt(8)\n  port &lt;&gt; temp1 //OK!\n  temp1 &lt;&gt; temp2 //Bad connection! At least one connection side must be a port\n}\n</code></pre>"},{"location":"user-guide/connectivity/#dataflow-input-port-assignment-rule","title":"Dataflow Input Port Assignment <code>:=</code> Rule","text":"<p>An input port cannot be assigned to. A connection must be used to transfer data to an input port, e.g.:</p> <pre><code>trait IO extends DFDesign {\n  val in  = DFUInt(8) &lt;&gt; IN\n  val out = DFUInt(8) &lt;&gt; OUT\n  out := in //OK! Can assign internally to an output port\n}\ntrait Assign1 extends DFDesign {\n  val io = new IO{}\n  io.in := 1 //Bad assignment! Must use a connection annotation\n  io.in &lt;&gt; 1 //OK!\n  io.out := 1 //Bad assignment! Output ports can only be assigned internally\n}\n</code></pre>"},{"location":"user-guide/connectivity/#immutable-value-connections","title":"Immutable Value Connections","text":"<p>When connecting a port to an immutable value, the port must be a consumer, meaning the connection is done internally to an output port or externally to an input port, e.g.:</p> <pre><code>trait IO extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  //For brevity, we consider every connection/assignment in this example separately.\n  //We ignore multiple connection issues that should arise.\n  o &lt;&gt; 1 //OK!\n  i &lt;&gt; 1 //Bad connection! 1 is immutable (constant)\n  i &lt;&gt; o.prev //Bad connection! o.prev is immutable\n  i.prev &lt;&gt; o //OK!\n}\ntrait IOUser extends DFDesign {\n  val io = new IO {}\n  io.i &lt;&gt; 1 //OK!\n  io.o &lt;&gt; 1 //Bad connection! 1 is immutable\n}\n</code></pre>"},{"location":"user-guide/connectivity/#different-type-connections","title":"Different Type Connections","text":"<p>Connecting between different types is possible, but depends on the specific type: if it enables automatic conversion for the connection to succeed. Different port widths are considered different types and casting is required. An alias/casted/converted dataflow value is considered immutable for the connection (see above). Here are some examples:</p> <pre><code>trait DifferentTypesConn extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val ob9 = DFBits(9) &lt;&gt; OUT\n\n  val u7 = DFUInt(7)\n  val u9 = DFUInt(9)\n  val b8 = DFBits(8)\n\n  //For brevity, we consider every connection/assignment in this example separately.\n  //We ignore multiple connection issues that should arise.\n  u7 &lt;&gt; o //OK! u7 is automatically extended to connect to \n  u7 &lt;&gt; i //Bad connection! u7 is considered immutable when extended to 8 bits\n  o &lt;&gt; b8 //Bad connection! There is not automatic casting between bits and uint\n  o &lt;&gt; b8.uint //OK!\n  o.bits &lt;&gt; b8 //Bad connection! An alias of output port cannot be connected to\n               //This may change in the future.\n  o.bits := b8 //OK!\n  u9 &lt;&gt; i //OK! In this example u9 is the consumer\n  ob9 &lt;&gt; b8 //Bad connection! Bit vectors are NOT automatically extended.\n  ob9 := b8 //Bad assignment! Bit vectors are NOT automatically extended.\n}\n</code></pre>"},{"location":"user-guide/connectivity/#multiple-connections","title":"Multiple Connections","text":"<p>Two or more dataflow producers cannot be connected to the same consumer (a single producer can be connected to more than one consumer), e.g.:</p> <pre><code>trait Gen extends DFDesign {\n  val out1 = DFUInt(8) &lt;&gt; OUT init 1\n  val out2 = DFUInt(8) &lt;&gt; OUT init 2\n}\ntrait Conn2 extends DFDesign {\n  val in1 = DFUInt(8) &lt;&gt; IN\n  val in2 = DFUInt(8) &lt;&gt; IN\n  val out = DFUInt(8) &lt;&gt; OUT\n  val temp1 = DFUInt(8)\n  temp1 &lt;&gt; in1 //OK!\n  out   &lt;&gt; in1 //Also OK! (Same producer can connect to more than one cosumer)\n  temp1 &lt;&gt; in2 //Bad connection! Second producer connection to temp1\n\n  val gen = new Gen {}\n  val temp2 = DFUInt(8)\n  val temp3 = DFUInt(8)\n  gen.out1 &lt;&gt; temp2 //OK!\n  gen.out1 &lt;&gt; temp3 //Also OK! (Same producer can connect to more than one cosumer)\n  gen.out2 &lt;&gt; temp2 //Bad connection! Second producer connection to temp2\n} \n</code></pre>"},{"location":"user-guide/connectivity/#mixing-assignments-and-connections","title":"Mixing Assignments and Connections","text":"<p>The same consumer cannot be both assigned to and connected to as the consumer, e.g.:</p> <pre><code>trait Conn3 extends DFDesign {\n  val out1 = DFUInt(8) &lt;&gt; OUT\n  val out2 = DFUInt(8) &lt;&gt; OUT\n  val out3 = DFUInt(8) &lt;&gt; OUT\n  out1 &lt;&gt; 1 //OK!\n  out1 := 1 //Bad assignment! Cannot assign to a connected dataflow variable\n\n  out2 := 2 //OK!\n  out2 &lt;&gt; 2 //Bad connection! Cannot connect to an assigned dataflow variable\n\n  out3 := 1 //OK!\n  out3 := 2 //Also OK! (Multiple assignments are accepted)\n}\n</code></pre>"},{"location":"user-guide/connectivity/#connection-statement-order","title":"Connection Statement Order","text":"<p>The connection <code>&lt;&gt;</code> statement ordering does not matter.</p>"},{"location":"user-guide/connectivity/#connection-and-initial-conditions","title":"Connection and Initial Conditions","text":"<p>A connection <code>&lt;&gt;</code> transfers initial conditions to the consumer, but if the consumer is already initialized then the consumer keeps its existing initial conditions. Here is an example:</p> <pre><code>trait IOInit extends DFDesign {\n  val i = DFUInt(8)        //init = (11, 12) Overriden from TopInit connection\n  val o = DFUInt(8) init 5 //init = (5)      Not overridden due to assignment\n  val ip = i.prev          //init = (12)     Prev moves down the init queue\n  o := ip \n}\ntrait TopInit extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN.init(1, 2)  //init = (1, 2)   The top-level initial conditions\n  val o = DFUInt(8) &lt;&gt; OUT init 1     //init = (1)      Keeps its initializaion\n  val iPlus10 = in + 10               //init = (11, 12) Arithmetics affect init\n  val io = new IOInit {}\n  io.i &lt;&gt; inPlus10                                          \n  o &lt;&gt; io.o                                         \n}\n</code></pre> <p></p> <p>We learn from the above that port initial conditions are often overridden due to connections. So why should we apply initial conditions to a port? Answer: If we want to define what happens when a port is open (unconnected). Read the next two sections for more information.</p>"},{"location":"user-guide/connectivity/#open-unconnected-ports","title":"Open (Unconnected) Ports","text":"<p>Ports have two connection sides: a consumer side and a producer side. Typically ports have both sides connected, except for top-level ports. When either port side is unconnected, we refer to it as open, and expect the following behavior:</p> <ul> <li> <p>When the port consumer side is open, the port produces tokens according to its initial condition. Uninitialized open-consumer ports generate bubble tokens.</p> </li> <li> <p>When the port producer side is open (unless it is a top-level output port), the port is considered as not used, and is pruned during compilation. All dataflow streams that are only used by this port will be pruned as well.</p> </li> </ul> <p>Note: the current compiler implementation does not warn of open ports.  </p> <p>Example:</p> <pre><code>trait IOInit2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN init 5\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT init 2\n  o1 &lt;&gt; i1 \n}\ntrait TopIO2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN  \n  val o = DFUInt(8) &lt;&gt; OUT //Will generate infinite tokens of 2, due to io.o2 init\n  val io = new IO5 {}\n  o &lt;&gt; io.o2\n  i &lt;&gt; io.i1\n  io.i2 &lt;&gt; 5\n}\n</code></pre> <p></p>"},{"location":"user-guide/connectivity/#initial-condition-cyclic-loop-errors","title":"Initial Condition Cyclic Loop Errors","text":"<p>Connections enable dataflow feedbacks and even dataflow dependency loops. There is no problem in dependency loops, other than pipelining limitations (see chapter TBD for more information). However, if we only apply connections and references that transfer initial conditions, we end up with a cyclic dependency for initial condition which is illegal. Therefore to enable dependency loops, at least one link in the loop must be an assignment, which has an implicit state and does not affect initial conditions. Consider the following examples:</p> <pre><code>trait IO1 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i //Connection transfers initial conditions from i to o\n}\ntrait BadConnLoop1 extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO1 {}\n  io.i &lt;&gt; io.o //Bad connection! An initial conditions cyclic loop\n  o  &lt;&gt; io.o\n}\ntrait IO2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i.prev //prev transfers initial conditions\n}\ntrait BadConnLoop2 extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO2 {}\n  io.i &lt;&gt; io.o //Bad connection! An initial conditions cyclic loop\n  o  &lt;&gt; io.o\n}\ntrait IO3 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o := i //Assignment does not affect initial conditions and therefore breaks the loop\n}\ntrait OKConnLoop extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO3 {}\n  io.i &lt;&gt; io.o //OK!\n  o  &lt;&gt; io.o\n}\n</code></pre> <p></p> <p>Note: when following the drawing convention within this document, we want to avoid a double-lined loop in order to avoid a cyclic initial conditions dependency.</p>"},{"location":"user-guide/connectivity/#valid-connection-and-assignment-examples","title":"Valid Connection and Assignment Examples","text":"<pre><code>trait IODesign extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i\n}\n</code></pre> <pre><code>trait IODesign1 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val tmp = DFUInt(8)\n  tmp &lt;&gt; i\n  o &lt;&gt; tmp\n}\n</code></pre> <pre><code>trait IODesign2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT\n  o1 &lt;&gt; i1\n  o2 &lt;&gt; i2\n}\n</code></pre> <pre><code>trait Container extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign {}\n  i    &lt;&gt; io.i //Connecting between owner input and child input\n  io.o &lt;&gt; o    //Connecting between child output and owner output\n}\n</code></pre> <pre><code>trait Container2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io1 = new IODesign {}\n  val io2 = new IODesign {}\n  i     &lt;&gt; io1.i //Connecting between owner input and child input\n  io1.o &lt;&gt; io2.i //Connecting between siblings (output &lt;&gt; input)\n  io2.o &lt;&gt; o     //Connecting between child output and owner output\n}\n</code></pre> <pre><code>trait Container3 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign2 {}\n  i &lt;&gt; io.i1 //Connecting between owner input and child input\n  i &lt;&gt; io.i2 //Connecting between owner input and child input\n  o &lt;&gt; (io.o1 + io.o2)\n}\n</code></pre> <pre><code>trait Container4 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign2 {}\n  i     &lt;&gt; io.i1 //Connecting between owner input and child input\n  io.i2 &lt;&gt; 5     //Connecting between constant value and child input\n  o     &lt;&gt; io.o2\n}\n</code></pre> <pre><code>trait Blank2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT    \n}\ntrait Container5 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new Blank2 {\n    o1 &lt;&gt; i1 //Assignment\n    o2 &lt;&gt; i2 //Internal connection   \n  }\n  i     &lt;&gt; io.i1 //Connecting between owner input and child input\n  io.i2 &lt;&gt; io.o1 //External connection between child input/output creates a feeback\n  o     &lt;&gt; io.o2\n}\n</code></pre> <p>Note: although there is a feedback in this design, there is no circular initial conditions dependency.</p>"},{"location":"user-guide/connectivity/#magnet-port-connections","title":"Magnet Port Connections","text":""},{"location":"user-guide/connectivity/#future-work","title":"Future Work","text":"<ul> <li>In the future <code>&lt;&gt;</code> will be used to connect multi-port interfaces.</li> <li>We will add support to treat an alias of a port as a port when connection <code>&lt;&gt;</code> rules are enforced.</li> <li>Connecting between any ancestor which is not a parent and child. Currently not supported fully.</li> </ul>"},{"location":"user-guide/design-domains/","title":"Design Domains","text":"<p>DFHDL offers three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in the following figure. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through an intelligent compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p> </p>"},{"location":"user-guide/design-domains/#dataflow-df-domain","title":"Dataflow (DF) Domain","text":"<p>The dataflow domain provides the highest level of abstraction, focusing on data dependencies rather than timing.</p>"},{"location":"user-guide/design-domains/#key-features","title":"Key Features","text":"<ul> <li>Timing-agnostic descriptions</li> <li>Implicit state handling</li> <li>Token stream semantics</li> <li>History access via <code>.prev</code></li> </ul>"},{"location":"user-guide/design-domains/#example","title":"Example","text":"<pre><code>class Accumulator extends DFDesign:\n  val input = UInt(8) &lt;&gt; IN\n  val sum = UInt(16) &lt;&gt; OUT init 0\n  sum := sum.prev + input  // Implicit state handling\n</code></pre>"},{"location":"user-guide/design-domains/#register-transfer-rt-domain","title":"Register Transfer (RT) Domain","text":"<p>The RT domain provides explicit control over registers and timing while maintaining hardware-friendly abstractions.</p>"},{"location":"user-guide/design-domains/#domain-configuration","title":"Domain Configuration","text":""},{"location":"user-guide/design-domains/#clock-configuration","title":"Clock Configuration","text":"<pre><code>// Clock edge options\nval risingEdge = ClkCfg.Edge.Rising   // Rising edge triggered\nval fallingEdge = ClkCfg.Edge.Falling // Falling edge triggered\n\n// Clock configuration with options\nval clkCfg = ClkCfg(\n  edge = ClkCfg.Edge.Rising,    // Clock edge sensitivity\n  rate = 50.MHz,                // Clock frequency\n  portName = \"clk\",             // Port name in generated code\n  inclusionPolicy = ClkCfg.InclusionPolicy.AsNeeded // Port inclusion policy\n)\n</code></pre>"},{"location":"user-guide/design-domains/#reset-configuration","title":"Reset Configuration","text":"<pre><code>// Reset mode options\nval asyncRst = RstCfg.Mode.Async  // Asynchronous reset\nval syncRst = RstCfg.Mode.Sync    // Synchronous reset\n\n// Reset active level\nval activeHigh = RstCfg.Active.High // Reset active at 1\nval activeLow = RstCfg.Active.Low   // Reset active at 0\n\n// Reset configuration with options\nval rstCfg = RstCfg(\n  mode = RstCfg.Mode.Sync,         // Reset mode\n  active = RstCfg.Active.High,     // Active level\n  portName = \"rst\",                // Port name in generated code\n  inclusionPolicy = RstCfg.InclusionPolicy.AsNeeded // Port inclusion policy\n)\n</code></pre>"},{"location":"user-guide/design-domains/#rtdomain-configuration","title":"RTDomain Configuration","text":"<pre><code>// Complete domain configuration\nval domainCfg = RTDomainCfg(clkCfg, rstCfg)\n\n// Special configurations\nval combDomain = RTDomainCfg.Comb           // Combinational domain (no clk/rst)\nval defaultDomain = RTDomainCfg.Default     // Default configuration\nval derivedDomain = RTDomainCfg.Derived     // Derived from parent domain\n\n// Domain without reset\nval noRstDomain = domainCfg.norst           // Remove reset from configuration\n</code></pre>"},{"location":"user-guide/design-domains/#inclusion-policies","title":"Inclusion Policies","text":"<p>The <code>InclusionPolicy</code> determines how clock and reset ports are included in the generated code:</p> <ul> <li><code>AsNeeded</code>: Only includes ports when they are actually used</li> <li><code>AlwaysAtTop</code>: Always includes ports at the top level with <code>@unused</code> annotation if not used</li> </ul>"},{"location":"user-guide/design-domains/#domain-types","title":"Domain Types","text":""},{"location":"user-guide/design-domains/#basic-rt-domain","title":"Basic RT Domain","text":"<pre><code>class BasicRTDesign extends RTDesign(domainCfg):\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT.REG init 0\n  y := x.reg  // Registered on configured clock edge\n</code></pre>"},{"location":"user-guide/design-domains/#multiple-clock-domains","title":"Multiple Clock Domains","text":"<pre><code>class MultiClockDesign extends RTDesign(mainCfg):\n  // Main domain at 100MHz\n  val mainClk = ClkCfg(edge = ClkCfg.Edge.Rising, rate = 100.MHz)\n  val mainRst = RstCfg(mode = RstCfg.Mode.Sync, active = RstCfg.Active.High)\n\n  // Slow domain at 25MHz\n  val slowClk = ClkCfg(edge = ClkCfg.Edge.Rising, rate = 25.MHz)\n  val slowDomain = new RTDomain(RTDomainCfg(slowClk, mainRst)):\n    val slow_reg = UInt(8) &lt;&gt; VAR.REG init 0\n\n  // Fast domain at 200MHz\n  val fastClk = ClkCfg(edge = ClkCfg.Edge.Rising, rate = 200.MHz)\n  val fastDomain = new RTDomain(RTDomainCfg(fastClk, mainRst)):\n    val fast_reg = UInt(8) &lt;&gt; VAR.REG init 0\n</code></pre>"},{"location":"user-guide/design-domains/#related-domains","title":"Related Domains","text":"<pre><code>class RelatedDomainsDesign extends RTDesign(mainCfg):\n  val baseDomain = new RTDomain(baseCfg):\n    val base_reg = UInt(8) &lt;&gt; VAR.REG init 0\n\n  // Inherits clock/reset from baseDomain\n  val relatedDomain = new baseDomain.RelatedDomain:\n    val related_reg = UInt(8) &lt;&gt; VAR.REG init 0\n\n  // Related domain without reset\n  val noRstRelated = new baseDomain.RelatedDomain(baseCfg.norst):\n    val norst_reg = UInt(8) &lt;&gt; VAR.REG init 0\n</code></pre>"},{"location":"user-guide/design-domains/#register-types-and-initialization","title":"Register Types and Initialization","text":""},{"location":"user-guide/design-domains/#register-declarations-vs-aliases","title":"Register Declarations vs Aliases","text":"<pre><code>class RegisterPatterns extends RTDesign(cfg):\n  val x = UInt(8) &lt;&gt; IN\n\n  // Register Declaration - creates a new register\n  val reg1 = UInt(8) &lt;&gt; VAR.REG init 0  // Variable register\n  val out1 = UInt(8) &lt;&gt; OUT.REG init 0  // Output register\n\n  // Register Alias - creates a registered version of a signal\n  val delayed = x.reg      // One cycle delay of x\n  val delayed2 = x.reg(2)  // Two cycle delay of x\n</code></pre>"},{"location":"user-guide/design-domains/#register-access-patterns","title":"Register Access Patterns","text":"<pre><code>class RegisterAccess extends RTDesign(cfg):\n  val x = UInt(8) &lt;&gt; IN\n  val reg = UInt(8) &lt;&gt; VAR.REG init 0\n  val out = UInt(8) &lt;&gt; OUT.REG init 0\n\n  // CORRECT: Writing to register input using .din\n  reg.din := x            // Updates register input\n  out.din := reg         // Updates output register input\n\n  // INCORRECT: Attempting to write to register output\n  reg := x               // Error: Can't write to register output\n  out := reg            // Error: Can't write to register output\n\n  // Reading from registers (always reads output)\n  val value = reg        // Reads register output\n  val outValue = out     // Reads output register value\n</code></pre>"},{"location":"user-guide/design-domains/#register-composition","title":"Register Composition","text":"<pre><code>class RegisterComposition extends RTDesign(cfg):\n  val x = UInt(8) &lt;&gt; IN\n\n  // Using register declarations\n  val reg1 = UInt(8) &lt;&gt; VAR.REG init 0\n  val reg2 = UInt(8) &lt;&gt; VAR.REG init 0\n  reg1.din := x\n  reg2.din := reg1      // Chaining registers\n\n  // Using register aliases\n  val stage1 = x.reg    // Same as reg1\n  val stage2 = x.reg(2) // Same as reg2, but more concise\n\n  // Mixing declarations and aliases\n  val reg3 = UInt(8) &lt;&gt; VAR.REG init 0\n  reg3.din := stage2    // Can mix both styles\n</code></pre>"},{"location":"user-guide/design-domains/#advanced-register-patterns","title":"Advanced Register Patterns","text":"<pre><code>class AdvancedRegisters extends RTDesign(cfg):\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; IN\n\n  // Conditional registration\n  val reg = UInt(8) &lt;&gt; VAR.REG init 0\n  if (x &gt; 10)\n    reg.din := y     // Register y when x &gt; 10\n  else\n    reg.din := x     // Register x otherwise\n\n  // Register with enable\n  val enReg = UInt(8) &lt;&gt; VAR.REG init 0\n  val en = Bit &lt;&gt; IN\n  if (en)\n    enReg.din := x   // Only update when enabled\n\n  // Multiple cycle delays with processing\n  val processed = (x + 1).reg(2)  // Add 1 and delay 2 cycles\n</code></pre>"},{"location":"user-guide/design-domains/#common-patterns-and-pitfalls","title":"Common Patterns and Pitfalls","text":"<pre><code>class RegisterPitfalls extends RTDesign(cfg):\n  val x = UInt(8) &lt;&gt; IN\n  val reg = UInt(8) &lt;&gt; VAR.REG init 0\n\n  // GOOD: Explicit input/output separation\n  reg.din := x + 1        // Write to input\n  val result = reg + 2    // Read from output\n\n  // BAD: Attempting to write to output\n  reg := x + 1           // Error: Writing to output\n\n  // GOOD: Register alias for simple delays\n  val delayed = x.reg    // Clean and clear intent\n\n  // BAD: Unnecessary register declaration for simple delay\n  val regDelay = UInt(8) &lt;&gt; VAR.REG init 0\n  regDelay.din := x      // More verbose than needed\n</code></pre>"},{"location":"user-guide/design-domains/#event-driven-ed-domain","title":"Event-Driven (ED) Domain","text":"<p>The ED domain provides the lowest level of abstraction, with explicit process blocks and event sensitivity.</p>"},{"location":"user-guide/design-domains/#process-types","title":"Process Types","text":"<pre><code>class EDExample extends EDDesign:\n  val clk = Bit &lt;&gt; IN\n  val rst = Bit &lt;&gt; IN\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n\n  // Combinational process\n  process(all):\n    y := x + 1\n\n  // Clock-sensitive process\n  process(clk.rising):\n    y := x\n\n  // Clock and reset process\n  process(clk, rst):\n    if (rst)\n      y := 0\n    else if (clk.rising)\n      y := x\n</code></pre>"},{"location":"user-guide/design-domains/#assignment-types","title":"Assignment Types","text":"<ul> <li>Blocking (<code>:=</code>): Immediate effect</li> <li>Non-blocking (<code>:==</code>): Scheduled update <pre><code>process(clk.rising):\n  val temp = x  // Blocking read\n  y :== temp    // Non-blocking write\n</code></pre></li> </ul>"},{"location":"user-guide/design-domains/#domain-interaction","title":"Domain Interaction","text":""},{"location":"user-guide/design-domains/#cross-domain-communication","title":"Cross-Domain Communication","text":"<pre><code>class CrossDomainExample extends RTDesign(mainCfg):\n  val x = UInt(8) &lt;&gt; IN\n\n  val domainA = new RTDomain(cfgA):\n    val reg_a = UInt(8) &lt;&gt; VAR.REG init 0\n    reg_a := x.reg\n\n  val domainB = new RTDomain(cfgB):\n    val reg_b = UInt(8) &lt;&gt; VAR.REG init 0\n    reg_b := domainA.reg_a.reg  // Cross-domain registration\n</code></pre>"},{"location":"user-guide/design-domains/#domain-flattening","title":"Domain Flattening","text":"<p>During compilation, nested domains are flattened while preserving clock and reset relationships: <pre><code>// Original nested domains\nval innerDomain = new RTDomain(innerCfg):\n  val reg = UInt(8) &lt;&gt; VAR.REG init 0\n\n// After flattening\nval innerDomain_reg = UInt(8) &lt;&gt; VAR.REG init 0\nprocess(innerDomain_clk.rising):\n  if (innerDomain_rst) \n    innerDomain_reg := 0\n  else \n    innerDomain_reg := next_value\n</code></pre></p>"},{"location":"user-guide/design-domains/#compilation-flow","title":"Compilation Flow","text":"<ol> <li>Domain Resolution:</li> <li>Flattens nested domains</li> <li>Resolves clock and reset configurations</li> <li> <p>Establishes domain hierarchies</p> </li> <li> <p>State Management:</p> </li> <li>Converts DF <code>.prev</code> to explicit registers</li> <li>Handles RT register declarations</li> <li> <p>Manages ED process state variables</p> </li> <li> <p>Process Generation:</p> </li> <li>Converts DF and RT to ED processes</li> <li>Optimizes sensitivity lists</li> <li> <p>Handles blocking/non-blocking assignments</p> </li> <li> <p>Backend Generation:</p> </li> <li>Generates VHDL or Verilog code</li> <li>Preserves timing relationships</li> <li>Maintains design hierarchy</li> </ol>"},{"location":"user-guide/design-domains/#best-practices","title":"Best Practices","text":"<ol> <li>Domain Selection:</li> <li>Use DF for algorithmic descriptions</li> <li>Use RT for timing-critical paths</li> <li> <p>Use ED for low-level control</p> </li> <li> <p>Clock Domain Crossing:</p> </li> <li>Use explicit synchronization</li> <li>Maintain clear domain boundaries</li> <li> <p>Document clock relationships</p> </li> <li> <p>State Management:</p> </li> <li>Initialize all registers</li> <li>Use appropriate reset strategies</li> <li> <p>Consider reset domains</p> </li> <li> <p>Performance Optimization:</p> </li> <li>Balance domain abstractions</li> <li>Use appropriate clock domains</li> <li>Consider resource utilization</li> </ol>"},{"location":"user-guide/design-hierarchy/","title":"Design Hierarchy","text":"<p>DFHDL supports composable design hierarchies through design class instantiation and port connections.</p> <p>Terminology</p> <ul> <li>design - A Scala class extending <code>XXDesign</code>, where <code>XX</code> can be <code>DF</code>, <code>RT</code>, or <code>ED</code>, corresponding to the desired design domain.</li> <li>design member - Any DFHDL object instantiated within a design (the design contains or owns all its members).</li> <li>child design/component - A design instance that is owned by another design.</li> <li>top design - The highest-level design in the hierarchy (not contained by any other design), also known as the top-level design.</li> <li>top-app design - A <code>@top</code> annotated top design that generates a main entry point with the default application.</li> </ul> topconstchild A param1param2child B in portout port param"},{"location":"user-guide/design-hierarchy/#design-declaration","title":"Design Declaration","text":""},{"location":"user-guide/design-hierarchy/#design-dcl-syntax","title":"Syntax","text":"<p>A DFHDL design declaration follows standard Scala class syntax, with specialized handling by the DFHDL Scala compiler plugin.</p> Design declaration syntax<pre><code>/** _documentation_ */\n@top(genMain) //required only for top-level designs\n[_modifiers_] class _name_(_params_) extends XXDesign:\n  _contents_\nend _name_ //optional `end` marker\n</code></pre> <ul> <li> <p><code>_name_</code> - The Scala class name for the design. The DFHDL compiler preserves this name and uses it in error messages and generated artifacts (e.g., Verilog modules or VHDL entities). See the naming section for details.</p> </li> <li> <p><code>(_params_)</code> - An optional parameter block. This can include either Scala parameters that are inlined during design elaboration, or DFHDL design parameters that are preserved through elaboration and compilation. If no parameters are needed, Scala syntax accepts either empty parentheses <code>()</code> or no parentheses. See Parameter Block Syntax for details.</p> </li> <li> <p><code>_XXDesign_</code> - The base class to extend, where <code>XX</code> specifies the design domain: <code>DF</code> for dataflow, <code>RT</code> for register-transfer, or <code>ED</code> for event-driven.</p> </li> <li> <p><code>_contents_</code> - The design interface (ports/interfaces/domains) and functionality (variables, functions, child designs, processes, etc.), based on the selected design domain's semantics.</p> </li> <li> <p><code>@top(genMain)</code> - A required annotation for top-level designs (designs not instantiated within another design). The annotation has an optional <code>val genMain: Boolean = true</code> parameter:</p> <ul> <li>When <code>genMain = true</code>, the design becomes a top-app design where all parameters must have default values, and a main Scala entry point named <code>top__name_</code> is generated</li> <li>When <code>genMain = false</code>, the annotation only provides a default top-level context for the design</li> </ul> </li> <li> <p><code>_documentation_</code> - Design documentation in Scaladoc format. This documentation is preserved throughout compilation and included in the generated backend code.</p> </li> <li> <p><code>_modifiers_</code> - Optional Scala modifiers. See Design Class Modifier Rules for details.</p> </li> </ul>"},{"location":"user-guide/design-hierarchy/#LeftShift2","title":"<code>LeftShift2</code> example","text":"<p>Basic top-app design example: a two-bits left shifter</p> <p>The DFHDL code below implements a two-bit left shifter design named <code>LeftShift2</code>. The design:</p> <ul> <li>Uses register-transfer (RT) domain semantics by extending <code>RTDesign</code></li> <li>Has an 8-bit input port and an 8-bit output port </li> <li>Performs a fixed 2-bit left shift operation on the input</li> </ul> <pre><code>import dfhdl.*\n//optionally set the default backend configuration option\n//(can be overridden by the top-app CLI)\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A two-bits left shifter */\n@top class LeftShift2 extends RTDesign:\n  /** bits input */\n  val iBits = Bits(8) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(8) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; 2\n</code></pre> LeftShift22&lt;&lt; iBitsoBits <p>Since this design is annotated with <code>@top</code>, it is a top-app design that generates an executable Scala program. This program compiles the design and generates backend code (Verilog or VHDL). The backend can be configured through:</p> <ul> <li>Command-line arguments when running the program</li> <li>Implicit backend settings in the code (as shown in this example)</li> </ul> <p>The <code>@top</code> annotation captures any implicit/given options within its scope and provides them as defaults when no CLI arguments are specified.</p> Generated VerilogGenerated VHDL <p><pre><code>/* A two-bits left shifter */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LeftShift2_defs.svh\"\n\nmodule LeftShift2(\n  /* bits input */\n  input  wire logic [7:0] iBits,\n  /* bits output */\n  output      logic [7:0] oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; 2;\nendmodule\n</code></pre> Looking at the generated Verilog code, we can observe several key differences from the DFHDL source:</p> <ol> <li> <p>Module Interface: DFHDL's Scala-style port declarations (<code>&lt;&gt; IN/OUT</code>) are translated to traditional Verilog port declarations (<code>input wire</code>/<code>output logic</code>)</p> </li> <li> <p>Documentation: Scaladoc comments are preserved and converted to Verilog-style comments (<code>/* */</code>)</p> </li> <li> <p>Default Settings: The compiler adds standard Verilog settings like <code>`default_nettype none</code> and <code>`timescale</code></p> </li> <li> <p>Include Files: The compiler adds necessary include files for backend-specific definitions</p> </li> <li> <p>Assignment Syntax: DFHDL's <code>:=</code> assignments are translated to Verilog's <code>assign</code> statements</p> </li> </ol> <p><pre><code>-- A two-bits left shifter \nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LeftShift2_pkg.all;\n\nentity LeftShift2 is\nport (\n  -- bits input \n  iBits : in  std_logic_vector(7 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(7 downto 0)\n);\nend LeftShift2;\n\narchitecture LeftShift2_arch of LeftShift2 is\nbegin\n  oBits &lt;= slv_sll(iBits, 2);\nend LeftShift2_arch;\n</code></pre> The generated VHDL code shows similar transformations from the DFHDL source:</p> <ol> <li> <p>Entity Interface: DFHDL's port declarations are translated to VHDL's <code>in</code>/<code>out</code> mode declarations with explicit signal types</p> </li> <li> <p>Documentation: Scaladoc comments are preserved as VHDL comments (<code>--</code>)</p> </li> <li> <p>Library/Package Usage: The compiler adds necessary library and package references (<code>ieee</code>, <code>std_logic_1164</code>, etc.)</p> </li> <li> <p>Signal Types: DFHDL's <code>Bits</code> type is translated to VHDL's <code>std_logic_vector</code> with appropriate widths</p> </li> <li> <p>Assignment Syntax: While both DFHDL and VHDL use <code>:=</code>, the semantics differ - DFHDL represents high-level connections while VHDL represents signal assignments</p> </li> </ol> Runnable example <pre><code>import dfhdl.*\n//optionally set the default backend configuration option\n//(can be overridden by the top-app CLI)\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A two-bits left shifter */\n@top class LeftShift2 extends RTDesign:\n  /** bits input */\n  val iBits = Bits(8) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(8) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; 2\n</code></pre>"},{"location":"user-guide/design-hierarchy/#design-params-syntax","title":"Parameter Block Syntax","text":"<p>The DFHDL design parameter block follows standard Scala syntax, accepting a comma-separated list of parameter declarations:</p> Design declaration parameter block syntax<pre><code>([_access_] _name_: _type_ [= _default_], ...)\n</code></pre> <ul> <li> <p><code>_type_</code> - Either a pure Scala type or a DFHDL parameter type (<code>DFType &lt;&gt; CONST</code>):</p> <ul> <li>Pure Scala parameters are inlined during elaboration</li> <li>DFHDL parameters are preserved in the generated backend code</li> <li>See Design Parameter Type Rules for details</li> </ul> </li> <li> <p><code>_name_</code> - The parameter name. For DFHDL parameters, this name is:</p> <ul> <li>Preserved throughout compilation</li> <li>Used in the generated backend code</li> <li>Available through the CLI for top-app designs</li> </ul> </li> <li> <p><code>_default_</code> - Optional default value. Required for all parameters in top-app designs. See Design Parameter Default Value Rules for details.</p> </li> <li> <p><code>_access_</code> - Optional Scala access modifier. Usually <code>val</code> to make the parameter public. See Design Parameter Access Rules for details.</p> </li> </ul>"},{"location":"user-guide/design-hierarchy/#LeftShiftBasic","title":"<code>LeftShiftBasic</code> example","text":"<p>Scala-parameterized top-app design example: a basic left shifter</p> <p>The DFHDL code below implements a basic left shifter design named <code>LeftShiftBasic</code>. This design is similar to the earlier example of <code>LeftShift2</code>, except here the design has the shift value as an input, and its input and output port widths are set according to the Scala parameter <code>width</code>.</p> <pre><code>/** A basic left shifter */\n@top class LeftShiftBasic(\n    val width: Int = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre> LeftShiftBasic&lt;&lt; shiftiBitsoBitswidth Generated VerilogGenerated VHDL <pre><code>/* A basic left shifter */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LeftShiftBasic_defs.svh\"\n\nmodule LeftShiftBasic(\n  /* bits input */\n  input  wire logic [7:0] iBits,\n  /* requested shift */\n  input  wire logic [2:0] shift,\n  /* bits output */\n  output      logic [7:0] oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; shift;\nendmodule\n</code></pre> <pre><code>-- A basic left shifter \nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LeftShiftBasic_pkg.all;\n\nentity LeftShiftBasic is\nport (\n  -- bits input \n  iBits : in  std_logic_vector(7 downto 0);\n  -- requested shift \n  shift : in  unsigned(2 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(7 downto 0)\n);\nend LeftShiftBasic;\n\narchitecture LeftShiftBasic_arch of LeftShiftBasic is\nbegin\n  oBits &lt;= slv_sll(iBits, to_integer(shift));\nend LeftShiftBasic_arch;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A basic left shifter */\n@top class LeftShiftBasic(\n    val width: Int = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre> <p>The basic code shifter above did not generate the <code>width</code> parameter in the Verilog and VHDL backend code. The following example shows how to preserve the <code>width</code> parameter:</p>"},{"location":"user-guide/design-hierarchy/#LeftShiftGen","title":"<code>LeftShiftGen</code> example","text":"<p>DFHDL-parameterized top-app design example: a generic left shifter</p> <p>The DFHDL code below implements a generic left shifter design named <code>LeftShiftGen</code>. This design is similar to the earlier example of <code>LeftShiftBasic</code>, except here the <code>width</code> parameter is now a DFHDL parameter, as indicated by its <code>Int &lt;&gt; CONST</code> type. This enables the DFHDL compiler to preserve the parameter name and directly use it in the generated backend code where applicable.</p> <pre><code>/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LeftShiftGen(\n    val width: Int &lt;&gt; CONST = 8,\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre> LeftShiftGen&lt;&lt; shiftiBitsoBitswidth Generated VerilogGenerated VHDL <pre><code>/* A generic left shifter \n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LeftShiftGen_defs.svh\"\n\nmodule LeftShiftGen#(parameter int width = 8)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; shift;\nendmodule\n</code></pre> <pre><code>-- A generic left shifter \n--   \n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LeftShiftGen_pkg.all;\n\nentity LeftShiftGen is\ngeneric (\n  width : integer := 8\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend LeftShiftGen;\n\narchitecture LeftShiftGen_arch of LeftShiftGen is\nbegin\n  oBits &lt;= slv_sll(iBits, to_integer(shift));\nend LeftShiftGen_arch;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LeftShiftGen(\n    val width: Int &lt;&gt; CONST = 8,\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  oBits := iBits &lt;&lt; shift\n</code></pre>"},{"location":"user-guide/design-hierarchy/#design-parameter-type-rules","title":"Design Parameter Type Rules","text":"<ul> <li>Any pure Scala parameter or DFHDL parameter types are acceptable.</li> <li>Top-app design parameters that can be modified from the CLI must be one of:<ul> <li>Pure Scala Types: <code>String</code>, <code>Boolean</code>, <code>Int</code>, and <code>Double</code></li> <li>DFHDL Types: <code>Int &lt;&gt; CONST</code>, <code>Bit &lt;&gt; CONST</code>, and <code>Boolean &lt;&gt; CONST</code></li> </ul> </li> </ul> <p>Top-app design with accepted and ignored CLI arguments example</p> <p>In this example, the top-app supported parameters <code>pureIntArg</code> and <code>dfhdlIntArg</code> are preserved to be modifiable from the CLI, while <code>ignored</code> and <code>dfhdlIgnored</code> keep their default values.</p> DFHDL code<pre><code>import dfhdl.*\nclass CustomArg\n@top class Foo(\n    val pureIntArg:   Int              = 5,\n    val dfhdlIntArg:  Int &lt;&gt; CONST     = 7,\n    val ignored:      CustomArg        = CustomArg(),\n    val dfhdlIgnored: Bits[8] &lt;&gt; CONST = all(0)\n) extends DFDesign\n</code></pre> CLI help mode output, when running via sbt (truncated)<pre><code>Design Name: Foo\nUsage: sbt runMain \"top_Foo [design-args] &lt;mode&gt; [options]\"\n Design arguments:\n      --pureIntArg  &lt;Int&gt;    (default = 5)\n      --dfhdlIntArg  &lt;Int&gt;   (default = 7)\n</code></pre> Runnable example <pre><code>import dfhdl.*\n//this option forces the top-app\n//to run help mode by default\ngiven options.AppOptions.DefaultMode = \n  options.AppOptions.DefaultMode.help\nclass CustomArg\n@top class Foo(\n    val pureIntArg:   Int              = 5,\n    val dfhdlIntArg:  Int &lt;&gt; CONST     = 7,\n    val ignored:      CustomArg        = CustomArg(),\n    val dfhdlIgnored: Bits[8] &lt;&gt; CONST = all(0)\n) extends DFDesign</code></pre>"},{"location":"user-guide/design-hierarchy/#design-parameter-default-value-rules","title":"Design Parameter Default Value Rules","text":"<p>For top-app designs, all parameters must have default values.</p> <p><code>@top</code> annotation and default parameter value requirement example</p> <p>This example shows <code>FooErr</code> is missing a default value and throws an error. There are three ways to resolve this, shown in <code>FooOK1</code>, <code>FooOK2</code>, and <code>FooOK3</code>.</p> <pre><code>//Error: Missing argument's default value \n//for top-level design with a default app \n//entry point. Either add a default value \n//or disable the app entry point generation \n//with `@top(false)`.\n@top class FooErr(\n    val arg1: Int = 5,\n    val arg2: Boolean &lt;&gt; CONST\n) extends DFDesign\n\n//OK: all parameters have default values\n//Top-app capability: YES\n//Top-level design capability: YES\n@top class FooOK1(\n    val arg1: Int = 5,\n    val arg2: Boolean &lt;&gt; CONST = true\n) extends DFDesign\n\n//OK: the `genMain` argument in the `@top` \n//annotation is set to `false`\n//Top-app capability: NO\n//Top-level design capability: YES\n@top(false) class FooOK2(\n    val arg1: Int = 5,\n    val arg2: Boolean &lt;&gt; CONST\n) extends DFDesign\n\n//OK: no top annotation\n//Top-app capability: NO\n//Top-level design capability: NO\nclass FooOK3(\n    val arg1: Int = 5,\n    val arg2: Boolean &lt;&gt; CONST\n) extends DFDesign\n</code></pre> <p>Good design practice - avoid default parameter value overuse</p> <p>Overusing default parameter values is considered bad design practice. In general, default values should be used sparingly and only to define \"sensible defaults\" for parameters that are rarely changed. A good rule of thumb is to avoid default values that affect a design's interface (e.g., the width of a port).</p>"},{"location":"user-guide/design-hierarchy/#design-parameter-access-rules","title":"Design Parameter Access Rules","text":"<p>Without any Scala access modifier, a Scala class parameter access is declared as <code>private val</code>. This default access leads to an error if that parameter affects the type of non-private class member (e.g., a <code>width</code> parameter affecting the bits width of a port). To resolve this error, the parameter can be declared as public <code>val</code>, as <code>protected val</code>, or even <code>private[scope] val</code> with a scope access qualifier.</p> <p>Parameter access example</p> <p>This example shows an access error in <code>FooErr</code>, where a private parameter <code>width</code> affects the type of a non-private member <code>v</code>. There are four ways to resolve this error, shown in <code>FooOK1</code>, <code>FooOK2</code>, <code>FooOK3</code>, and <code>FooOK4</code>. <code>FooOK5</code> demonstrates that private parameters can be accessed by public members as long as they don't affect the type.</p> <pre><code>//Error: non-private value v in class FooErr \n//refers to private value width ... (lengthy \n//type description)\nclass FooErr(\n    width: Int &lt;&gt; CONST\n) extends DFDesign:\n  val v = UInt(width) &lt;&gt; VAR\n\n//OK: both parameter and its dependent design \n//members are public\nclass FooOK1(\n    val width: Int &lt;&gt; CONST\n) extends DFDesign:\n  val v = UInt(width) &lt;&gt; VAR\n\n//OK: both parameter and its dependent design \n//members are private (note that ports should\n//never be private, and therefore parameters\n//that affect their types should never be \n//private)\nclass FooOK2(\n    width: Int &lt;&gt; CONST\n) extends DFDesign:\n  private val v = UInt(width) &lt;&gt; VAR\n\n//OK: the parameter is protected\nclass FooOK3(\n    protected val width: Int &lt;&gt; CONST\n) extends DFDesign:\n  val v = UInt(width) &lt;&gt; VAR\n\npackage Bar:\n  //OK: the parameter is private but only \n  //outside the scope of `Bar`.\n  class FooOK4(\n      private[Bar] val width: Int &lt;&gt; CONST\n  ) extends DFDesign:\n    val v = UInt(width) &lt;&gt; VAR\n\n//OK: the parameter `v0` is private, but it\n//does not affect the type of the public\n//dfhdl variable `v`. Only `width` affects\n//the type of `v` and it's public as well.\nclass FooOK5(\n    v0: Int &lt;&gt; CONST,\n    val width: Int &lt;&gt; CONST\n) extends DFDesign:\n  val v = UInt(width) &lt;&gt; VAR init v0\n</code></pre> <p>Good design practice - how to choose the right parameter/member access?</p> <ul> <li>For Simple Development - During initial development, you can declare all parameters and named design members as public <code>val</code> for simplicity.</li> <li>Protection for Shared Code - When sharing your design with others in DFHDL (Scala) form, follow good design practices to maintain source and binary compatibility of your Scala library artifacts. Remember: You can always remove protection without breaking code, but adding protection later will cause breakage.<ul> <li>Public Interface, Protected Implementation - Keep the design interface (ports, domains, interfaces, and their type-affecting parameters) public. All other design class members should have private or protected access modifiers.</li> <li>Private vs. Protected Access - Use private access for members that should only be accessible within the design class itself. Use protected access for members that should also be accessible by subclasses.</li> <li>Scoped Protection for Testing - For verification code that needs access to internal design members, use package-private access with a scope qualifier (e.g. <code>private[mylib]</code>) instead of making members fully public. This restricts access to just your library's test code.</li> </ul> </li> </ul> <p>In this example, the <code>Foo</code> class demonstrates good design practices for parameter and member access. Good design practice example<pre><code>package mylib\nimport dfhdl.*\n\nclass Foo(\n    val width: Int &lt;&gt; CONST,\n    val boolParam: Boolean &lt;&gt; CONST,\n    protected[mylib] val someValue: Int &lt;&gt; CONST\n) extends DFDesign:\n  //Public interface\n  val i = UInt(width) &lt;&gt; IN\n  val o = UInt(width) &lt;&gt; OUT\n  //Protected implementation\n  protected[mylib] val v = UInt(width) &lt;&gt; VAR\n</code></pre></p>"},{"location":"user-guide/design-hierarchy/#design-class-modifier-rules","title":"Design Class Modifier Rules","text":"<p>A DFHDL design class cannot be declared as <code>final class</code> or <code>case class</code>. Attempting to do so produces an error:</p> DFHDL design class modifier limitation example<pre><code>//error: DFHDL classes cannot be final classes.\nfinal class Foo extends DFDesign\n//error: DFHDL classes cannot be case classes.\ncase class Bar() extends DFDesign\n</code></pre> <p>All other Scala class modifiers have no special effect or limitation from a DFHDL compiler perspective. Nonetheless, these modifiers can be relevant when defining a more complex design API, as part of the DFHDL meta-programming capabilities through the Scala language (e.g., changing class access to <code>protected</code>).</p>"},{"location":"user-guide/design-hierarchy/#LRShiftFlat","title":"<code>LRShiftFlat</code> example","text":"<p>Generic left-right shifter, flat design example</p> <p>The DFHDL code below implements a generic left-right shifter flat design named <code>LRShiftFlat</code>. This design expands on <code>LeftShiftGen</code> by adding a <code>dir</code> enum port value that specifies the shift direction and a shift operation multiplexer through a <code>match</code> statement.</p> <pre><code>enum ShiftDir extends Encoded:\n  case Left, Right\n\n/** A left-right bits shifter (flat version)\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftFlat(\n    val width: Int &lt;&gt; CONST = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** direction of shift */\n  val dir   = ShiftDir          &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  oBits := dir match\n    case ShiftDir.Left  =&gt; iBits &lt;&lt; shift\n    case ShiftDir.Right =&gt; iBits &gt;&gt; shift\n</code></pre> LRShiftFlat&lt;&lt; &gt;&gt; mux dirshiftiBitsoBitswidth Generated VerilogGenerated VHDL LRShiftFlat.svLRShiftFlat_defs.svh <pre><code>/* A left-right bits shifter (flat version)\n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftFlat_defs.svh\"\n\nmodule LRShiftFlat#(parameter int width = 8)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* direction of shift */\n  input  wire t_enum_ShiftDir             dir,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  always_comb\n  begin\n    case (dir)\n      ShiftDir_Left:  oBits = iBits &lt;&lt; shift;\n      ShiftDir_Right: oBits = iBits &gt;&gt; shift;\n    endcase\n  end\nendmodule\n</code></pre> <pre><code>`ifndef LRSHIFTFLAT_DEFS\n`define LRSHIFTFLAT_DEFS\ntypedef enum logic [0:0] {\n  ShiftDir_Left  = 0,\n  ShiftDir_Right = 1\n} t_enum_ShiftDir;\n\n`endif\n</code></pre> LRShiftFlat.vhdLRShiftFlat_pkg.vhd <pre><code>-- A left-right bits shifter (flat version)\n--\n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftFlat_pkg.all;\n\nentity LRShiftFlat is\ngeneric (\n  width : integer := 8\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- direction of shift \n  dir   : in  t_enum_ShiftDir;\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend LRShiftFlat;\n\narchitecture LRShiftFlat_arch of LRShiftFlat is\nbegin\n  process (all)\n  begin\n    case dir is\n      when ShiftDir_Left  =&gt; oBits &lt;= slv_sll(iBits, to_integer(shift));\n      when ShiftDir_Right =&gt; oBits &lt;= slv_srl(iBits, to_integer(shift));\n    end case;\n  end process;\nend LRShiftFlat_arch;\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\n\npackage LRShiftFlat_pkg is\ntype t_enum_ShiftDir is (\n  ShiftDir_Left, ShiftDir_Right\n);\nfunction bitWidth(A: t_enum_ShiftDir) return integer;\nfunction to_slv(A: t_enum_ShiftDir) return std_logic_vector;\nfunction to_t_enum_ShiftDir(A: std_logic_vector) return t_enum_ShiftDir;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir;\n\n\nend package LRShiftFlat_pkg;\n\npackage body LRShiftFlat_pkg is\nfunction bitWidth(A : t_enum_ShiftDir) return integer is\nbegin\n  return 1;\nend;\nfunction to_slv(A : t_enum_ShiftDir) return std_logic_vector is\n  variable int_val : integer;\nbegin\n  case A is\n    when ShiftDir_Left  =&gt; int_val := 0;\n    when ShiftDir_Right =&gt; int_val := 1;\n  end case;\n  return resize(to_slv(int_val), 1);\nend;\nfunction to_t_enum_ShiftDir(A : std_logic_vector) return t_enum_ShiftDir is\nbegin\n  case to_integer(unsigned(A)) is\n    when 0              =&gt; return ShiftDir_Left;\n    when 1              =&gt; return ShiftDir_Right;\n    when others         =&gt; \n      assert false report \"Unknown state detected!\" severity error;\n      return ShiftDir_Left;\n  end case;\nend;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir is\nbegin\n  if C then\n    return T;\n  else\n    return F;\n  end if;\nend;\n\nend package body LRShiftFlat_pkg;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\nenum ShiftDir extends Encoded:\n  case Left, Right\n\n/** A left-right bits shifter (flat version)\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftFlat(\n    val width: Int &lt;&gt; CONST = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width)       &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** direction of shift */\n  val dir   = ShiftDir          &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width)       &lt;&gt; OUT\n  oBits := dir match\n    case ShiftDir.Left  =&gt; iBits &lt;&lt; shift\n    case ShiftDir.Right =&gt; iBits &gt;&gt; shift\n</code></pre>"},{"location":"user-guide/design-hierarchy/#design-class-inheritance","title":"Design Class Inheritance","text":"<p>DFHDL leverages Scala inheritance to enable sharing functionality between design classes.</p>"},{"location":"user-guide/design-hierarchy/#ShiftGen","title":"<code>ShiftGen</code> example","text":"<p>Generic left and right shifters, design class inheritance example</p> <p>The DFHDL code below demonstrates how to implement both left and right generic shifters efficiently by using a common <code>abstract class</code> named <code>ShiftGen</code>. The <code>width</code> parameter is declared as an abstract class field (without an assigned value) inside the <code>ShiftGen</code> class body. By extending <code>ShiftGen</code>, both <code>LeftShiftGen</code> and <code>RightShiftGen</code> can utilize the IOs already declared in <code>ShiftGen</code>. They only need to explicitly declare the <code>width</code> parameter and implement the shift functionality in their respective class bodies.</p> <pre><code>/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n</code></pre> LeftShiftGen&lt;&lt; shiftiBitsoBitswidthRightShiftGen&gt;&gt; shiftiBitsoBitswidth"},{"location":"user-guide/design-hierarchy/#design-composition-instantiation","title":"Design Composition &amp; Instantiation","text":"<p>DFHDL supports three mechanisms to form a design hierarchy through design instantiation and composition:</p> <ul> <li> <p>Direct Connection Composition - The recommended mechanism for complex design hierarchies with multiple inputs and outputs. Design instantiation and port connection can be done separately, allowing child design ports to be referenced without intermediate variables.</p> </li> <li> <p>Via Connection Composition - A legacy mechanism that connects ports only within a design instantiation. This exists for compatibility with Verilog module instancing and VHDL component instancing. The DFHDL compiler automatically transforms direct connections into via connections.</p> </li> <li> <p>Functional Composition - A method-call mechanism for dataflow designs, primarily used for arithmetic/logic functionality with a single output port. The DFHDL compiler automatically transforms functional composition into direct design composition.</p> </li> </ul> <p>The following sections explore these composition mechanisms using our running example of a bit shifter:</p>"},{"location":"user-guide/design-hierarchy/#direct-connection-composition","title":"Direct Connection Composition","text":"<p>Direct connection composition is the recommended approach for building hierarchical designs in DFHDL. It offers several key advantages:</p> <ol> <li>Separate instantiation and connection - Create child design instances first, then connect their ports later</li> <li>Direct port references - Access child design ports without intermediate variables </li> <li>Flexible connectivity - Connect ports in any order and across multiple statements</li> </ol>"},{"location":"user-guide/design-hierarchy/#syntax","title":"Syntax","text":"<p>The syntax for direct composition follows standard Scala class instantiation, with port connections made via the <code>&lt;&gt;</code> operator:</p> Direct composition syntax<pre><code>//instantiate a child design\nval _childDesignName_ = _designClass_(_params_)\n//port connection (repeat for each child port)\n_childDesignName_._childPort_ &lt;&gt; _connectedValue_ \n</code></pre> <p>Where:</p> <ul> <li> <p><code>_childDesignName_</code> - The instance name for the child design. This name is preserved by the DFHDL compiler and used in error messages and generated artifacts. See the naming section for details.</p> </li> <li> <p><code>_designClass_</code> - The design class to instantiate.</p> </li> <li> <p><code>_params_</code> - Parameters for the child design. Empty parentheses <code>()</code> are required even if no parameters are needed. Parameters can be specified:</p> <ul> <li>As ordered values (e.g., <code>Counter(8, Up)</code>)</li> <li>As named parameters (e.g., <code>Counter(width = 8, dir = Up)</code>) </li> <li>Parameters with default values can be omitted</li> </ul> </li> <li> <p><code>_childPort_</code> - The port of the child design to connect.</p> </li> <li> <p><code>_connectedValue_</code> - The value to connect to the child port. Can be:</p> <ul> <li>A constant</li> <li>A variable</li> <li>A port of the parent design</li> <li>A port of another child design instance</li> </ul> </li> </ul> <p>The <code>&lt;&gt;</code> connection operator has no explicit directionality - it automatically infers producer/consumer relationships based on the connected value types and scope. See the connectivity section for details.</p>"},{"location":"user-guide/design-hierarchy/#LRShiftDirect","title":"<code>LRShiftDirect</code> example","text":"<p>Generic left-right shifter using direct connection composition</p> <p>The code below implements a generic left-right shifter named <code>LRShiftDirect</code>. This design provides the same functionality as <code>LRShiftFlat</code>, but uses composition to split left and right shift operations into separate designs. The implementation leverages the design class inheritance shown in the <code>ShiftGen</code> example.</p> <p>Note</p> <p>While this example demonstrates direct composition, a flat approach is often preferable for simpler designs. For complex designs, however, splitting functionality into sub-components promotes code reuse, simplifies verification, and follows good design practices.</p> <pre><code>/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n\nenum ShiftDir extends Encoded:\n  case Left, Right\n\n/** A left-right bits shifter, direct composition\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftDirect(\n    val width: Int &lt;&gt; CONST = 8\n) extends ShiftGen:\n  /** direction of shift */\n  val dir   = ShiftDir &lt;&gt; IN\n  val lshifter = LeftShiftGen(width)\n  val rshifter = RightShiftGen(width)\n  lshifter.iBits &lt;&gt; iBits\n  lshifter.shift &lt;&gt; shift\n  rshifter.iBits &lt;&gt; iBits\n  rshifter.shift &lt;&gt; shift\n  oBits := dir match\n    case ShiftDir.Left  =&gt; lshifter.oBits\n    case ShiftDir.Right =&gt; rshifter.oBits\nend LRShiftDirect\n</code></pre> LeftShiftGen&lt;&lt; shiftiBitsoBitswidthRightShiftGen&gt;&gt; shiftiBitsoBitswidthLRShiftDirectlshifterLeftShiftGenshiftiBitsoBitswidthrshifterRightShiftGenshiftiBitsoBitswidthmux dirshiftiBitsoBitswidth Generated VerilogGenerated VHDL LRShiftDirect.svLeftShiftGen.svRightShiftGen.svLRShiftDirect_defs.svh <pre><code>/* A left-right bits shifter, direct composition\n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftDirect_defs.svh\"\n\nmodule LRShiftDirect#(parameter int width = 8)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits,\n  /* direction of shift */\n  input  wire t_enum_ShiftDir             dir\n);\n  `include \"dfhdl_defs.svh\"\n  logic [width - 1:0] lshifter_iBits;\n  logic [$clog2(width) - 1:0] lshifter_shift;\n  logic [width - 1:0] lshifter_oBits;\n  logic [width - 1:0] rshifter_iBits;\n  logic [$clog2(width) - 1:0] rshifter_shift;\n  logic [width - 1:0] rshifter_oBits;\n  LeftShiftGen #(\n    .width (width)\n  ) lshifter(\n    .iBits /*&lt;--*/ (lshifter_iBits),\n    .shift /*&lt;--*/ (lshifter_shift),\n    .oBits /*--&gt;*/ (lshifter_oBits)\n  );\n  RightShiftGen #(\n    .width (width)\n  ) rshifter(\n    .iBits /*&lt;--*/ (rshifter_iBits),\n    .shift /*&lt;--*/ (rshifter_shift),\n    .oBits /*--&gt;*/ (rshifter_oBits)\n  );\n  assign lshifter_iBits = iBits;\n  assign lshifter_shift = shift;\n  assign rshifter_iBits = iBits;\n  assign rshifter_shift = shift;\n  always_comb\n  begin\n    case (dir)\n      ShiftDir_Left:  oBits = lshifter_oBits;\n      ShiftDir_Right: oBits = rshifter_oBits;\n    endcase\n  end\nendmodule\n</code></pre> <pre><code>/* A generic left shifter \n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftDirect_defs.svh\"\n\nmodule LeftShiftGen#(parameter int width)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &lt;&lt; shift;\nendmodule\n</code></pre> <pre><code>/* A generic right shifter \n\n   @param width\n     the width of the input and output bits\n  */\n`default_nettype none\n`timescale 1ns/1ps\n`include \"LRShiftDirect_defs.svh\"\n\nmodule RightShiftGen#(parameter int width)(\n  /* bits input */\n  input  wire logic [width - 1:0]         iBits,\n  /* requested shift */\n  input  wire logic [$clog2(width) - 1:0] shift,\n  /* bits output */\n  output      logic [width - 1:0]         oBits\n);\n  `include \"dfhdl_defs.svh\"\n  assign oBits = iBits &gt;&gt; shift;\nendmodule\n</code></pre> <pre><code>`ifndef LRSHIFTDIRECT_DEFS\n`define LRSHIFTDIRECT_DEFS\ntypedef enum logic [0:0] {\n  ShiftDir_Left  = 0,\n  ShiftDir_Right = 1\n} t_enum_ShiftDir;\n\n`endif\n</code></pre> LRShiftDirect.vhdLeftShiftGen.vhdRightShiftGen.vhdLRShiftDirect_pkg.vhd <pre><code>-- A left-right bits shifter, direct composition\n--\n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftDirect_pkg.all;\n\nentity LRShiftDirect is\ngeneric (\n  width : integer := 8\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0);\n  -- direction of shift \n  dir   : in  t_enum_ShiftDir\n);\nend LRShiftDirect;\n\narchitecture LRShiftDirect_arch of LRShiftDirect is\n  signal lshifter_iBits : std_logic_vector(width - 1 downto 0);\n  signal lshifter_shift : unsigned(clog2(width) - 1 downto 0);\n  signal lshifter_oBits : std_logic_vector(width - 1 downto 0);\n  signal rshifter_iBits : std_logic_vector(width - 1 downto 0);\n  signal rshifter_shift : unsigned(clog2(width) - 1 downto 0);\n  signal rshifter_oBits : std_logic_vector(width - 1 downto 0);\nbegin\n  lshifter : entity work.LeftShiftGen(LeftShiftGen_arch) generic map (\n    width        =&gt; width\n  ) port map (\n    iBits        =&gt; lshifter_iBits,\n    shift        =&gt; lshifter_shift,\n    oBits        =&gt; lshifter_oBits\n  );\n  rshifter : entity work.RightShiftGen(RightShiftGen_arch) generic map (\n    width        =&gt; width\n  ) port map (\n    iBits        =&gt; rshifter_iBits,\n    shift        =&gt; rshifter_shift,\n    oBits        =&gt; rshifter_oBits\n  );\n  lshifter_iBits &lt;= iBits;\n  lshifter_shift &lt;= shift;\n  rshifter_iBits &lt;= iBits;\n  rshifter_shift &lt;= shift;\n  process (all)\n  begin\n    case dir is\n      when ShiftDir_Left  =&gt; oBits &lt;= lshifter_oBits;\n      when ShiftDir_Right =&gt; oBits &lt;= rshifter_oBits;\n    end case;\n  end process;\nend LRShiftDirect_arch;\n</code></pre> <pre><code>-- A generic left shifter \n--   \n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftDirect_pkg.all;\n\nentity LeftShiftGen is\ngeneric (\n  width : integer\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend LeftShiftGen;\n\narchitecture LeftShiftGen_arch of LeftShiftGen is\nbegin\n  oBits &lt;= slv_sll(iBits, to_integer(shift));\nend LeftShiftGen_arch;\n</code></pre> <pre><code>-- A generic right shifter \n--   \n-- @param width\n--   the width of the input and output bits\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\nuse work.LRShiftDirect_pkg.all;\n\nentity RightShiftGen is\ngeneric (\n  width : integer\n);\nport (\n  -- bits input \n  iBits : in  std_logic_vector(width - 1 downto 0);\n  -- requested shift \n  shift : in  unsigned(clog2(width) - 1 downto 0);\n  -- bits output \n  oBits : out std_logic_vector(width - 1 downto 0)\n);\nend RightShiftGen;\n\narchitecture RightShiftGen_arch of RightShiftGen is\nbegin\n  oBits &lt;= slv_srl(iBits, to_integer(shift));\nend RightShiftGen_arch;\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.dfhdl_pkg.all;\n\npackage LRShiftDirect_pkg is\ntype t_enum_ShiftDir is (\n  ShiftDir_Left, ShiftDir_Right\n);\nfunction bitWidth(A: t_enum_ShiftDir) return integer;\nfunction to_slv(A: t_enum_ShiftDir) return std_logic_vector;\nfunction to_t_enum_ShiftDir(A: std_logic_vector) return t_enum_ShiftDir;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir;\n\n\nend package LRShiftDirect_pkg;\n\npackage body LRShiftDirect_pkg is\nfunction bitWidth(A : t_enum_ShiftDir) return integer is\nbegin\n  return 1;\nend;\nfunction to_slv(A : t_enum_ShiftDir) return std_logic_vector is\n  variable int_val : integer;\nbegin\n  case A is\n    when ShiftDir_Left  =&gt; int_val := 0;\n    when ShiftDir_Right =&gt; int_val := 1;\n  end case;\n  return resize(to_slv(int_val), 1);\nend;\nfunction to_t_enum_ShiftDir(A : std_logic_vector) return t_enum_ShiftDir is\nbegin\n  case to_integer(unsigned(A)) is\n    when 0              =&gt; return ShiftDir_Left;\n    when 1              =&gt; return ShiftDir_Right;\n    when others         =&gt; \n      assert false report \"Unknown state detected!\" severity error;\n      return ShiftDir_Left;\n  end case;\nend;\nfunction bool_sel(C : boolean; T : t_enum_ShiftDir; F : t_enum_ShiftDir) return t_enum_ShiftDir is\nbegin\n  if C then\n    return T;\n  else\n    return F;\n  end if;\nend;\n\nend package body LRShiftDirect_pkg;\n</code></pre> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n\n/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n\nenum ShiftDir extends Encoded:\n  case Left, Right\n\n/** A left-right bits shifter, direct composition\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftDirect(\n    val width: Int &lt;&gt; CONST = 8\n) extends ShiftGen:\n  /** direction of shift */\n  val dir   = ShiftDir &lt;&gt; IN\n  val lshifter = LeftShiftGen(width)\n  val rshifter = RightShiftGen(width)\n  lshifter.iBits &lt;&gt; iBits\n  lshifter.shift &lt;&gt; shift\n  rshifter.iBits &lt;&gt; iBits\n  rshifter.shift &lt;&gt; shift\n  oBits := dir match\n    case ShiftDir.Left  =&gt; lshifter.oBits\n    case ShiftDir.Right =&gt; rshifter.oBits\nend LRShiftDirect\n</code></pre>"},{"location":"user-guide/design-hierarchy/#via-connection-composition","title":"Via Connection Composition","text":"<p>Via connection composition is a legacy mechanism that connects child design ports within the child design instantiation. It exists for compatibility with Verilog module instantiation and VHDL component instantiation. The DFHDL compiler automatically transforms direct connections into via connections.</p>"},{"location":"user-guide/design-hierarchy/#syntax_1","title":"Syntax","text":"<p>The syntax for via composition uses Scala anonymous class instantiation, with port connections made inside the instantiation block:</p> Via composition syntax<pre><code>//instantiate a child design\nval _childDesignName_ = new _designClass_(_params_):\n    //port connection (repeat for each child port)\n    _childPort_ &lt;&gt; _connectedValue_\n</code></pre> <p>The <code>new</code> keyword and colon <code>:</code> syntax creates an anonymous class instance. Port connections must be made within this instantiation block, similar to Verilog module and VHDL component instantiation. This means connected values must be declared before they are used in the connection operation.</p> <p>Handling port name collisions between parent and child designs</p> <p>When connecting ports with the same name in parent and child designs, Scala's name shadowing rules will favor the child port name. For example, when connecting the <code>iBits</code> port of <code>LeftShiftGen</code> to the <code>iBits</code> port of <code>LRShiftVia</code>, we need a way to reference the parent's <code>iBits</code> port from within the child design.</p> <p>To solve this, we use Scala's class self reference feature and name it <code>parent</code>, as shown in the <code>LRShiftVia</code> example below.</p>"},{"location":"user-guide/design-hierarchy/#LRShiftVia","title":"<code>LRShiftVia</code> example","text":"<p>Generic left-right shifter, via composition example</p> <p>The DFHDL code below implements the same generic left-right shifter composition seen in the <code>LRShiftDirect</code> example, but uses via composition instead of direct composition. We define a <code>parent</code> self reference for the <code>LRShiftVia</code> design to refer to the <code>LRShiftVia</code> design within the <code>lshifter: LeftShiftGen</code> and <code>rshifter: RightShiftGen</code> child designs. We also use intermediate variables for the <code>oBits</code> ports of the <code>lshifter</code> and <code>rshifter</code> child designs and apply the multiplexer logic to select between them.</p> <pre><code>/** A left-right bits shifter, via composition\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftVia(\n    val width: Int &lt;&gt; CONST = 8\n) extends ShiftGen:\n  parent =&gt; //parent design reference\n  /** direction of shift */\n  val dir = ShiftDir &lt;&gt; IN\n  val lshifter_oBits = Bits(width) &lt;&gt; VAR\n  val lshifter = new LeftShiftGen(width):\n    iBits &lt;&gt; parent.iBits\n    shift &lt;&gt; parent.shift\n    oBits &lt;&gt; lshifter_oBits\n  val rshifter_oBits = Bits(width) &lt;&gt; VAR\n  val rshifter = new RightShiftGen(width):\n    iBits &lt;&gt; parent.iBits\n    shift &lt;&gt; parent.shift\n    oBits &lt;&gt; rshifter_oBits\n  oBits := dir match\n    case ShiftDir.Left  =&gt; lshifter_oBits\n    case ShiftDir.Right =&gt; rshifter_oBits\nend LRShiftVia\n</code></pre> <p>Another interesting example is the automatic transformation of a direct composition design into a via composition design:</p> <p>Direct-to-via compilation transformation example</p> <p>The code below shows how the DFHDL compiler transforms the <code>LRShiftDirect</code> design into via composition form. For each child design port, the compiler:</p> <ol> <li>Creates an intermediate variable with the same type</li> <li>Connects the child port to this variable inside the child's instantiation block</li> <li>Connects the variable to the appropriate value in the parent design</li> </ol> <p><pre><code>class LRShiftDirect(val width: Int &lt;&gt; CONST = 8) extends EDDesign:\n  /** bits input */\n  val iBits          = Bits(width)        &lt;&gt; IN\n  /** requested shift */\n  val shift          = UInt(clog2(width)) &lt;&gt; IN\n  /** bits output */\n  val oBits          = Bits(width)        &lt;&gt; OUT\n  /** direction of shift */\n  val dir            = ShiftDir           &lt;&gt; IN\n  val lshifter_iBits = Bits(width)        &lt;&gt; VAR\n  val lshifter_shift = UInt(clog2(width)) &lt;&gt; VAR\n  val lshifter_oBits = Bits(width)        &lt;&gt; VAR\n  val lshifter = new LeftShiftGen(width = width):\n    this.iBits   &lt;&gt;/*&lt;--*/ lshifter_iBits\n    this.shift   &lt;&gt;/*&lt;--*/ lshifter_shift\n    this.oBits   &lt;&gt;/*--&gt;*/ lshifter_oBits\n  val rshifter_iBits = Bits(width)        &lt;&gt; VAR\n  val rshifter_shift = UInt(clog2(width)) &lt;&gt; VAR\n  val rshifter_oBits = Bits(width)        &lt;&gt; VAR\n  val rshifter = new RightShiftGen(width = width):\n    this.iBits   &lt;&gt;/*&lt;--*/ rshifter_iBits\n    this.shift   &lt;&gt;/*&lt;--*/ rshifter_shift\n    this.oBits   &lt;&gt;/*--&gt;*/ rshifter_oBits\n  lshifter_iBits &lt;&gt; iBits\n  lshifter_shift &lt;&gt; shift\n  rshifter_iBits &lt;&gt; iBits\n  rshifter_shift &lt;&gt; shift\n  process(all):\n    dir match\n      case ShiftDir.Left  =&gt; oBits := lshifter_oBits\n      case ShiftDir.Right =&gt; oBits := rshifter_oBits\n    end match\nend LRShiftDirect\n</code></pre> Note how the compiler adds comments (<code>/*&lt;--*/</code> and <code>/*--&gt;*/</code>) to indicate the direction of data flow in the child design port connections.</p> <p>The following runnable example is the same as the <code>LRShiftDirect</code> example, except for the default compiler options, which we altered to print the compiled design in DFHDL code format rather than the backend code format.</p> Runnable example <pre><code>import dfhdl.*\ngiven options.CompilerOptions.Backend = backends.verilog\n//disable the default backend code print (in scastie)\ngiven options.CompilerOptions.PrintBackendCode = false\n//enable the DFHDL code print after compilation\ngiven options.CompilerOptions.PrintDFHDLCode = true\n\n/** A generic abstract shifter with only IOs */\nabstract class ShiftGen extends RTDesign:\n  /** the width of the input and output bits */\n  val width: Int &lt;&gt; CONST //abstract\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n\n/** A generic left shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass LeftShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &lt;&lt; shift\n\n/** A generic right shifter \n  *   \n  * @param width\n  *   the width of the input and output bits\n  */\nclass RightShiftGen(\n    val width: Int &lt;&gt; CONST\n) extends ShiftGen:\n  oBits := iBits &gt;&gt; shift\n\nenum ShiftDir extends Encoded:\n  case Left, Right\n\n/** A left-right bits shifter, direct composition\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftDirect(\n    val width: Int &lt;&gt; CONST = 8\n) extends ShiftGen:\n  /** direction of shift */\n  val dir   = ShiftDir &lt;&gt; IN\n  val lshifter = LeftShiftGen(width)\n  val rshifter = RightShiftGen(width)\n  lshifter.iBits &lt;&gt; iBits\n  lshifter.shift &lt;&gt; shift\n  rshifter.iBits &lt;&gt; iBits\n  rshifter.shift &lt;&gt; shift\n  oBits := dir match\n    case ShiftDir.Left  =&gt; lshifter.oBits\n    case ShiftDir.Right =&gt; rshifter.oBits\nend LRShiftDirect\n</code></pre>"},{"location":"user-guide/design-hierarchy/#functional-composition","title":"Functional Composition","text":"<p>Functional composition is a method-call based mechanism primarily used for dataflow designs with a single output. It's particularly useful for arithmetic and logic operations. The DFHDL compiler automatically transforms functional composition into direct design composition.</p>"},{"location":"user-guide/design-hierarchy/#syntax_2","title":"Syntax","text":"<p>The syntax for functional composition follows standard Scala method declaration and invocation to declare and invoke design definitions (aka design methods or design functions):</p> Functional composition syntax<pre><code>//declare a design definition\ndef _designName_(\n    _param1_: _type1_ &lt;&gt; VAL,\n    _param2_: _type2_ &lt;&gt; VAL,\n    ...,\n    _paramN_: _typeN_ &lt;&gt; VAL\n): _returnType_ &lt;&gt; DFRET = _expression_\n\n//invoke the design definition\n_designName_(_param1_, _param2_, ..., _paramN_)\n</code></pre> <p>Where:</p> <ul> <li><code>_designName_</code> - The name of the design definition</li> <li><code>_paramN_</code> - Input parameters that act as design ports</li> <li><code>_typeN_</code> - DFHDL types for the parameters</li> <li><code>_returnType_</code> - DFHDL type for the output port</li> <li><code>&lt;&gt; VAL</code> - Marks parameters as design input ports</li> <li><code>&lt;&gt; DFRET</code> - Marks the return type as a design output port</li> <li><code>_expression_</code> - The design functionality</li> </ul>"},{"location":"user-guide/design-hierarchy/#LRShiftFunc","title":"<code>LRShiftFunc</code> example","text":"<p>Generic left-right shifter using functional composition</p> <p>The code below implements the same generic left-right shifter functionality seen in previous examples, but uses functional composition. The implementation is split into three function designs:</p> <ol> <li><code>LeftShiftGen</code> - Performs left shift operation</li> <li><code>RightShiftGen</code> - Performs right shift operation  </li> <li><code>LRShiftFunc</code> - Top-level function that selects between left/right shift</li> </ol> <p>Since functions can't be top-level designs in DFHDL, we wrap <code>LRShiftFunc</code> in a top-level design class <code>LRShiftFuncWrapper</code>.</p> <pre><code>/** A generic left shifter */\ndef LeftShiftGen(\n  iBits: Bits[Int] &lt;&gt; VAL,\n  shift: UInt[Int] &lt;&gt; VAL\n): Bits[Int] &lt;&gt; RTRET = iBits &lt;&lt; shift\n\n/** A generic right shifter */\ndef RightShiftGen(\n  iBits: Bits[Int] &lt;&gt; VAL,\n  shift: UInt[Int] &lt;&gt; VAL\n): Bits[Int] &lt;&gt; RTRET = iBits &gt;&gt; shift\n\nenum ShiftDir extends Encoded:\n  case Left, Right\n\n/** A left-right bits shifter, functional composition */\ndef LRShiftFunc(\n  iBits: Bits[Int] &lt;&gt; VAL,\n  shift: UInt[Int] &lt;&gt; VAL,\n  dir: ShiftDir &lt;&gt; VAL\n): Bits[Int] &lt;&gt; RTRET =\n  dir match\n    case ShiftDir.Left  =&gt; LeftShiftGen(iBits, shift)\n    case ShiftDir.Right =&gt; RightShiftGen(iBits, shift)\n\n/** A left-right bits shifter wrapper\n  * (required as top-level design for functional composition)\n  *\n  * @param width\n  *   the width of the input and output bits\n  */\n@top class LRShiftFuncWrapper(\n    val width: Int &lt;&gt; CONST = 8\n) extends RTDesign:\n  /** bits input */\n  val iBits = Bits(width) &lt;&gt; IN\n  /** requested shift */\n  val shift = UInt.until(width) &lt;&gt; IN\n  /** bits output */\n  val oBits = Bits(width) &lt;&gt; OUT\n  /** direction of shift */\n  val dir   = ShiftDir &lt;&gt; IN\n\n  oBits &lt;&gt; LRShiftFunc(iBits, shift, dir)\nend LRShiftFuncWrapper\n</code></pre> LRShiftFuncWrapperLRShiftFuncLeftShiftGen&lt;&lt; shiftiBitsoBitsRightShiftGen&gt;&gt; shiftiBitsoBitsmux dirshiftiBitsoBitsdirshiftiBitsoBitswidth <p>Advantages of functional composition</p> <p>Functional composition offers several benefits:</p> <ol> <li>Concise syntax - No need for explicit port declarations and connections</li> <li>Natural expression - Operations can be written in a more natural mathematical style</li> <li>Easy reuse - Functions can be composed and reused easily</li> <li>Type safety - Scala's type system ensures correct port connections</li> </ol>"},{"location":"user-guide/errors/","title":"Errors &amp; Warnings","text":"<p>DFiant-related compiler errors &amp; warnings and ways to resolve them</p>"},{"location":"user-guide/errors/#missing-context","title":"Missing Context","text":"<p>TBD</p>"},{"location":"user-guide/errors/#dont-use-var-with-dataflow-valuesvariables","title":"Don't use <code>var</code> with dataflow values/variables","text":"<p>TBD</p>"},{"location":"user-guide/interfaces/","title":"Interfaces [WIP]","text":""},{"location":"user-guide/meta/","title":"Meta Hardware Description","text":""},{"location":"user-guide/methods/","title":"Functions / Methods","text":""},{"location":"user-guide/naming/","title":"Naming","text":""},{"location":"user-guide/processes/","title":"Processes","text":""},{"location":"user-guide/simulation/","title":"Simulation","text":""},{"location":"user-guide/state/","title":"Index","text":""},{"location":"user-guide/state/#state-initialization","title":"State &amp; Initialization","text":"<p>Semantically, every DFiant dataflow variable references a token stream (TS). </p> <ul> <li> <p>Unless stated otherwise, all dataflow variables are always consuming and always producing.</p> </li> <li> <p>Previous token initialization:</p> </li> <li> <p>The token history stream can be initialized.</p> </li> <li> <p>Initialization does not mutate the dataflow variable.</p> </li> <li> <p>Initialization has no effect on the TS. Only when using <code>prev</code> the initialization is placed on the TS reference.</p> </li> <li> <p><code>init</code> returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. </p> </li> <li> <p>Bubble tokens (?) :</p> </li> <li> <p>Produced when a <code>prev</code> is called on a non-initialized dataflow variable. E.g.,</p> Code Init Token Stream <code>in : DFUInt[32]</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>in.prev</code> <code>?</code> <code>?, 2, 3, 1, 5, 9</code> <code>in.prev(2)</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>in.prev.prev</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>val in1 = in.init(1); in1</code> <code>1</code> <code>2, 3, 1, 5, 9</code> <code>in1.prev</code> <code>1</code> <code>1, 2, 3, 1, 5, 9</code> <code>in1.prev(2)</code> <code>1</code> <code>1, 1, 2, 3, 1, 5, 9</code> <code>in1.prev.init(8)</code> <code>8</code> <code>1, 2, 3, 1, 5, 9</code> <code>val innew = DFUInt(32) := in1; innew</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>val ins7 = in.init(7, ?); ins7</code> <code>(7, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins7.prev</code> <code>?</code> <code>7, 2, 3, 1, 5, 9</code> <code>val ins78 = in.init(7, 8, ?); ins78</code> <code>(7, 8, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins78.prev</code> <code>(8, ?)</code> <code>7, 2, 3, 1, 5, 9</code> <code>ins78.prev(2)</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> <code>in.init(7).prev.init(8, ?).prev</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> </li> <li> <p>Bubbles are like any regular-value tokens in terms of consumption and production rules.</p> </li> <li> <p>Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue.</p> </li> <li> <p>Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., </p> <pre><code>def foo(a : DFUInt(8)) = a + a.prev\n//'in' is token stream of:    2, 3, 1, 5, 9\n//'foo(in)' returns:          ?, 5, 4, 6, 14\n</code></pre> </li> <li> <p><code>prev</code> maintains Distributivity through basic operations e.g.: </p> <p><code>(a + b).prev</code> \u2257 <code>a.prev + b.prev</code> (timeless TS equality).</p> Code Init Token Stream <code>inL : DFUInt(32)</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>inR : DFUInt(32)</code> <code>?</code> <code>4, 0, 2</code> <code>inL + inR</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2</code> <code>=</code><code>6, 3, 3</code> <code>inL + inR.prev</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>?, 4, 0, 2</code> <code>=</code><code>?, 7, 1, 7</code> <code>inL.init(1) + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1, ?) + inR.init(3).prev</code> <code>(1, ?)</code> <code>+</code><code>3</code> <code>=</code><code>(4, ?)</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1) + inR.init(3, ?).prev</code> <code>1</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1).prev + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>1, 2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>4, 6, 3, 3</code> <code>(inL.init(1) + inR.init(3)).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>(2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2)</code> <code>.prev =</code><code>4, 6, 3, 3</code> </li> <li> <p>Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags.</p> </li> <li> <p>Casting:</p> </li> <li> <p>Parts of a bits vector can be bubbles while others normal values.</p> </li> <li> <p>However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.</p> </li> </ul>"},{"location":"user-guide/state/#time-invariance","title":"Time Invariance","text":""},{"location":"user-guide/synthesis/","title":"Synthesis","text":""},{"location":"user-guide/type-system/","title":"Type System","text":""},{"location":"user-guide/type-system/#type-system","title":"Type System","text":"<p>DFHDL is a Scala library and thus inherently supports type-safe and modern language constructs. This chapter covers the rules and API of this type system. </p> Check out the benefits of the DFHDL type system <ul> <li> <p> Strongly-typed</p> <p>Most type checks are performed statically, enforcing strict rules that help avoid ambiguity.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN \n//2-bit unsigned input\nval u2 = UInt(2) &lt;&gt; IN \nval y1 = u8 - u2 //ok\n// Error prevents ambiguous behavior \n// when a wider num is subtracted from \n// a narrow num.\nval y2 = u2 - u8 //error\n</code></pre> </p> </li> <li> <p> Bit-accurate</p> <p>Each DFHDL value has a defined bit-width, which is used to enforce rules that prevent data loss.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN  \n//8-bit signed output\nval s8 = SInt(8) &lt;&gt; OUT \n// Error prevents data loss when u8 is \n// converted to a 9-bit signed to be \n// assigned to s8, which is only 8-bits \n// wide.\ns8 := u8 //error\n</code></pre> </p> </li> <li> <p> Composable</p> <p>Types can be composed through structs or tuples to form new, combined types.</p> <pre><code>//new Pixel type as a structure\n//of two unsigned 8-bit numbers\ncase class Pixel(\n  x: UInt[8] &lt;&gt; VAL,\n  y: UInt[8] &lt;&gt; VAL\n) extends Struct\n\nval pixel = Pixel &lt;&gt; VAR\n//select and assign fields\npixel.x := pixel.y\n</code></pre> </li> <li> <p> Expandable</p> <p>New types can be defined, and methods can be added for entirely new or existing types.</p> <pre><code>//new AESByte type of unsigned 8-bit num\ncase class AESByte() \n  extends Opaque(UInt(8))\n//define addition between two AESByte\n//values as a xor operation\nextension (lhs: AESByte &lt;&gt; VAL)\n  def +(rhs: AESByte &lt;&gt; VAL): AESByte &lt;&gt; DFRET =\n    (lhs.actual ^ rhs.actual).as(AESByte)\nval x, y = AESByte &lt;&gt; VAR\nval z = x + y //actually XOR\n</code></pre> </li> </ul> <p>DFHDL Values</p> <p>Each DFHDL value is simply a Scala object that has two critical fields:</p> <ul> <li> <p> (Shape) Type, aka DFType</p> <p>Determines the bit-width and bit-structure of the value. Currently the supported types are: </p> <ul> <li>DFHDL Bit/Boolean: <code>Bit</code>/<code>Boolean</code> </li> <li>DFHDL Bit Vector: <code>Bits</code></li> <li>DFHDL Integer: <code>UInt</code>/<code>SInt</code>/<code>Int</code></li> <li> <p>DFHDL Fix-Point (future work)</p> </li> <li> <p>DFHDL Flt-Point (future work)</p> </li> <li> <p>DFHDL String (future work)</p> </li> <li>DFHDL Enumeration: <code>enum ... extends Encoded</code></li> <li>DFHDL Vector: <code>_CellType_ X _Dim_</code></li> <li>DFHDL Structure: <code>... extends Struct</code></li> <li>DFHDL Tuple: <code>(T1, T2, ..., Tn)</code></li> <li>DFHDL Opaque: <code>... extends Opaque</code></li> <li>DFHDL Double: <code>Double</code></li> <li>DFHDL Time/Freq: <code>Time</code>/<code>Freq</code></li> <li>DFHDL Unit (Void): <code>Unit</code></li> </ul> </li> <li> <p> (Access) Modifier</p> <p>Determines what kind of access the user has on the value. User explicit modifiers:</p> <ul> <li>Variable: <code>VAR[.REG][.SHARED]</code></li> <li>Port: <code>IN</code>/<code>OUT[.REG]</code>/<code>INOUT</code></li> <li>Constant: <code>CONST</code></li> <li>Struct Field: <code>VAL</code></li> <li>Method Param: <code>VAL</code></li> <li>Method Return: <code>DFRET</code>/<code>RTRET</code>/<code>EDRET</code></li> </ul> <p>Although this mechanism can be quite complex under the hood, the explicit modifiers available to the user are straightforward.</p> </li> </ul> Internal Type-System Hierarchy (For Advanced Users) <p>DFHDL brings type-driven development concepts to hardware design, by creating an extensible type class hierarchy. Any DFHDL value is a Scala object instance of the class <code>DFVal[T &lt;: DFTypeAny, M &lt;: ModifierAny]</code>, where <code>T</code> is the type (shape) of value and <code>M</code> is a modifier that sets additional characteristics of the DFHDL value, like if it's assignable, connectable, initializable, etc. </p> <p> </p> <p>For example, the Scala value <code>x</code> which references a port declared like <code>val x = Boolean &lt;&gt; IN</code> has the type <code>DFVal[DFBool, Modifier.Dcl]</code>.</p>"},{"location":"user-guide/type-system/#Dcl","title":"Variable and Port Declarations","text":"<p>Ports are DFHDL values that define the inputs and outputs of a design. Variables are DFHDL values that represent internal design wiring, logic, or state.</p>"},{"location":"user-guide/type-system/#dcl-syntax","title":"Syntax","text":"Port/Variable declaration syntax<pre><code>val _name_ = _dftype_ &lt;&gt; _modifier_ [init _const_]\n</code></pre> <ul> <li><code>_name_</code> is the Scala value name reference for the DFHDL port/variable you constructed. The DFHDL compiler preserves this name and uses it in error messages and the final generated artifacts (e.g., Verilog module or VHDL entity port names). <code>_name_</code> can also be a series of names separated by commas to declare several equivalent ports/variables. More information is available under the naming section.</li> <li><code>_dftype_</code> is set according to the shape type (DFType) of the DFHDL value. Each of the supported DFTypes have their own constructors. See relevant sections for the DFHDL DFType you wish to construct.</li> <li><code>&lt;&gt;</code> is the operator applied between a <code>_dftype_</code> and a <code>_modifier_</code> to construct the Scala value that represents a DFHDL variable or port accordingly. Note: the same <code>&lt;&gt;</code> operator is used as a language construct for declaring connections. Thanks to Scala method overloading, <code>&lt;&gt;</code> can be shared for both use-cases with no issues (due to the Scala argument type difference). </li> <li><code>_modifier_</code> is set with one of the following: <ul> <li><code>VAR</code> - to construct a variable</li> <li><code>IN</code> - to construct an input port</li> <li><code>OUT</code> - to construct an output port</li> <li><code>INOUT</code> - to construct a bidirectional input-output port</li> <li><code>VAR.REG</code> / <code>OUT.REG</code> - to construct a registered variable or output port (available only in RT domains) </li> <li><code>VAR.SHARED</code> - to construct a shared variable that can be assigned in more than one domain (this feature is to be used scarcely, to model unique designs like True Dual-Port RAM)</li> </ul> </li> <li><code>init</code> is an optional construct to initialize the DFHDL variable/port declaration history with the applied <code>_const_</code> value.</li> <li><code>_const_</code> is the state history initialization value which must be a constant that is supported by the DFType <code>_dftype_</code>. Under DF domain only, <code>_const_</code> can also be represented by a Scala Tuple sequence of constant initialization values that are supported by the DFType <code>_dftype_</code>.</li> </ul> Port/Variable declaration examples<pre><code>class Foo extends DFDesign:\n  //8-bit unsigned integer input port named 'i', \n  //initialized with the value 27\n  val i = UInt(8)    &lt;&gt; IN  init 27\n\n  //single bit output port named 'o' \n  //with a sequence history (0, 1, 0) init\n  //(possible under DF domain only)\n  val o = Bit        &lt;&gt; OUT init (0, 1, 0)\n\n  //5 element vector of 8-bit vector cells \n  //variable named 'v' with no init\n  val v = Bits(8) X 5 &lt;&gt; VAR\n\n  //multiple equivalent single bit input port \n  //declarations named 'a', 'b', and 'c'\n  val a, b, c = Bit   &lt;&gt; IN\n</code></pre> Transitioning from Verilog <p>TODO</p> Transitioning from VHDL <p>TODO</p>"},{"location":"user-guide/type-system/#dcl-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#dcl-scope","title":"Scope","text":"<ul> <li> <p>Variables can be declared in any DFHDL scope, except global scope, meaning within DFHDL designs, domains, interfaces, methods, processes, and conditional blocks. <pre><code>//error: Port/Variable declarations cannot be global\nval x = Bit &lt;&gt; VAR \nclass Foo extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n</code></pre></p> </li> <li> <p>Ports can only be declared at the scopes of DFHDL designs, domains, and interfaces. Other scopes are not allowed. <pre><code>class Foo extends DFDesign:\n  val i = Boolean &lt;&gt; IN\n  if (i)\n    //error: Ports can only be directly owned by a design, a domain or an interface.\n    val o = Bit &lt;&gt; OUT \n    o := 0\n</code></pre></p> </li> </ul>"},{"location":"user-guide/type-system/#dcl-naming","title":"Naming","text":"<p>Ports and variables must always be named, and cannot be anonymous. </p> Anonymous declaration elaboration error example<pre><code>class Foo extends DFDesign:\n  //elaboration error: Unable to determine names for the members declared at the following positions\n  Bit &lt;&gt; OUT \n</code></pre> <p>As you'll read later on, constants and other values can be anonymous.</p>"},{"location":"user-guide/type-system/#dcl-connectable","title":"Connectable","text":"<p>Ports and variables are connectable, meaning they can be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.  For input ports this occurs outside their design scope, while connecting to an external value.  For output ports and variables this occurs only within their design scope, while connecting to an internal value. <pre><code>class ID extends DFDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  y &lt;&gt; x //connecting x to y\n</code></pre></p>"},{"location":"user-guide/type-system/#dcl-assignable","title":"Assignable (Mutable)","text":"<p>Output ports, input-output ports, and variables are assignable (mutable), when they can be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation, which occurs only within their design scope. Input ports can never be assigned (are immutable). Registered ports and variables are assignable only when referencing their registers' input via <code>.din</code> selection (referencing a register without <code>.din</code> is always considered to be its output, which is immutable). </p> <p>Assignment semantics are a key difference between the different design domains DFHDL has to offer. Here are some basic examples: <pre><code>class Foo1 extends DFDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  //dataflow assignment of x to y\n  y := x\n\nclass Foo2 extends RTDesign:\n  val x  = Bit &lt;&gt; IN\n  val y1 = Bit &lt;&gt; OUT\n  val y2 = Bit &lt;&gt; OUT.REG\n  //wire assignment of x to y1\n  y1     := x \n  //registered assignment of x to y2\n  y2.din := x \n\nclass Foo3 extends EDDesign:\n  val clk = Bit &lt;&gt; IN\n  val x   = Bit &lt;&gt; IN\n  val y1  = Bit &lt;&gt; OUT\n  val y2  = Bit &lt;&gt; OUT\n  process(all):\n    //blocking assignment of x to y1\n    y1 := x \n  process(clk):\n    if (clk.rising)\n      //non-blocking assignment of x to y2\n      y2 :== x \n\nclass Errors1 extends RTDesign:\n  val x  = Bit &lt;&gt; IN\n  val y1 = Bit &lt;&gt; OUT.REG\n  val y2 = Bit &lt;&gt; OUT\n  //error: Cannot assign to an immutable value.\n  x  := 1\n  //error: Cannot assign to a register output; it is immutable.\n  //To assign to the register's input, apply `.din` on the LHS argument of the assignment.\n  y1 := x\n  //error: Non-blocking assignments `:==` are allowed only inside an event-driven (ED) domain.\n  //Change the assignment to a regular assignment `:=` or the logic domain to ED.\n  y2 :== x\n\nclass Errors2 extends EDDesign:\n  val x = Bit &lt;&gt; IN\n  val y = Bit &lt;&gt; OUT\n  //error: Blocking assignments `:=` are only allowed inside a process under an event-driven (ED) domain.\n  //Change the assignment to a connection `&lt;&gt;` or place it in a process.\n  y := x\n  //error: Non-blocking assignments `:==` are only allowed inside a process under an event-driven (ED) domain.\n  //Change the assignment to a connection `&lt;&gt;` or place it in a process.\n  y :== x\n</code></pre> Be sure to read more on assignment rules and semantics in the assignment section.</p>"},{"location":"user-guide/type-system/#dcl-variability","title":"Variability (Not Constant)","text":"<p>DFHDL ports and variables are never considered to be constant (even when connected/assigned only once and to a constant value) for elaboration. Later compilation stages can apply further constant propagation steps that reduce logic utilization. <pre><code>class Errors extends DFDesign:\n  val x  = Bit &lt;&gt; VAR\n  x := 1\n  val c: Bit &lt;&gt; CONST = 1\n  // error: Not a constant\n  val e: Bit &lt;&gt; CONST = x\n</code></pre></p>"},{"location":"user-guide/type-system/#inout-port-limitation","title":"<code>INOUT</code> Port Limitation","text":"<p><code>INOUT</code> (bidirectional) ports are generally used to define IO pins of top-level device connectivity (e.g., protocols like I<sup>2</sup>C benefit from such ability). They are not meant for inter-device wiring reduction, and thus should be used scarcely within their intended purpose. Throughout the years they were also used to workaround HDL limitations like reading from output ports in VHDL'93, or lack of interfaces. Since DFHDL has none of these limitations, we encourage you to use <code>INOUT</code> for their intended purpose only, as synthesis tools for FPGAs and even ASICs will not cooperate. Although, theoretically, in DF domain we can enable bidirectional communication that can later be compiled into two separate ports, there is no real value behind this. <pre><code>class I2CCore extends EDDesign:\n  val scl = Bit &lt;&gt; INOUT\n  val sda = Bit &lt;&gt; INOUT\n</code></pre></p>"},{"location":"user-guide/type-system/#dcl-variability","title":"Grouping","text":"<p>Ports can be grouped together in dedicated interfaces.</p>"},{"location":"user-guide/type-system/#dcl-transitioning","title":"Transitioning","text":"Transitioning from Verilog <p>TODO</p> Transitioning from VHDL <p>TODO</p> Differences from Scala parameters/fields <p>TODO: Data validity, Number of outputs</p>"},{"location":"user-guide/type-system/#DFConst","title":"Constant/Literal Values","text":"<p>In DFHDL there are three methods to construct constant DFHDL values:</p> <ol> <li>Literal value generators: These language constructs directly generate constant DFHDL values. Currently, these are:<ul> <li>Binary <code>Bits</code> string interpolator</li> <li>Hexadecimal <code>Bits</code> string interpolator</li> <li>Decimal string interpolator</li> <li>Signed Decimal string interpolator</li> </ul> </li> <li>Constant candidates: Various Scala values can become DFHDL values, as. Constant declaration syntax<pre><code>val _name_: _dftype_ &lt;&gt; CONST = _value_\n</code></pre></li> <li>Constant value propagation: Cleaners</li> </ol>"},{"location":"user-guide/type-system/#const-syntax","title":"Syntax","text":""},{"location":"user-guide/type-system/#const-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#unconnectable","title":"Unconnectable","text":"<p>Constant values are not connectable, meaning they can never be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.</p>"},{"location":"user-guide/type-system/#unassignable-immutable","title":"Unassignable (Immutable)","text":"<p>Constant values are immutable and cannot be assigned, meaning they can never be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation.</p>"},{"location":"user-guide/type-system/#dfhdl-value-statement-order-referencing","title":"DFHDL Value Statement Order &amp; Referencing","text":"<p>Any DFHDL value must be declared before it can be referenced in code. Other than this (pretty intuitive) limitation, no other limitations exist and ports, variables, constants, and other values may be freely distributed within their approved scope space. During the compilation process, you can notice that the compiler reorders the port declarations so that they always come second to constant declarations, and variables right after.</p>"},{"location":"user-guide/type-system/#connection","title":"DFHDL Value Connections","text":"<p>After ([or during][via-connections]) a design instantiation, its ports need to be connected to other ports or values of the same DFType by applying the <code>&lt;&gt;</code> operator. Variables can also be connected and used as intermediate wiring between ports. Output ports can be directly referenced (read) without being connected to an intermediate variable. For more rules about design and port connectivity, see the relevant section. Successful port/variable connection example<pre><code>class ID extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  //internal connection between ports\n  y &lt;&gt; x \n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre></p> Failed port/variable connection example<pre><code>class Foo extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y1 = Bit     &lt;&gt; OUT\n  val y2 = UInt(8) &lt;&gt; OUT\n  y1 &lt;&gt; x //DFType mismatch error\n  y2 &lt;&gt; x\n  //connection error (cannot connect \n  //to the same port more than once)\n  y2 &lt;&gt; x \n</code></pre>"},{"location":"user-guide/type-system/#assignment","title":"DFHDL Value Assignment (Mutation)","text":"<p>Both output ports and variables are [mutable][mutability] and can be assigned with values of the same DFType and only within the scope of the design they belong to. Input ports cannot be directly assigned, and require an intermediate variable connected to them to modify their value. Generally assignments to DFHDL values are applied through the <code>:=</code> operator. In processes under ED domains there are two kind of assignments: blocking assignments via <code>:=</code>, and non-blocking assignments via <code>:==</code>. Other domains support only blocking assignments via <code>:=</code>. Read more on domain semantics in the [next section][domain-semantics]. See the connectivity section for more rules about mixing connections and assignments.</p> Successful port/variable connection example<pre><code>class Shift extends DFDesign:\n  val x = Bits(8) &lt;&gt; IN\n  val y = Bits(8) &lt;&gt; OUT\n  //assigning `x` left-shifted by 1 \n  //to `y`\n  y := x &lt;&lt; 1\n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre> <p>Don't use <code>var</code> with DFHDL values/designs</p> <p>Because the semantics may get confusing, we enforced a compiler warning if a DFHDL value/design is constructed and fed into a Scala <code>var</code> reference. You can apply a Scala <code>@nowarn</code> annotation to suppress this warning.</p> Warning when using a Scala `var` and suppression example<pre><code>import scala.annotation.nowarn\nclass Foo extends DFDesign:\n  //warning: \n  //Scala `var` modifier for DFHDL \n  //values/designs is highly discouraged!\n  //Consider changing to `val`.   \n  var a = UInt(8) &lt;&gt; IN\n  //this specific warning is suppressed\n  @nowarn(\"msg=Scala `var` modifier for DFHDL\")\n  var ok = UInt(8) &lt;&gt; IN \n</code></pre>"},{"location":"user-guide/type-system/#bit-accurate-operations-and-type-inference","title":"Bit-Accurate Operations and Type Inference","text":"<p>DFHDL provides bit-accurate operations and strong type inference for bit-level manipulations. Here are the key features:</p>"},{"location":"user-guide/type-system/#bit-selection-and-slicing","title":"Bit Selection and Slicing","text":"<pre><code>val b8 = Bits(8) &lt;&gt; VAR\n// Most significant bits selection\nval ms7 = b8(7, 1)    // 7 MSBs\nval ms1 = b8(7, 7)    // MSB only\n\n// Least significant bits selection\nval ls7 = b8(6, 0)    // 7 LSBs\nval ls1 = b8(0, 0)    // LSB only\n\n// Single bit access\nval msbit = b8(7)      // MSB\nval lsbit = b8(0)      // LSB\n</code></pre>"},{"location":"user-guide/type-system/#bit-operations","title":"Bit Operations","text":"<pre><code>val b8 = Bits(8) &lt;&gt; VAR\n\n// Shift operations\nval shifted_left = b8 &lt;&lt; 2    // Logical left shift\nval shifted_right = b8 &gt;&gt; 2   // Logical right shift\n\n// Bit reduction operations\nval or_reduced = b8.|         // OR reduction\nval and_reduced = b8.&amp;        // AND reduction\nval xor_reduced = b8.^        // XOR reduction\n\n// Bit concatenation\nval concat = (b\"100\", b\"1\", b\"0\", b\"11\").toBits  // Creates 8-bit value\n</code></pre>"},{"location":"user-guide/type-system/#multiple-variable-assignment","title":"Multiple Variable Assignment","text":"<pre><code>val b4M, b4L = Bits(4) &lt;&gt; VAR  // Declare multiple variables\nval b3M = Bits(3) &lt;&gt; VAR\nval u5L = UInt(5) &lt;&gt; VAR\n\n// Assign to multiple variables using tuple pattern\n(b4M, b4L) := (h\"1\", 1, 0, b\"11\")  // Values are concatenated and split\n\n// Mix different types in assignment\n(b3M, u5L) := (h\"1\", 1, 0, b\"11\")  // Values automatically cast to appropriate types\n\n// Assign bit slices to multiple variables\n(b4M, b4L) := (u8.bits(3, 0), u8.bits(7, 4))  // Split byte into nibbles\n\n// Complex multiple assignment\n(b4M, b3M, u5L, b4L) := (u8, b8)  // Automatically extracts appropriate bits for each variable\n</code></pre>"},{"location":"user-guide/type-system/#width-inference-and-resizing","title":"Width Inference and Resizing","text":"<pre><code>// Automatic width inference\nval b3 = Bits(3) &lt;&gt; VAR\nval b8 = Bits(8) &lt;&gt; VAR\n\n// Explicit resizing required when widths don't match\nb8 := b3.resize(8)     // Zero-extend to 8 bits\nb3 := b8.resize(3)     // Truncate to 3 bits\n</code></pre>"},{"location":"user-guide/type-system/#bubble","title":"Bubble Values","text":"<ul> <li>RT and ED - Don't Care / Unknown</li> <li>DF - Stall</li> </ul>"},{"location":"user-guide/type-system/#dfhdl-value-candidates","title":"DFHDL Value Candidates","text":"<p>TODO: requires explanation The candidate produces a constant DFHDL value if the candidate argument is a constant.</p> <p>Operation supported values for an argument of DFType <code>T</code></p> `T`Candidate`T`ValueAnyValue`T`OperationCandidate . is! .. is? .. is? .. is! .. is? . Bits assignment and concatenation operation candidates example<pre><code>val b8 = Bits(8) &lt;&gt; VAR //8-bits variable\nval b9 = Bits(9) &lt;&gt; VAR //9-bits variable\n\n//Assignment operations to b8 accept either\n//Bits candidates that are 8-bit wide or\n//a same-element-vector (SEV) of \n//0/1/true/false, via `all(elem)`.\nb8 := h\"FF\"  //ok: 8-bits constant\nb8 := all(0) //ok: SEV of 0\nb8 := 5      //fails `Bits` candidate\nb8 := b9     //fails `:=` candidate\n\n//Bits `++` concatenation operation with b8\n//only accepts Bits candidate, while SEV\n//is not a Bits candidate.\nval x = b8 ++ h\"FF\"  //ok\nval y = b8 ++ all(0) //error\n</code></pre>"},{"location":"user-guide/type-system/#DFBitOrBool","title":"<code>Bit</code>/<code>Boolean</code> DFHDL Values","text":"<p><code>Bit</code> DFHDL values represent binary <code>1</code> or <code>0</code> values, whereas <code>Boolean</code> DFHDL values represent <code>true</code> or <code>false</code> values, respectively. The <code>Bit</code> and <code>Boolean</code> DFHDL values are generally interchangeable, and automatically converted between one and the other. </p> <p>Should I use <code>Bit</code> or <code>Boolean</code> DFTypes?</p> <p>Although they are interchangeable, it's generally recommended to use <code>Boolean</code> DFHDL values with conditional <code>if</code> statements, guards, or expressions, and <code>Bit</code> DFHDL values for everything else. There could be constant parameters that are better defined as a <code>true</code> or <code>false</code> <code>Boolean</code> values rather than <code>0</code> or <code>1</code> <code>Bit</code> values.</p> Why have both <code>Bit</code> and <code>Boolean</code> DFTypes? <p>The main reason to differentiate between <code>Bit</code> and <code>Boolean</code> is that VHDL has both <code>std_logic</code> and <code>boolean</code> types, respectively. Verilog has only a single <code>logic</code> or <code>wire</code> to represent both. Indeed VHDL'2008 has relaxed some of the type constraints, but not enough. And nevertheless, DFHDL aims to support various HDL dialects, and thus enables simple implicit or explicit conversion between these two DFType values.</p>"},{"location":"user-guide/type-system/#dftype-constructors","title":"DFType Constructors","text":"<p>Use the <code>Bit</code> or <code>Boolean</code> objects/types to construct <code>Bit</code> or <code>Boolean</code> DFHDL values, respectively.</p> <pre><code>val bit   = Bit     &lt;&gt; VAR\nval bool  = Boolean &lt;&gt; VAR\nval c_bit:  Bit     &lt;&gt; CONST = 1\nval c_bool: Boolean &lt;&gt; CONST = false\n</code></pre>"},{"location":"user-guide/type-system/#candidates","title":"Candidates","text":"<ul> <li>DFHDL <code>Bit</code> values.</li> <li>DFHDL <code>Boolean</code> values. </li> <li>Scala <code>1</code> or <code>0</code> literal values. A regular Scala <code>Int</code> is not accepted. This candidate always produces a constant DFHDL value.</li> <li>Scala <code>Boolean</code> values. This candidate always produces a constant DFHDL value.</li> </ul> <pre><code>val bit  = Bit     &lt;&gt; VAR\nval bool = Boolean &lt;&gt; VAR\n//`bool` is implicitly converted to a \n//Bit DFHDL value.\nbit := bool \n//`1` is implicitly converted to a DFHDL\n//Bit constant value.\nbit := 1\n//`false` is implicitly converted to a \n//DFHDL Boolean constant, and then\n//converted to a Bit constant value.\nbit := false\nval one: Int = 1\n//error (only 1/0 literals are ok)\nbit := one \n//`bit` is implicitly converted to a\n//DFHDL Boolean\nbool := bit \n//`true` is implicitly converted to a \n//DFHDL Boolean constant value.\nbool := true\n//`0` is implicitly converted to a \n//DFHDL Bit constant, and then\n//converted to a Boolean constant value.\nbool := 0\nval TrueVal: Boolean = 1\n//`TrueVal` is implicitly converted to\n//a DFHDL Boolean value.\nbool := TrueVal \n</code></pre>"},{"location":"user-guide/type-system/#operations","title":"Operations","text":""},{"location":"user-guide/type-system/#explicit-casting-operations","title":"Explicit Casting Operations","text":"<p>These operations propagate constant modifiers, meaning that if the casted argument is a constant, the returned value is also a constant.</p> Operation Description LHS Constraints Returns <code>lhs.bool</code> Cast to a DFHDL <code>Boolean</code> value <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.bit</code> Cast to a DFHDL <code>Bit</code> value <code>Boolean</code> DFHDL value <code>Bit</code> DFHDL value <pre><code>val bt1 = Bit &lt;&gt; VAR\nval bl1 = bt1.bool\nval bl2 = Boolean &lt;&gt; VAR\nval bt2 = bl2.bit\nval bt3: Bit     &lt;&gt; CONST = 0\nval bl3: Boolean &lt;&gt; CONST = bt3.bool\nval bl4: Boolean &lt;&gt; CONST = true\nval bt4: Bit     &lt;&gt; CONST = bt4.bit\n// error: bt1 is not a constant\nval err: Bit     &lt;&gt; CONST = bt1\n</code></pre>"},{"location":"user-guide/type-system/#bit-history-operations","title":"Bit History Operations","text":"<p>Currently these operations are only supported under ED domains. However, in upcoming DFHDL updates, support will be added across all domain abstractions.</p> Operation Description LHS Constraints Returns <code>lhs.rising</code> True when a value changes from <code>0</code> to <code>1</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.falling</code> True when a value changes from <code>1</code> to <code>0</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <pre><code>class Foo extends EDDesign:\n  val clk  = Bit &lt;&gt; IN\n\n  /* VHDL-style */\n  process(clk):\n    if (clk.rising) \n      //some sequential logic\n\n  /* Verilog-style */\n  process(clk.rising):\n    //some sequential logic\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the Verilog <code>posedge x</code> and <code>negedge x</code>, respectively.  In future releases these operations will have an expanded functionality under the other design domains.</p> Transitioning from VHDL <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the VHDL <code>rising_edge(x)</code> and <code>falling_edge(x)</code>, respectively. In future releases these operations will have an expanded functionality under the other design domains.</p> <p>For more information see either the design domains or processes sections.</p>"},{"location":"user-guide/type-system/#logical-operations","title":"Logical Operations","text":"<p>Logical operations' return type always match the LHS argument's type. These operations propagate constant modifiers, meaning that if all arguments are constant, the returned value is also a constant.</p> Operation Description LHS/RHS Constraints Returns <code>lhs &amp;&amp; rhs</code> Logical AND The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs || rhs</code> Logical OR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs ^ rhs</code> Logical XOR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>!lhs</code> Logical NOT The argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. LHS-Type DFHDL value <pre><code>val bt = Bit     &lt;&gt; VAR\nval bl = Boolean &lt;&gt; VAR\nval t1 = bt &amp;&amp; bl    //result type: Bit\nval t2 = bt ^ 1      //result type: Bit\nval t3 = bl || false //result type: Boolean\nval t4 = bt &amp;&amp; true  //result type: Bit\nval t5 = bl || bt    //result type: Boolean\nval t6 = bl ^ 0 || !bt\n//`t7` after the candidate implicit\n//conversions, looks like so:\n//(bl &amp;&amp; bt.bool) ^ (!(bt || bl.bit)).bool\nval t7 = (bl &amp;&amp; bt) ^ !(bt || bl)\n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e1 = 0 ^ bt      \n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e2 = false ^ bt\n//not supported since both arguments\n//are just candidates\nval e3 = 0 ^ true\n//This just yields a Scala Boolean, \n//as a basic operation between Scala\n//Boolean values.\nval sc: Boolean = true &amp;&amp; true\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation Verilog Operation <code>lhs &amp;&amp; rhs</code> <code>lhs &amp; rhs</code> <code>lhs || rhs</code> <code>lhs | rhs</code> <code>lhs ^ rhs</code> <code>lhs ^ rhs</code> <code>!lhs</code> <code>!lhs</code> Transitioning from VHDL <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation VHDL Operation <code>lhs &amp;&amp; rhs</code> <code>lhs and rhs</code> <code>lhs || rhs</code> <code>lhs or rhs</code> <code>lhs ^ rhs</code> <code>lhs xor rhs</code> <code>!lhs</code> <code>not lhs</code>"},{"location":"user-guide/type-system/#constant-meta-operations","title":"Constant Meta Operations","text":"<p>These operations are activated during the elaboration stage of the DFHDL compilation, and are only available for constant <code>Bit</code>/<code>Boolean</code> DFHDL values.  Their use case is for meta-programming purposes, to control the generated code without the knowledge of the DFHDL compiler (could be considered as pre-processing steps).</p> Operation Description LHS Constraints Returns <code>lhs.toScalaBitNum</code> Extracts the known elaboration Scala <code>BitNum</code>(<code>1 | 0</code>) value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>BitNum</code> value <code>lhs.toScalaBoolean</code> Extracts the known elaboration Scala <code>Boolean</code> value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>Boolean</code> value <p>The following runnable example demonstrates how such meta operation affect the elaborated design.  The <code>Boolean</code> argument <code>arg</code> of a design <code>Foo</code> is used twice within the design:  first, in an <code>if</code> condition directly; and second, in an <code>if</code> condition after a Scala value extraction.  When referenced directly, the <code>if</code> is elaborated as-is, but when the <code>if</code> is applied on the extracted Scala value,  the <code>if</code> is completely removed and either the block inside the <code>if</code> is elaborated when the argument is true or completely removed if false.</p> <code>Foo</code><code>Foo(true)</code><code>Foo(false)</code> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n    if (arg.toScalaBoolean) o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n    o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n    val o = Bit &lt;&gt; OUT\n    if (!arg) o := 1 \n</code></pre> Runnable example <pre><code>import dfhdl.*\n\n@top(false) class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n  if (arg.toScalaBoolean) o := 0\n\n@main def main = \n  println(\"Foo(true) Elaboration:\")\n  Foo(true).printCodeString\n  println(\"Foo(false) Elaboration:\")\n  Foo(false).printCodeString</code></pre>"},{"location":"user-guide/type-system/#DFBits","title":"<code>Bits</code> DFHDL Values","text":"<p><code>Bits</code> DFHDL values represent vectors of DFHDL <code>Bit</code> values as elements.  The vector bits width (length) is a positive constant number (nilable [zero-width] vectors will be supported in the future).</p> <p>Differences between DFHDL <code>Bits</code> and DFHDL Vector of <code>Bit</code></p> <p>In addition to <code>Bits</code>, DFHDL also supports generic vectors of any DFHDL values.  One could therefore construct a generic vector with <code>Bit</code> as the element DFType.  This vector has a different type than <code>Bits</code>, since <code>Bits</code> is a special case, both internally  in their implementations and externally in their API. Where applicable, both <code>Bits</code> and generic vector of <code>Bits</code> have overlapping equivalent APIs. </p>"},{"location":"user-guide/type-system/#dftype-constructors_1","title":"DFType Constructors","text":"Constructor Description Arg Constraints Returns <code>Bits(width)</code> Construct a <code>Bits</code> DFType with the given <code>width</code> as number of bits. <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[width.type]</code> DFType <code>Bits.until(sup)</code> Construct a <code>Bits</code> DFType with the given <code>sup</code> supremum number the vector is expected to reach. The number of bits is set as <code>clog2(sup)</code>. <code>sup</code> is a Scala <code>Int</code> or constant DFHDL <code>Int</code> value larger than 1. <code>Bits[CLog2[width.type]]</code> DFType <code>Bits.to(max)</code> Construct a <code>Bits</code> DFType with the given <code>max</code> maximum number the vector is expected to reach. The number of bits is set as <code>clog2(max+1)</code>. <code>max</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[CLog2[width.type+1]]</code> DFType <code>Bits[W]</code> Construct a <code>Bits</code> DFType with the given <code>W</code> width as Scala type argument (for advanced users). <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> Singleton type. <code>Bits[W]</code> DFType <pre><code>val b8 = Bits(8)       &lt;&gt; VAR\nval b3 = Bits.until(8) &lt;&gt; VAR\nval b4 = Bits.to(8)    &lt;&gt; VAR\nval b9 = Bits[9]       &lt;&gt; VAR\nval w: Int &lt;&gt; CONST = 7\nval b7 = Bits(w)       &lt;&gt; VAR\nval b6: Bits[6] &lt;&gt; CONST = all(0)\n</code></pre> Transitioning from Verilog <ul> <li>Specifying a width instead of an index range: In Verilog bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>[width-1:0]</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common Verilog bit vector declaration. For example, instead of declaring <code>reg [$clog2(DEPTH)-1:0] addr</code> in Verilog, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul> Transitioning from VHDL <ul> <li>Specifying a width instead of an index range: In VHDL bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>(width-1 downto 0)</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common VHDL bit vector declaration. For example, instead of declaring <code>signal addr: std_logic_vector(clog2(DEPTH)-1 downto 0)</code> in VHDL, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul>"},{"location":"user-guide/type-system/#literal-constant-value-generation","title":"Literal (Constant) Value Generation","text":"<p>Literal (constant) DFHDL <code>Bits</code> value generation is carried out through binary and hexadecimal string interpolation, a core Scala feature that was customized for DFHDL's exact use-case. There are also bit-accurate decimal and signed decimal interpolations available that produce <code>UInt</code> and <code>SInt</code> DFHDL values. If needed, those values can be cast to <code>Bits</code>. No octal interpolation is currently available or planned.</p>"},{"location":"user-guide/type-system/#b-interp","title":"Binary Bits String-Interpolator","text":"Binary Bits string-interpolation syntax<pre><code>b\"width'bin\"\n</code></pre> <ul> <li>bin is a sequence of <code>0</code>, <code>1</code>, and <code>?</code> characters, each representing a single bit.  <code>?</code> indicates a bit bubble.    The leftest (first) character is the most-significant bit (MSB), and the rightest (last) character is    the least-significant bit (LSB). </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>bin</code> are ignored.</li> <li><code>bin</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>width, followed by a <code>'</code> (apostrophe), is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added at the left of the sequence or the sequence is truncated based on the <code>width</code>.    Truncation only occurs if the MSBits being removed are zeros; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Binary Bits string-interpolation examples<pre><code>b\"1\"        // Value = 1\nb\"1000\"     // Value = 1000\nb\"8'1000\"   // Value = 00001000\nb\"3'0100\"   // Value = 100\nb\"3'1100\"   // Compilation error\nb\"1?11\"     // Value = 1?11 (? indicates a bit bubble)\nb\"11_00\"    // Value = 1100\nval value = \"100\"\nval width = 10\nb\"$width'1${value}1\" //Value = 0000011001\nval p: Int &lt;&gt; CONST = 10\nb\"$p'0\" // Value = 0....0 (p-bits wide)\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#h-interp","title":"Hexadecimal Bits String-Interpolator","text":"Hexadecimal Bits string-interpolation syntax<pre><code>h\"width'hex\"\n</code></pre> <ul> <li>hex is a sequence of hexadecimal characters (<code>0</code>-<code>9</code>, <code>A</code>-<code>F</code>, <code>a</code>-<code>f</code>, and <code>?</code>)   where <code>?</code> indicates a 4-bit bubble. Each character represents a 4-bit nibble,    encoded such that the leftest bit is the most-significant bit.    The leftest (first) character is the most-significant nibble, and the rightest (last) character is    the least-significant nibble. </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>hex</code> are ignored.</li> <li><code>hex</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>Binary sequences can be embedded within <code>{bin}</code> tags, allowing integration of binary   bit sequences of any length, not necessarily divisible by 4, between hex nibbles.</li> <li>width, followed by a <code>'</code>, is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added or the sequence is truncated based on the <code>width</code>. Truncation only occurs if   the most significant bits being removed are zeros or bubbles; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Hexadecimal Bits string-interpolation examples<pre><code>h\"1\"        // Value = 0001\nh\"27\"       // Value = 00100111\nh\"6'27\"     // Value = 100111\nh\"5'27\"     // Compilation error\nh\"2?\"       // Value = 0010????\nh\"F{00}F\"   // Value = 1111001111\nh\"3_3\"      // Value = 00110011\nval value = \"FF\"\nval width = 10\nh\"$width'${value}\" //Value = 0011111111\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#candidates_1","title":"Candidates","text":"<ul> <li>DFHDL <code>Bits</code> values</li> <li>DFHDL <code>Bit</code> or <code>Boolean</code> values. This candidate produces a single bit <code>Bits[1]</code> vector. </li> <li>DFHDL <code>UInt</code> values</li> <li>Scala <code>Tuple</code> combination of any DFHDL values and <code>1</code>/<code>0</code> literal values. This candidate performs bit concatenation of all values, according their order in the tuple, encoded from the most-significant value position down to the least-significant value position.</li> <li>Application-only candidate - Same-Element Vector (<code>all(elem)</code>).  </li> </ul> <pre><code>val b8   = Bits(8) &lt;&gt; VAR\nval b1   = Bits(1) &lt;&gt; VAR\n//`bit` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bit  = Bit     &lt;&gt; VAR\nb1 := bit\n//`bool` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bool = Boolean &lt;&gt; VAR\nbool := bit\n//`u8` is implicitly converted to a \n//Bits[8] DFHDL value.\nval u8   = UInt(8) &lt;&gt; VAR\nb8 := u8\nval s4   = SInt(4) &lt;&gt; VAR\n//the tuple is implicitly converted\n//to a Bits[8] DFHDL value.\nb8 := (1, s4, b1, b\"10\")\n</code></pre>"},{"location":"user-guide/type-system/#concatenated-assignment","title":"Concatenated Assignment","text":"<p>DFHDL supports a special-case assignment of concatenated DFHDL Bits variables, using a Scala <code>Tuple</code> syntax on LHS of the assignment operator. Both LHS and RHS bits width must be the same. This assignment is just syntactic sugar for multiple separate assignments and carried out during the design elaboration. The assignment ordering is from the first value at most-significant position down to the last value at least-significant position.</p> <code>Foo Declaration</code><code>Foo Elaboration</code> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")\n</code></pre> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  b2 := b\"10\"\n  b5 := (b\"1\", i4).toBits\n  b3 := b\"111\"\n</code></pre> Runnable example <pre><code>import dfhdl.*\n\n//print the code after elaboration\ngiven options.ElaborationOptions.PrintDFHDLCode = true\n//set mode to elaborate only\ngiven options.AppOptions.DefaultMode = options.AppOptions.DefaultMode.elaborate\n\n@top class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")</code></pre>"},{"location":"user-guide/type-system/#DFDecimal","title":"<code>UInt</code>/<code>SInt</code>/<code>Int</code> DFHDL Values","text":"<p>DFHDL provides three decimal numeric types: - <code>UInt</code> - Unsigned integer values - <code>SInt</code> - Signed integer values - <code>Int</code> - Constant integer values (used mainly for parameters)</p>"},{"location":"user-guide/type-system/#dftype-constructors_2","title":"DFType Constructors","text":"Constructor Description Arg Constraints Returns <code>UInt(width)</code> Construct an unsigned integer DFType with the given <code>width</code> as number of bits. <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>UInt[width.type]</code> DFType <code>UInt.until(sup)</code> Construct an unsigned integer DFType with the given <code>sup</code> supremum number the value is expected to reach. The number of bits is set as <code>clog2(sup)</code>. <code>sup</code> is a Scala <code>Int</code> or constant DFHDL <code>Int</code> value larger than 1. <code>UInt[CLog2[width.type]]</code> DFType <code>UInt.to(max)</code> Construct an unsigned integer DFType with the given <code>max</code> maximum number the value is expected to reach. The number of bits is set as <code>clog2(max+1)</code>. <code>max</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>UInt[CLog2[width.type+1]]</code> DFType <code>SInt(width)</code> Construct a signed integer DFType with the given <code>width</code> as number of bits. <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>SInt[width.type]</code> DFType <code>Int</code> Construct a constant integer DFType. Used mainly for parameters. None <code>Int</code> DFType"},{"location":"user-guide/type-system/#candidates_2","title":"Candidates","text":"<ul> <li>DFHDL decimal values of the same type</li> <li>DFHDL <code>Bits</code> values (via <code>.uint</code> or <code>.sint</code> casting)</li> <li>Scala numeric values (Int, Long, etc.) for constant values</li> <li>Decimal string interpolation values</li> </ul>"},{"location":"user-guide/type-system/#operations_1","title":"Operations","text":""},{"location":"user-guide/type-system/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>These operations propagate constant modifiers and maintain proper bit widths:</p> Operation Description LHS/RHS Constraints Returns <code>lhs + rhs</code> Addition Both decimal types Result with appropriate width <code>lhs - rhs</code> Subtraction Both decimal types Result with appropriate width <code>lhs * rhs</code> Multiplication Both decimal types Result with width = lhs.width + rhs.width <code>lhs / rhs</code> Division Both decimal types Result with lhs width <code>lhs % rhs</code> Modulo Both decimal types Result with rhs width"},{"location":"user-guide/type-system/#comparison-operations","title":"Comparison Operations","text":"<p>Return Boolean values:</p> Operation Description LHS/RHS Constraints Returns <code>lhs &lt; rhs</code> Less than Both decimal types Boolean <code>lhs &lt;= rhs</code> Less than or equal Both decimal types Boolean <code>lhs &gt; rhs</code> Greater than Both decimal types Boolean <code>lhs &gt;= rhs</code> Greater than or equal Both decimal types Boolean <code>lhs == rhs</code> Equal Both decimal types Boolean <code>lhs != rhs</code> Not equal Both decimal types Boolean"},{"location":"user-guide/type-system/#constant-generation","title":"Constant Generation","text":""},{"location":"user-guide/type-system/#d-interp","title":"Decimal String-Interpolator","text":"<p>The decimal string interpolator <code>d</code> creates unsigned/signed integer constants (<code>UInt</code>) from decimal values.</p> Decimal string-interpolation syntax<pre><code>d\"width'dec\"\n</code></pre> <ul> <li>dec is a sequence of decimal characters ('0'-'9') with an optional prefix <code>-</code> for negative values</li> <li>width followed by a <code>'</code> is optional and specifies the exact width of the integer's bit representation</li> <li>Separators <code>_</code> (underscore) and <code>,</code> (comma) within <code>dec</code> are ignored</li> <li>If width is omitted, it is inferred from the value's size</li> <li>If specified, the output is padded with zeros or extended for signed numbers using two's complement</li> <li>Returns an unsigned <code>UInt[W]</code> for natural numbers and signed <code>SInt[W]</code> for negative numbers, where <code>W</code> is the width in bits</li> <li>An error occurs if the specified width is less than required to represent the value</li> </ul> <p>Examples: <pre><code>d\"0\"      // UInt[1], value = 0\nd\"-1\"     // SInt[2], value = -1 \nd\"8'-1\"   // SInt[8], value = -1\nd\"255\"    // UInt[8], value = 255\nd\"1,023\"  // UInt[10], value = 1023\nd\"1_000\"  // UInt[10], value = 1000\n</code></pre></p>"},{"location":"user-guide/type-system/#sd-interp","title":"Signed Decimal String-Interpolator","text":"<p>The signed decimal string interpolator <code>sd</code> creates signed integer constants (<code>SInt</code>) from decimal values.</p> Signed decimal string-interpolation syntax<pre><code>sd\"width'dec\"\n</code></pre> <ul> <li>dec is a sequence of decimal characters ('0'-'9') with an optional prefix <code>-</code> for negative values</li> <li>width followed by a <code>'</code> is optional and specifies the exact width of the integer's bit representation</li> <li>Separators <code>_</code> (underscore) and <code>,</code> (comma) within <code>dec</code> are ignored</li> <li>Output is always a signed integer type <code>SInt[W]</code>, regardless of whether the value is negative or natural</li> <li>Width is always at least 2 bits to accommodate the sign bit</li> <li>An error occurs if the specified width is less than required to represent the value including the sign bit</li> </ul> <p>Examples: <pre><code>sd\"0\"     // SInt[2], value = 0 (natural number represented as signed)\nsd\"-1\"    // SInt[2], value = -1\nsd\"255\"   // SInt[9], value = 255 (natural number represented as signed)\nsd\"8'42\"  // SInt[8], value = 42\nsd\"8'255\" // Error: width too small to represent value with sign bit\n</code></pre></p>"},{"location":"user-guide/type-system/#examples","title":"Examples","text":"<pre><code>// Basic declarations\nval u8 = UInt(8) &lt;&gt; VAR      // 8-bit unsigned\nval s8 = SInt(8) &lt;&gt; VAR      // 8-bit signed\nval param: Int &lt;&gt; CONST = 42  // Constant parameter\n\n// Arithmetic\nval sum = u8 + s8.uint       // Addition with casting\nval diff = s8 - 5            // Subtraction with constant\nval prod = u8 * u8           // Multiplication\n\n// Comparisons\nval lt = u8 &lt; 100\nval eq = s8 == sd\"8'0\"\n\n// Initialization\nval u4 = UInt(4) &lt;&gt; VAR init d\"4'10\"\nval s4 = SInt(4) &lt;&gt; VAR init sd\"4'-2\"\n</code></pre>"},{"location":"user-guide/type-system/#DFEnum","title":"Enumeration DFHDL Values","text":"<p>DFHDL supports enumerated types through Scala's enum feature with special encoding traits. Enums provide a type-safe way to represent a fixed set of values.</p>"},{"location":"user-guide/type-system/#enum-type-definition","title":"Enum Type Definition","text":"<pre><code>enum MyEnum extends Encoded:\n  case A, B, C, D\n</code></pre>"},{"location":"user-guide/type-system/#encoding-types","title":"Encoding Types","text":"<p>DFHDL supports several encoding schemes for enums:</p> <ol> <li> <p>Binary Encoded (default) <pre><code>enum MyEnum extends Encoded:\n  case A, B, C, D  // Encoded as 0,1,2,3\n</code></pre></p> </li> <li> <p>One-Hot Encoded <pre><code>enum MyEnum extends Encoded.OneHot:\n  case A, B, C  // Encoded as 001,010,100\n</code></pre></p> </li> <li> <p>Gray Encoded <pre><code>enum MyEnum extends Encoded.Grey:\n  case A, B, C  // Encoded as 00,01,11\n</code></pre></p> </li> <li> <p>Custom Start Value <pre><code>enum MyEnum extends Encoded.StartAt(10):\n  case A, B, C  // Encoded as 10,11,12\n</code></pre></p> </li> <li> <p>Manual Encoding <pre><code>enum MyEnum(val value: UInt[8] &lt;&gt; CONST) extends Encoded.Manual(8):\n  case A extends MyEnum(200)\n  case B extends MyEnum(100)\n  case C extends MyEnum(50)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/type-system/#operations_2","title":"Operations","text":"Operation Description LHS/RHS Constraints Returns <code>lhs == rhs</code> Equality comparison Same enum type Boolean <code>lhs != rhs</code> Inequality comparison Same enum type Boolean <code>lhs.bits</code> Get raw bits representation Enum value Bits <code>lhs.uint</code> Get unsigned int representation Enum value UInt"},{"location":"user-guide/type-system/#pattern-matching","title":"Pattern Matching","text":"<p>Enums can be used in pattern matching expressions:</p> <pre><code>val state = MyEnum &lt;&gt; VAR\n\nstate match\n  case MyEnum.A =&gt; // handle A\n  case MyEnum.B =&gt; // handle B\n  case MyEnum.C =&gt; // handle C\n</code></pre>"},{"location":"user-guide/type-system/#examples_1","title":"Examples","text":"<pre><code>// State machine enum\nenum State extends Encoded.OneHot:\n  case Idle, Fetch, Execute, Store\n\nclass CPU extends RTDesign:\n  val state = State &lt;&gt; VAR.REG init State.Idle\n\n  state match\n    case State.Idle =&gt; \n      // Idle state logic\n    case State.Fetch =&gt;\n      // Fetch state logic\n    case State.Execute =&gt;\n      // Execute state logic\n    case State.Store =&gt;\n      // Store state logic\n</code></pre>"},{"location":"user-guide/type-system/#DFVector","title":"Vector DFHDL Values","text":"<p>DFHDL vectors allow creating arrays of any DFHDL type. Unlike <code>Bits</code> which is specialized for bit vectors, generic vectors can hold any DFHDL type and support multi-dimensional arrays.</p>"},{"location":"user-guide/type-system/#vector-type-construction","title":"Vector Type Construction","text":"<p>The vector type is constructed using the <code>X</code> operator between a base type and dimension:</p> <pre><code>val vec = BaseType X Dimension &lt;&gt; Modifier\n</code></pre> <p>Examples: <pre><code>val vec1 = UInt(8) X 4 &lt;&gt; VAR        // 1D vector of 4 8-bit unsigned ints\nval vec2 = Bit X 8 X 8 &lt;&gt; VAR        // 2D 8x8 vector of bits\nval vec3 = MyEnum X 16 &lt;&gt; VAR        // Vector of 16 enum values\n</code></pre></p>"},{"location":"user-guide/type-system/#initialization","title":"Initialization","text":"<p>Vectors can be initialized in several ways:</p> <pre><code>// Initialize all elements to same value\nval vec1 = UInt(8) X 4 &lt;&gt; VAR init all(0)\n\n// Initialize with specific values\nval vec2 = UInt(8) X 4 &lt;&gt; VAR init Vector(1, 2, 3, 4)\n\n// Initialize from file\nval mem = UInt(32) X 1024 &lt;&gt; VAR initFile \"mem.hex\"\n</code></pre>"},{"location":"user-guide/type-system/#operations_3","title":"Operations","text":""},{"location":"user-guide/type-system/#element-access","title":"Element Access","text":"<p>Access individual elements using array indexing:</p> <pre><code>val elem = vec(idx)     // Read element at index\nvec(idx) := newValue    // Write element at index\n</code></pre>"},{"location":"user-guide/type-system/#vector-wide-operations","title":"Vector-wide Operations","text":"Operation Description Returns <code>vec.elements</code> Get all elements as Scala sequence Seq[BaseType] <code>vec.size</code> Get vector dimension Int <code>vec.bits</code> Get bits representation Bits"},{"location":"user-guide/type-system/#multi-dimensional-vectors","title":"Multi-dimensional Vectors","text":"<p>Multi-dimensional vectors are created by chaining <code>X</code> operators:</p> <pre><code>// 2D 4x4 matrix of 8-bit values\nval matrix = UInt(8) X 4 X 4 &lt;&gt; VAR\n\n// Access elements\nval elem = matrix(row)(col)\nmatrix(1)(2) := 42\n\n// Initialize 2D array\nmatrix := all(all(0))  // All elements to 0\n</code></pre>"},{"location":"user-guide/type-system/#memoryram-implementation","title":"Memory/RAM Implementation","text":"<p>Vectors are commonly used to implement memories and RAMs:</p> <pre><code>class RAM extends RTDesign:\n  val addr = UInt(10) &lt;&gt; IN           // 10-bit address\n  val data = UInt(32) &lt;&gt; INOUT        // 32-bit data\n  val we   = Bit &lt;&gt; IN               // Write enable\n\n  val mem = UInt(32) X 1024 &lt;&gt; VAR.SHARED  // 1K x 32-bit memory\n\n  if (we) mem(addr) := data          // Write\n  data := mem(addr)                  // Read\n</code></pre>"},{"location":"user-guide/type-system/#file-initialization","title":"File Initialization","text":"<p>Vectors support initialization from files in various formats:</p> <pre><code>// Initialize from hex file\nval rom = UInt(8) X 256 &lt;&gt; VAR initFile(\"rom.hex\", InitFileFormat.VerilogHex)\n\n// Initialize from binary file\nval ram = UInt(32) X 1024 &lt;&gt; VAR initFile \"ram.bin\"\n</code></pre>"},{"location":"user-guide/type-system/#DFStruct","title":"Struct DFHDL Values","text":"<p>DFHDL structures allow creating composite types by combining multiple DFHDL values into a single type. Structs are defined using Scala case classes that extend the <code>Struct</code> trait.</p>"},{"location":"user-guide/type-system/#struct-type-definition","title":"Struct Type Definition","text":"<pre><code>case class MyStruct(\n  field1: UInt[8] &lt;&gt; VAL,\n  field2: Bits[4] &lt;&gt; VAL,\n  field3: Boolean &lt;&gt; VAL\n) extends Struct\n</code></pre>"},{"location":"user-guide/type-system/#field-access-and-assignment","title":"Field Access and Assignment","text":"<p>Fields are accessed using dot notation and can be assigned individually:</p> <pre><code>val s = MyStruct &lt;&gt; VAR\ns.field1 := 42          // Assign to individual field\ns.field2 := b\"1010\"     // Assign bits\ns := MyStruct(1, b\"0101\", true)  // Assign whole struct\n</code></pre>"},{"location":"user-guide/type-system/#nested-structs","title":"Nested Structs","text":"<p>Structs can be nested to create more complex data structures:</p> <pre><code>case class Point(x: UInt[8] &lt;&gt; VAL, y: UInt[8] &lt;&gt; VAL) extends Struct\ncase class Rectangle(topLeft: Point &lt;&gt; VAL, bottomRight: Point &lt;&gt; VAL) extends Struct\n\nval rect = Rectangle &lt;&gt; VAR\nrect.topLeft.x := 0\nrect.bottomRight.y := 100\n</code></pre>"},{"location":"user-guide/type-system/#operations_4","title":"Operations","text":"Operation Description LHS/RHS Constraints Returns <code>lhs == rhs</code> Equality comparison Same struct type Boolean <code>lhs != rhs</code> Inequality comparison Same struct type Boolean <code>lhs.bits</code> Get raw bits representation Struct value Bits"},{"location":"user-guide/type-system/#pattern-matching_1","title":"Pattern Matching","text":"<p>Structs support pattern matching for field extraction:</p> <pre><code>val point = Point &lt;&gt; VAR\npoint match\n  case Point(x, y) if x &gt; 10 =&gt; // Use x and y\n  case Point(0, _) =&gt; // Match x=0, any y\n</code></pre>"},{"location":"user-guide/type-system/#examples_2","title":"Examples","text":"<pre><code>// AXI-like interface struct\ncase class AXILite(\n  addr: UInt[32] &lt;&gt; VAL,\n  data: Bits[64] &lt;&gt; VAL,\n  valid: Bit &lt;&gt; VAL,\n  ready: Bit &lt;&gt; VAL\n) extends Struct\n\nclass MyDesign extends RTDesign:\n  val axi = AXILite &lt;&gt; OUT.REG\n\n  // Initialize struct\n  axi := AXILite(0, all(0), 0, 1)\n\n  // Access individual fields\n  axi.valid := 1\n  axi.data := h\"DEADBEEF\"\n</code></pre>"},{"location":"user-guide/type-system/#DFTuple","title":"Tuple DFHDL Values","text":"<p>DFHDL tuples provide a way to group multiple DFHDL values together without defining a named structure. They are similar to Scala tuples but operate on DFHDL values.</p>"},{"location":"user-guide/type-system/#tuple-type-construction","title":"Tuple Type Construction","text":"<pre><code>val tuple = (Type1, Type2, ..., TypeN) &lt;&gt; Modifier\n</code></pre>"},{"location":"user-guide/type-system/#examples_3","title":"Examples","text":"<pre><code>// Basic tuple declaration\nval pair = (UInt(8), Bit) &lt;&gt; VAR\n\n// Nested tuples\nval complex = ((UInt(8), Bit), Bits(4)) &lt;&gt; VAR\n\n// Assignment\npair := (42, 1)\ncomplex := ((100, 0), b\"1010\")\n</code></pre>"},{"location":"user-guide/type-system/#element-access_1","title":"Element Access","text":"<p>Tuple elements can be accessed using ._N notation or pattern matching:</p> <pre><code>val first = pair._1    // Access first element\nval second = pair._2   // Access second element\n\n// Pattern matching\nval (x, y) = pair\n</code></pre>"},{"location":"user-guide/type-system/#operations_5","title":"Operations","text":"Operation Description Returns <code>tuple.bits</code> Get bits representation Bits <code>tuple == other</code> Equality comparison Boolean <code>tuple != other</code> Inequality comparison Boolean"},{"location":"user-guide/type-system/#DFOpaque","title":"Opaque DFHDL Values","text":"<p>Opaque types allow creating new DFHDL types that wrap existing types while hiding their internal representation. This is useful for creating abstraction layers and type-safe interfaces.</p>"},{"location":"user-guide/type-system/#opaque-type-definition","title":"Opaque Type Definition","text":"<pre><code>// Define opaque type wrapping UInt(8)\ncase class MyOpaque() extends Opaque(UInt(8))\n\n// Define opaque type with custom operations\ncase class Counter() extends Opaque(UInt(32)):\n  extension (c: Counter &lt;&gt; VAL)\n    def increment: Counter &lt;&gt; DFRET = \n      (c.actual + 1).as(Counter)\n</code></pre>"},{"location":"user-guide/type-system/#usage","title":"Usage","text":"<pre><code>val op = MyOpaque &lt;&gt; VAR\nval wrapped: UInt[8] &lt;&gt; VAL = op.actual  // Access wrapped value\nop := 42.as(MyOpaque)  // Assign using .as conversion\n</code></pre>"},{"location":"user-guide/type-system/#examples_4","title":"Examples","text":"<pre><code>// AES byte type with custom operations\ncase class AESByte() extends Opaque(UInt(8)):\n  extension (lhs: AESByte &lt;&gt; VAL)\n    def +(rhs: AESByte &lt;&gt; VAL): AESByte &lt;&gt; DFRET =\n      (lhs.actual ^ rhs.actual).as(AESByte)\n\nclass AESCircuit extends DFDesign:\n  val in1 = AESByte &lt;&gt; IN\n  val in2 = AESByte &lt;&gt; IN\n  val out = AESByte &lt;&gt; OUT\n\n  out := in1 + in2  // Uses custom + operation\n</code></pre>"},{"location":"user-guide/type-system/#DFDouble","title":"Double DFHDL Values","text":"<p>DFHDL Double values represent IEEE-754 double-precision floating-point numbers.</p>"},{"location":"user-guide/type-system/#type-construction","title":"Type Construction","text":"<pre><code>val d = Double &lt;&gt; Modifier\n</code></pre>"},{"location":"user-guide/type-system/#operations_6","title":"Operations","text":"<p>Supports standard arithmetic operations:</p> <pre><code>val d1 = Double &lt;&gt; VAR\nval d2 = Double &lt;&gt; VAR\n\nval sum = d1 + d2\nval prod = d1 * d2\nval quot = d1 / d2\nval comp = d1 &lt; d2\n</code></pre>"},{"location":"user-guide/type-system/#conversion","title":"Conversion","text":"<pre><code>val bits = d1.bits        // Get bits representation\nval d3 = bits.as(Double)  // Convert back to Double\n</code></pre>"},{"location":"user-guide/type-system/#DFPhysical","title":"Time/Freq DFHDL Values","text":"<p>DFHDL provides special types for representing time and frequency values in hardware designs through physical units. These types help ensure correct timing specifications and frequency calculations.</p>"},{"location":"user-guide/type-system/#time-values","title":"Time Values","text":"<p>Time values can be created using various unit suffixes:</p> <pre><code>// Time unit constructors\nval t1 = 1.fs     // Femtoseconds\nval t2 = 1.ps     // Picoseconds\nval t3 = 1.ns     // Nanoseconds\nval t4 = 1.us     // Microseconds\nval t5 = 1.ms     // Milliseconds\nval t6 = 1.sec    // Seconds\nval t7 = 1.min    // Minutes\nval t8 = 1.hr     // Hours\n</code></pre> <p>Both integer and floating-point values can be used with time units: <pre><code>val t9 = 1.5.ns   // 1.5 nanoseconds\nval t10 = 10.ms   // 10 milliseconds\n</code></pre></p>"},{"location":"user-guide/type-system/#frequency-values","title":"Frequency Values","text":"<p>Frequency values can be specified using standard frequency units:</p> <pre><code>// Frequency unit constructors\nval f1 = 1.Hz     // Hertz\nval f2 = 1.KHz    // Kilohertz\nval f3 = 1.MHz    // Megahertz\nval f4 = 1.GHz    // Gigahertz\n</code></pre> <p>Like time values, both integer and floating-point values are supported: <pre><code>val f5 = 100.MHz  // 100 megahertz\nval f6 = 2.5.GHz  // 2.5 gigahertz\n</code></pre></p>"},{"location":"user-guide/type-system/#usage-in-rt-domains","title":"Usage in RT Domains","text":"<p>Physical values are particularly useful when configuring RT domains and specifying clock frequencies:</p> <pre><code>class TimingExample extends RTDesign:\n  // Clock configuration with 100MHz frequency\n  val clkCfg = ClkCfg(\n    edge = ClkCfg.Edge.Rising,\n    rate = 100.MHz,\n    portName = \"clk\"\n  )\n\n  // Timing calculations\n  val period = 10.ns      // Clock period\n  val setupTime = 1.ns    // Setup time requirement\n  val clockFreq = 1.GHz   // Clock frequency\n</code></pre>"},{"location":"user-guide/type-system/#cycles-in-rt-domain","title":"Cycles in RT Domain","text":"<p>In RT domains, you can also specify cycle counts using the <code>.cy</code> unit:</p> <pre><code>class RTExample extends RTDesign:\n  val delay = 5.cy    // 5 clock cycles delay\n</code></pre> <p>Note: The <code>.cy</code> unit is only available within register-transfer (RT) domains.</p>"},{"location":"user-guide/type-system/#DFUnit","title":"Unit (Void) DFHDL Values","text":"<p>The Unit type in DFHDL represents a void or no-value type, similar to Scala's Unit type. It's typically used when an operation doesn't need to return a meaningful value.</p>"},{"location":"user-guide/type-system/#usage_1","title":"Usage","text":"<pre><code>// Method returning Unit\ndef doSomething: Unit &lt;&gt; DFRET =\n  // Perform operations without returning value\n  ()\n\n// Assignment that produces no value\nval x = Bit &lt;&gt; VAR\nval y: Unit &lt;&gt; VAL = x := 1\n</code></pre>"},{"location":"user-guide/type-system/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Side-effect operations</li> <li>Void method returns</li> <li>Assignment results</li> <li>Process bodies in event-driven designs</li> </ol> <pre><code>class Example extends EDDesign:\n  val clk = Bit &lt;&gt; IN\n\n  process(clk.rising):\n    // Process body returns Unit\n    doSomething\n</code></pre>"}]}